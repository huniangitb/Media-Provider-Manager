--- PROJECT STRUCTURE (APP ONLY) ---
.
./LICENSE
./README.md
./README_zh-CN.md
./app
./app/build.gradle
./app/proguard-rules.pro
./app/src
./app/src/main
./app/src/main/AndroidManifest.xml
./app/src/main/aidl
./app/src/main/assets
./app/src/main/java
./app/src/main/res
./settings.gradle
./ai.sh
./android_logic_clean.txt
./android_app_logic.txt

--- CORE LOGIC CONTENTS ---

================================================
FILE: ./app/build.gradle
================================================
```
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'androidx.navigation.safeargs.kotlin'
apply plugin: 'com.google.devtools.ksp'
apply plugin: 'dagger.hilt.android.plugin'

def gitCommitCount = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim())
def sdk = 34

android {
    compileSdk sdk
    buildToolsVersion = '34.0.0'

    defaultConfig {
        applicationId 'me.gm.cleaner.plugin'
        minSdk 29
        targetSdk sdk
        versionCode gitCommitCount
        versionName 'beta12'
        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
        multiDexEnabled false
        resourceConfigurations += ['en', 'zh-rCN', 'zh-rTW']
    }
    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            outputFileName = "Media Provider Manager_${defaultConfig.versionName}-${variant.buildType.name}.apk"
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    buildFeatures {
        aidl true
        viewBinding true
        buildConfig = true
    }
    lint {
        abortOnError = false
        checkReleaseBuilds = false
    }
    namespace 'me.gm.cleaner.plugin'
    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17
    }
}

dependencies {
    compileOnly 'de.robv.android.xposed:api:82'
    implementation 'androidx.core:core-ktx:1.13.1'
    implementation 'androidx.fragment:fragment-ktx:1.7.0'
    def lifecycleVersion = '2.7.0'
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycleVersion"
    def media3Version = '1.3.1'
    implementation "androidx.media3:media3-exoplayer:$media3Version"
    implementation "androidx.media3:media3-ui:$media3Version"
    implementation "androidx.navigation:navigation-fragment-ktx:$rootProject.navigationVersion"
    implementation "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"
    implementation 'androidx.preference:preference-ktx:1.2.1'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.recyclerview:recyclerview-selection:1.1.0'
    def roomVersion = '2.6.1'
    annotationProcessor "androidx.room:room-compiler:$roomVersion"
    ksp "androidx.room:room-compiler:$roomVersion"
    implementation "androidx.room:room-ktx:$roomVersion"
    implementation "androidx.room:room-runtime:$roomVersion"
    implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
    implementation 'com.caverock:androidsvg:1.4'
    def glideVersion = '4.16.0'
    implementation "com.github.bumptech.glide:glide:$glideVersion"
    ksp "com.github.bumptech.glide:ksp:$glideVersion"
    implementation 'com.google.android.material:material:1.12.0'
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation "com.google.dagger:hilt-android:$rootProject.hiltVersion"
    ksp "com.google.dagger:hilt-android-compiler:$rootProject.hiltVersion"
    def retrofitVersion = '2.9.0'
    implementation "com.squareup.retrofit2:converter-gson:$retrofitVersion"
    implementation "com.squareup.retrofit2:converter-scalars:$retrofitVersion"
    implementation "com.squareup.retrofit2:retrofit:$retrofitVersion"
    implementation 'dev.rikka.rikkax.recyclerview:recyclerview-ktx:1.3.2'
    def markwonVersion = '4.6.2'
    implementation "io.noties.markwon:core:$markwonVersion"
    implementation "io.noties.markwon:ext-strikethrough:$markwonVersion"
    implementation "io.noties.markwon:html:$markwonVersion"
    implementation "io.noties.markwon:image:$markwonVersion"
    def appIconLoaderVersion = '1.5.0'
    implementation "me.zhanghai.android.appiconloader:appiconloader:$appIconLoaderVersion"
    implementation "me.zhanghai.android.appiconloader:appiconloader-glide:$appIconLoaderVersion"
    implementation 'me.zhanghai.android.fastscroll:library:1.3.0'
    def kotlinxCoroutinesVersion = '1.8.0'
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlinxCoroutinesVersion"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinxCoroutinesVersion"
    implementation 'org.lsposed.hiddenapibypass:hiddenapibypass:4.3'
    implementation project(':photoview')
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.25'

    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.13'
}

```

================================================
FILE: ./app/src/main/AndroidManifest.xml
================================================
```
<?xml version="1.0" encoding="utf-8"?>

<!--
  ~ Copyright 2021 Green Mushroom
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="32" />
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:name=".app.App"
        android:label="@string/app_name"
        android:largeHeap="true"
        android:multiArch="true"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity
            android:name=".app.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="audio/*" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="video/*" />
            </intent-filter>

            <meta-data
                android:name="android.app.shortcuts"
                android:resource="@xml/shortcuts" />
        </activity>
        <activity-alias
            android:name=".MainActivityAlias"
            android:exported="true"
            android:targetActivity=".app.MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="de.robv.android.xposed.category.MODULE_SETTINGS" />
            </intent-filter>
        </activity-alias>

        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="@string/description" />
        <meta-data
            android:name="xposedminversion"
            android:value="53" />
        <meta-data
            android:name="xposedscope"
            android:resource="@array/recommend_package" />
    </application>
</manifest>

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/IManagerService.aidl
================================================
```
package me.gm.cleaner.plugin;

import me.gm.cleaner.plugin.model.ParceledListSlice;
import me.gm.cleaner.plugin.IMediaChangeObserver;

interface IManagerService {

    int getModuleVersion() = 0;

    ParceledListSlice<PackageInfo> getInstalledPackages(int userId, int flags) = 10;

    PackageInfo getPackageInfo(String packageName, int flags, int userId) = 11;

    String readSp(int who) = 20;

    void writeSp(int who, String what) = 21;

    void clearAllTables() = 30;

    int packageUsageTimes(int operation, in List<String> packageNames) = 31;

    void registerMediaChangeObserver(in IMediaChangeObserver observer) = 32;

    void unregisterMediaChangeObserver(in IMediaChangeObserver observer) = 33;
}

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/IMediaChangeObserver.aidl
================================================
```
// @see https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/IProcessObserver.aidl

package me.gm.cleaner.plugin;

oneway interface IMediaChangeObserver {
    void onChange();
}

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/model/ParceledListSlice.aidl
================================================
```
package me.gm.cleaner.plugin.model;

parcelable ParceledListSlice<T>;

```

================================================
FILE: ./app/src/main/java/androidx/media3/ui/PlayerControlViewLayoutManagerAccessor.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.media3.ui

import me.gm.cleaner.plugin.ktx.getObjectField

class PlayerControlViewLayoutManagerAccessor(controller: PlayerControlView) {
    private val controlViewLayoutManager =
        controller.getObjectField<PlayerControlViewLayoutManager>()

    fun show() {
        controlViewLayoutManager.show()
    }

    fun showImmediately() {
        controlViewLayoutManager.isAnimationEnabled = false
        controlViewLayoutManager.show()
        controlViewLayoutManager.isAnimationEnabled = true
    }

    fun hide() {
        controlViewLayoutManager.hide()
    }

    fun hideImmediately() {
        controlViewLayoutManager.hideImmediately()
    }

    fun removeHideCallbacks() {
        controlViewLayoutManager.removeHideCallbacks()
    }

    fun resetHideCallbacks() {
        controlViewLayoutManager.resetHideCallbacks()
    }
}

```

================================================
FILE: ./app/src/main/java/androidx/swiperefreshlayout/widget/ThemedSwipeRefreshLayout.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.swiperefreshlayout.widget

import android.annotation.SuppressLint
import android.content.Context
import android.graphics.drawable.ShapeDrawable
import android.util.AttributeSet
import androidx.core.content.ContextCompat
import androidx.core.graphics.ColorUtils
import com.google.android.material.R
import me.gm.cleaner.plugin.ktx.colorOnSurfaceVariant
import me.gm.cleaner.plugin.ktx.colorSurface

@SuppressLint("PrivateResource")
open class ThemedSwipeRefreshLayout @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null
) : SwipeRefreshLayout(context, attrs) {

    init {
        val overlayColor = ContextCompat
            .getColorStateList(context, R.color.m3_popupmenu_overlay_color)!!
            .defaultColor
        val backgroundColor = ColorUtils.compositeColors(overlayColor, context.colorSurface)
        (mCircleView.background as ShapeDrawable).paint.color = backgroundColor

        setColorSchemeColors(context.colorOnSurfaceVariant)
    }
}

```

================================================
FILE: ./app/src/main/java/com/google/android/material/carousel/CustomHeroCarouselStrategy.java
================================================
```
/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.material.carousel;

import static com.google.android.material.carousel.CarouselStrategyHelper.createKeylineState;
import static com.google.android.material.carousel.CarouselStrategyHelper.getSmallSizeMax;
import static com.google.android.material.carousel.CarouselStrategyHelper.getSmallSizeMin;

import android.view.View;

import androidx.annotation.NonNull;
import androidx.core.math.MathUtils;
import androidx.recyclerview.widget.RecyclerView.LayoutParams;

/**
 * A {@link CarouselStrategy} that knows how to size and fit one large item and one small item into
 * a container to create a layout to browse one 'hero' item at a time with a preview item.
 *
 * <p>Note that this strategy resizes Carousel items to take up the full width or height of the
 * Carousel, save room for the small item.
 *
 * <p>This class will automatically be reversed by {@link CarouselLayoutManager} if being laid out
 * right-to-left and does not need to make any account for layout direction itself.
 *
 * <p>For more information, see the <a
 * href="https://github.com/material-components/material-components-android/blob/master/docs/components/Carousel.md">component
 * developer guidance</a> and <a href="https://material.io/components/carousel/overview">design
 * guidelines</a>.
 */
public class CustomHeroCarouselStrategy extends CarouselStrategy {

    @Override
    @NonNull
    KeylineState onFirstChildMeasuredWithMargins(@NonNull Carousel carousel, @NonNull View child) {
        int availableSpace = carousel.getContainerHeight();
        if (carousel.isHorizontal()) {
            availableSpace = carousel.getContainerWidth();
        }

        LayoutParams childLayoutParams = (LayoutParams) child.getLayoutParams();
        float childMargins = childLayoutParams.topMargin + childLayoutParams.bottomMargin;
        float measuredChildSize = child.getMeasuredWidth();

        if (carousel.isHorizontal()) {
            childMargins = childLayoutParams.leftMargin + childLayoutParams.rightMargin;
            measuredChildSize = child.getMeasuredHeight();
        }

        float smallSizeMin = getSmallSizeMin(child.getContext()) / 2;
        float smallSizeMax = getSmallSizeMax(child.getContext());
        float smallChildSizeMin = smallSizeMin + childMargins;
        float smallChildSizeMax = smallSizeMax + childMargins;

        float targetLargeChildSize = measuredChildSize + childMargins;
        // Ideally we would like to create a balanced arrangement where a small item is 2/3 the size of
        // the large item. Clamp the small target size within our min-max range and as close to 2/3 of
        // the target large item size as possible.
        float targetSmallChildSize =
                MathUtils.clamp(
                        measuredChildSize * 2F / 3F + childMargins,
                        smallChildSizeMin,
                        smallChildSizeMax);

        Arrangement arrangement = new Arrangement(
                /* priority= */ 0,
                targetSmallChildSize,
                smallChildSizeMin,
                smallChildSizeMax,
                /* smallCount= */ 2,
                /* targetMediumSize= */ 0,
                /* mediumCount= */ 0,
                targetLargeChildSize,
                /* largeCount= */ 1,
                availableSpace);
        return createKeylineState(
                child.getContext(),
                childMargins,
                availableSpace,
                arrangement,
                carousel.getCarouselAlignment());
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/App.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.os.Build
import android.view.ViewConfiguration
import androidx.appcompat.app.AppCompatDelegate
import com.google.android.material.color.DynamicColors
import dagger.hilt.android.HiltAndroidApp
import me.gm.cleaner.plugin.dao.RootPreferences
import org.lsposed.hiddenapibypass.HiddenApiBypass

@HiltAndroidApp
class App : Application() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            HiddenApiBypass.addHiddenApiExemptions("")
        }
    }

    override fun onCreate() {
        super.onCreate()
        RootPreferences.init(createDeviceProtectedStorageContext())
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
        DynamicColors.applyToActivitiesIfAvailable(this)
        reduceScaledMinimumScalingSpan()
    }

    @SuppressLint("BlockedPrivateApi")
    private fun reduceScaledMinimumScalingSpan() {
        // Reduce ScaledMinimumScalingSpan due to the following reasons:
        // 1) I think it significantly reduces the user experience.
        // 2) Many Google apps do not respect this value.
        // 3) The creator of pinch-to-zoom did not specify this value.
        val field = ViewConfiguration::class.java.getDeclaredField("mMinScalingSpan")
        field.isAccessible = true
        val viewConfiguration = ViewConfiguration.get(this)
        field.set(viewConfiguration, viewConfiguration.scaledTouchSlop * 2)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/BaseActivity.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.content.res.Configuration
import android.os.Bundle
import android.view.View
import android.view.WindowManager
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.view.WindowCompat
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R

abstract class BaseActivity : AppCompatActivity() {
    lateinit var appBarLayout: AppBarLayout

    override fun setContentView(view: View) {
        super.setContentView(view)
        appBarLayout = findViewById(R.id.toolbar_container)
        val toolbar: Toolbar = findViewById(R.id.toolbar)
        setSupportActionBar(toolbar)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Turn off the decor fitting system windows, which allows us to handle insets,
        // including IME animations
        WindowCompat.setDecorFitsSystemWindows(window, false)
        // @see https://developer.android.com/guide/topics/display-cutout
        window.attributes.layoutInDisplayCutoutMode = when (resources.configuration.orientation) {
            Configuration.ORIENTATION_PORTRAIT -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
            Configuration.ORIENTATION_LANDSCAPE -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
            else -> throw IllegalArgumentException()
        }
    }

    override fun onSupportNavigateUp(): Boolean {
        if (!super.onSupportNavigateUp()) {
            finish()
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/BaseFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.content.pm.ActivityInfo
import android.os.Bundle
import android.view.View
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import androidx.fragment.app.Fragment
import androidx.navigation.NavDestination
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R
import java.lang.ref.WeakReference

abstract class BaseFragment : Fragment() {
    val supportActionBar: ActionBar?
        get() = (activity as? AppCompatActivity)?.supportActionBar
    val appBarLayout: AppBarLayout?
        get() = activity?.findViewById(R.id.toolbar_container)
    protected var liftOnScrollTargetView: WeakReference<View>? = null

    @Deprecated("Deprecated in Java")
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        appBarLayout?.setLiftOnScrollTargetView(liftOnScrollTargetView?.get())
    }

    // @see https://developer.android.com/training/system-ui/immersive#EnableFullscreen
    open fun toggleAppBar(show: Boolean) {
        val window = requireActivity().window
        val insetsController = WindowInsetsControllerCompat(window, window.decorView)
        insetsController.systemBarsBehavior =
            WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        if (show) {
            supportActionBar?.show()
            insetsController.show(WindowInsetsCompat.Type.systemBars())
        } else {
            supportActionBar?.hide()
            insetsController.hide(WindowInsetsCompat.Type.systemBars())
        }
    }

    fun restoreAppBar(currentDestination: NavDestination) {
        supportActionBar?.apply {
            title = currentDestination.label
            subtitle = null
        }
        toggleAppBar(true)
        requireActivity().requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/ConfirmationDialog.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import androidx.fragment.app.viewModels
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import java.util.function.Consumer

class ConfirmationDialog : AppCompatDialogFragment() {
    private val viewModel: ConfirmationViewModel by viewModels()
    private val pendingViewModelActions: MutableList<Runnable> = mutableListOf()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (savedInstanceState == null) {
            val iterator = pendingViewModelActions.iterator()
            while (iterator.hasNext()) {
                iterator.next().run()
                iterator.remove()
            }
        }
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getCharSequence(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok) { _, _ ->
                viewModel.onPositiveButtonClickListeners.forEach { listener ->
                    listener.accept(this)
                }
            }
            .setNegativeButton(android.R.string.cancel) { _, _ ->
                viewModel.onNegativeButtonClickListeners.forEach { listener ->
                    listener.accept(this)
                }
            }
            .create()

    private fun handleAction(action: Runnable) {
        if (!isAdded) {
            pendingViewModelActions += action
        } else {
            action.run()
        }
    }

    fun addOnPositiveButtonClickListener(onPositiveButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onPositiveButtonClickListeners.add(onPositiveButtonClickListener)
        }

    fun removeOnPositiveButtonClickListener(onPositiveButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onPositiveButtonClickListeners.remove(onPositiveButtonClickListener)
        }

    fun clearOnPositiveButtonClickListeners() = handleAction {
        viewModel.onPositiveButtonClickListeners.clear()
    }

    fun addOnNegativeButtonClickListener(onNegativeButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onNegativeButtonClickListeners.add(onNegativeButtonClickListener)
        }

    fun removeOnNegativeButtonClickListener(onNegativeButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onNegativeButtonClickListeners.remove(onNegativeButtonClickListener)
        }

    fun clearOnNegativeButtonClickListeners() = handleAction {
        viewModel.onNegativeButtonClickListeners.clear()
    }

    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"

        fun newInstance(message: CharSequence): ConfirmationDialog = ConfirmationDialog().apply {
            arguments = bundleOf(KEY_MESSAGE to message)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/ConfirmationViewModel.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import java.util.function.Consumer

class ConfirmationViewModel(application: Application) : AndroidViewModel(application) {
    val onPositiveButtonClickListeners = mutableSetOf<Consumer<ConfirmationDialog>>()
    val onNegativeButtonClickListeners = mutableSetOf<Consumer<ConfirmationDialog>>()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/InfoDialog.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import com.google.android.material.dialog.MaterialAlertDialogBuilder

class InfoDialog : AppCompatDialogFragment() {

    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getString(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok, null)
            .create()

    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"
        fun newInstance(message: String): InfoDialog =
            InfoDialog().apply { arguments = bundleOf(KEY_MESSAGE to message) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/MainActivity.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.app

import dagger.hilt.android.AndroidEntryPoint
import me.gm.cleaner.plugin.ui.drawer.DrawerActivity

@AndroidEntryPoint
class MainActivity : DrawerActivity()

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/JsonSharedPreferencesImpl.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.dao;

import android.content.SharedPreferences;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.function.Predicate;

public class JsonSharedPreferencesImpl implements SharedPreferences {
    private final Object mLock = new Object();
    private static final Object CONTENT = new Object();
    private final JSONObject mStore;
    private final WeakHashMap<OnSharedPreferenceChangeListener, Object> mListeners = new WeakHashMap<>();

    public JsonSharedPreferencesImpl() {
        mStore = new JSONObject();
    }

    public JsonSharedPreferencesImpl(JSONObject jsonObject) {
        mStore = jsonObject;
    }

    public JsonSharedPreferencesImpl(@Nullable String json) throws JSONException {
        if (TextUtils.isEmpty(json)) {
            mStore = new JSONObject();
        } else {
            mStore = new JSONObject(json);
        }
    }

    public JSONObject getDelegate() {
        synchronized (mLock) {
            try {
                return new JSONObject(mStore, getNames(mStore));
            } catch (JSONException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
        }
    }

    public static String[] getNames(JSONObject jo) {
        var length = jo.length();
        if (length == 0) {
            return null;
        }
        var iterator = jo.keys();
        var names = new String[length];
        var i = 0;
        while (iterator.hasNext()) {
            names[i] = iterator.next();
            i += 1;
        }
        return names;
    }

    @Override
    public Map<String, ?> getAll() {
        var all = new HashMap<String, Object>();
        synchronized (mLock) {
            var iterator = mStore.keys();
            while (iterator.hasNext()) {
                var key = iterator.next();
                all.put(key, mStore.opt(key));
            }
        }
        return all;
    }

    @SuppressWarnings("unchecked")
    private <T> T get(String key, @Nullable T defValue) {
        synchronized (mLock) {
            var result = mStore.opt(key);
            if (result == null) {
                return defValue;
            }
            return (T) result;
        }
    }

    @Nullable
    @Override
    public String getString(String key, @Nullable String defValue) {
        return get(key, defValue);
    }

    @Nullable
    @Override
    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {
        synchronized (mLock) {
            var result = new HashSet<String>();
            var jsonArray = mStore.optJSONArray(key);
            if (jsonArray == null) {
                return defValues;
            }
            try {
                for (int i = 0, length = jsonArray.length(); i < length; i++) {
                    result.add(jsonArray.get(i).toString());
                }
            } catch (JSONException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
            return result;
        }
    }

    @Override
    public int getInt(String key, int defValue) {
        return get(key, defValue);
    }

    @Override
    public long getLong(String key, long defValue) {
        return get(key, defValue);
    }

    @Override
    public float getFloat(String key, float defValue) {
        return get(key, defValue);
    }

    @Override
    public boolean getBoolean(String key, boolean defValue) {
        return get(key, defValue);
    }

    @Override
    public boolean contains(String key) {
        synchronized (mLock) {
            return mStore.has(key);
        }
    }

    @Override
    public JsonEditorImpl edit() {
        return new JsonEditorImpl(jsonObject -> false);
    }

    @Override
    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        synchronized (mLock) {
            mListeners.put(listener, CONTENT);
        }
    }

    @Override
    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        synchronized (mLock) {
            mListeners.remove(listener);
        }
    }

    @NonNull
    @Override
    public String toString() {
        synchronized (mLock) {
            return mStore.toString();
        }
    }

    public class JsonEditorImpl implements Editor {
        private final Object mEditorLock = new Object();
        private final Map<String, Object> mModified = new HashMap<>();
        private boolean mClear = false;
        private final Predicate<JSONObject> mAwaitCommit;

        public JsonEditorImpl(Predicate<JSONObject> awaitCommit) {
            mAwaitCommit = awaitCommit;
        }

        @Override
        public Editor putString(String key, @Nullable String value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        @Override
        public Editor putStringSet(String key, @Nullable Set<String> values) {
            synchronized (mEditorLock) {
                mModified.put(key, new JSONArray(values));
                return this;
            }
        }

        @Override
        public Editor putInt(String key, int value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        @Override
        public Editor putLong(String key, long value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        @Override
        public Editor putFloat(String key, float value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        @Override
        public Editor putBoolean(String key, boolean value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        /**
         * Maps {@code name} to {@code value}, clobbering any existing name/value
         * mapping with the same name. If the value is {@code null}, any existing
         * mapping for {@code name} is removed.
         *
         * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean,
         *              Integer, Long, Double, {@link JSONObject#NULL}, or {@code null}. May not be
         *              {@link Double#isNaN() NaNs} or {@link Double#isInfinite()
         *              infinities}.
         * @return this object.
         */
        public Editor putAny(String key, Object value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }

        @Override
        public Editor remove(String key) {
            synchronized (mEditorLock) {
                mModified.put(key, this);
                return this;
            }
        }

        @Override
        public Editor clear() {
            synchronized (mEditorLock) {
                mClear = true;
                return this;
            }
        }

        @Override
        public boolean commit() {
            var jsonToWriteToDisk = commitToMemory();
            return commitToDisk(jsonToWriteToDisk);
        }

        @NonNull
        private JSONObject commitToMemory() {
            JSONObject jsonToWriteToDisk;
            Set<OnSharedPreferenceChangeListener> listeners;
            var keysModified = new ArrayList<String>();
            synchronized (mLock) {
                listeners = mListeners.keySet();
                var hasListeners = !listeners.isEmpty();
                synchronized (mEditorLock) {
                    if (mClear) {
                        mModified.clear();
                        mStore.keys().forEachRemaining(this::remove);
                        mClear = false;
                    }

                    for (Map.Entry<String, Object> e : mModified.entrySet()) {
                        String k = e.getKey();
                        Object v = e.getValue();
                        // "this" is the magic value for a removal mutation. In addition,
                        // setting a value to "null" for a given key is specified to be
                        // equivalent to calling remove on that key.
                        if (v == this || v == null) {
                            if (!contains(k)) {
                                continue;
                            }
                            mStore.remove(k);
                        } else {
                            Object existingValue = get(k, null);
                            if (existingValue != null && existingValue.equals(v)) {
                                continue;
                            }
                            try {
                                mStore.put(k, v);
                            } catch (JSONException jsonException) {
                                jsonException.printStackTrace();
                                throw new RuntimeException(jsonException);
                            }
                        }

                        if (hasListeners) {
                            keysModified.add(k);
                        }
                    }
                    mModified.clear();
                }
                jsonToWriteToDisk = new JSONObject(getAll());
            }
            notifyListeners(listeners, keysModified);
            return jsonToWriteToDisk;
        }

        private void notifyListeners(Set<OnSharedPreferenceChangeListener> listeners, List<String> keysModified) {
            if (Looper.myLooper() == Looper.getMainLooper()) {
                for (int i = keysModified.size() - 1; i >= 0; i--) {
                    final String key = keysModified.get(i);
                    for (OnSharedPreferenceChangeListener listener : listeners) {
                        if (listener != null) {
                            listener.onSharedPreferenceChanged(JsonSharedPreferencesImpl.this, key);
                        }
                    }
                }
            } else {
                // Run this function on the main thread.
                new Handler(Looper.getMainLooper()).post(() -> notifyListeners(listeners, keysModified));
            }
        }

        public boolean commitToDisk(JSONObject jo) {
            return mAwaitCommit.test(jo);
        }

        @Override
        public void apply() {
            var jsonToWriteToDisk = commitToMemory();
            new Thread(() -> commitToDisk(jsonToWriteToDisk)).start();
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/ListConverter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.dao

import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.lang.Character.MAX_RADIX
import java.math.BigInteger

object ListConverter {
    @TypeConverter
    fun fromString(value: String?): List<String>? {
        val listType = object : TypeToken<List<String>?>() {}.type
        val list = Gson().fromJson<List<String?>?>(value, listType)
        return if (list.isEmpty() || list.any { it == null }) null
        else list as List<String>?
    }

    @TypeConverter
    fun listToString(list: List<String>?) = Gson().toJson(list)

    @TypeConverter
    fun booleanListFromString(value: String): List<Boolean> {
        val splitIndex = value.indexOf(':', 1)
        val size = value.substring(0, splitIndex).toInt()
        val values = BigInteger(value.substring(splitIndex + 1), MAX_RADIX)

        val list = MutableList(size) { i ->
            values.testBit(i)
        }
        return list
    }

    @TypeConverter
    fun booleanListToString(list: List<Boolean>): String {
        var value = BigInteger("0", MAX_RADIX)
        list.forEachIndexed { index, b ->
            if (b) {
                value = value.setBit(index)
            }
        }
        return "${list.size}:${value.toString(MAX_RADIX)}"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/MediaProviderRecord.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.dao

import android.content.pm.PackageInfo
import android.database.Cursor
import androidx.annotation.IntDef
import androidx.room.*
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY

@Entity
data class MediaProviderRecord(
    @PrimaryKey(autoGenerate = true) val id: Int,
    @ColumnInfo(name = "time_millis") val timeMillis: Long,
    @ColumnInfo(name = "package_name") val packageName: String,
    @ColumnInfo(name = "match") val match: Int,
    @ColumnInfo(name = "operation") @MediaProviderOperation val operation: Int,
    @ColumnInfo(name = "data") val data: List<String>,
    @ColumnInfo(name = "mime_type") val mimeType: List<String>,
    @ColumnInfo(name = "intercepted") val intercepted: List<Boolean>,
) {
    @Ignore
    var packageInfo: PackageInfo? = null

    @Ignore
    var label: String? = null

    companion object {
        fun convert(cursor: Cursor): List<MediaProviderRecord> {
            if (cursor.count == 0) {
                return emptyList()
            }
            val timeMillisColumn = cursor.getColumnIndexOrThrow("time_millis")
            val packageNameColumn = cursor.getColumnIndexOrThrow("package_name")
            val matchColumn = cursor.getColumnIndexOrThrow("match")
            val operationColumn = cursor.getColumnIndexOrThrow("operation")
            val dataColumn = cursor.getColumnIndexOrThrow("data")
            val mimeTypeColumn = cursor.getColumnIndexOrThrow("mime_type")
            val interceptedColumn = cursor.getColumnIndexOrThrow("intercepted")

            val records = mutableListOf<MediaProviderRecord>()
            while (cursor.moveToNext()) {
                records += MediaProviderRecord(
                    0,
                    cursor.getLong(timeMillisColumn),
                    cursor.getString(packageNameColumn),
                    cursor.getInt(matchColumn),
                    cursor.getInt(operationColumn),
                    ListConverter.fromString(cursor.getString(dataColumn)) ?: continue,
                    ListConverter.fromString(cursor.getString(mimeTypeColumn)) ?: continue,
                    ListConverter.booleanListFromString(cursor.getString(interceptedColumn)),
                )
            }
            return records
        }
    }
}

@Dao
interface MediaProviderRecordDao {
    @Query("SELECT * FROM MediaProviderRecord WHERE time_millis BETWEEN (:start) AND (:end) AND operation IN (:operations) ORDER BY time_millis DESC")
    fun loadForTimeMillis(
        start: Long, end: Long, @MediaProviderOperation vararg operations: Int
    ): Cursor

    @Query("SELECT count(*) FROM MediaProviderRecord WHERE package_name IN (:packageNames) AND operation IN (:operation)")
    fun packageUsageTimes(@MediaProviderOperation operation: Int, vararg packageNames: String): Int

    @Insert
    fun insert(records: MediaProviderRecord)

    @Delete
    fun delete(record: MediaProviderRecord)
}

@IntDef(value = [OP_QUERY, OP_INSERT, OP_DELETE])
@kotlin.annotation.Retention(AnnotationRetention.SOURCE)
annotation class MediaProviderOperation {
    companion object {
        const val OP_QUERY = 0
        const val OP_INSERT = 1
        const val OP_DELETE = 2
    }
}

@Database(entities = [MediaProviderRecord::class], version = 2, exportSchema = false)
@TypeConverters(ListConverter::class)
abstract class MediaProviderRecordDatabase : RoomDatabase() {
    abstract fun mediaProviderRecordDao(): MediaProviderRecordDao
}

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(_db: SupportSQLiteDatabase) {
        _db.execSQL("DELETE FROM `MediaProviderQueryRecord`")
        _db.execSQL("DELETE FROM `MediaProviderInsertRecord`")
        _db.execSQL("DELETE FROM `MediaProviderDeleteRecord`")
        _db.execSQL("CREATE TABLE IF NOT EXISTS `MediaProviderRecord` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `time_millis` INTEGER NOT NULL, `package_name` TEXT NOT NULL, `match` INTEGER NOT NULL, `operation` INTEGER NOT NULL, `data` TEXT NOT NULL, `mime_type` TEXT NOT NULL, `intercepted` TEXT NOT NULL)")
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/RootPreferences.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.dao

import android.content.Context
import android.content.SharedPreferences
import android.content.res.Resources
import androidx.core.content.edit
import androidx.preference.PreferenceManager
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.util.FlowableSharedPreferences

object RootPreferences {
    const val SORT_BY_APP_NAME = 0
    const val SORT_BY_UPDATE_TIME = 1
    const val SORT_BY_PATH = 0
    const val SORT_BY_DATE_TAKEN = 1
    const val SORT_BY_SIZE = 2
    private lateinit var resources: Resources
    private lateinit var defaultSp: SharedPreferences

    fun init(context: Context) {
        resources = context.resources
        defaultSp = PreferenceManager.getDefaultSharedPreferences(context)
    }

    var startDestination: Int
        get() = defaultSp.getInt(
            resources.getString(R.string.start_destination_key), R.id.about_fragment
        )
        set(value) = defaultSp.edit {
            putInt(resources.getString(R.string.start_destination_key), value)
        }

    // APP LIST
    val sortByFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.sort_key),
            SORT_BY_APP_NAME
        )
    }
    val ruleCountFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_rule_count_key),
            true
        )
    }
    val isHideSystemAppFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_system_app_key),
            true
        )
    }

    // USAGE RECORD
    val isHideQueryFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_query_key),
            false
        )
    }
    val isHideInsertFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_insert_key),
            false
        )
    }
    val isHideDeleteFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_delete_key),
            false
        )
    }

    // MEDIA STORE
    val sortMediaByFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.sort_media_key),
            SORT_BY_PATH
        )
    }
    val spanCountFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.span_count_key),
            3
        )
    }
    val playbackSpeedFlowable: FlowableSharedPreferences<Float> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.playback_speed_key),
            1F
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/SharedPreferencesWrapper.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.dao;

import android.content.SharedPreferences;

import androidx.annotation.Nullable;

import java.util.Map;
import java.util.Set;

public class SharedPreferencesWrapper implements SharedPreferences {
    protected SharedPreferences delegate;

    @Override
    public Map<String, ?> getAll() {
        return delegate.getAll();
    }

    @Nullable
    @Override
    public String getString(String key, @Nullable String defValue) {
        return delegate.getString(key, defValue);
    }

    @Nullable
    @Override
    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {
        return delegate.getStringSet(key, defValues);
    }

    @Override
    public int getInt(String key, int defValue) {
        return delegate.getInt(key, defValue);
    }

    @Override
    public long getLong(String key, long defValue) {
        return delegate.getLong(key, defValue);
    }

    @Override
    public float getFloat(String key, float defValue) {
        return delegate.getFloat(key, defValue);
    }

    @Override
    public boolean getBoolean(String key, boolean defValue) {
        return delegate.getBoolean(key, defValue);
    }

    @Override
    public boolean contains(String key) {
        return delegate.contains(key);
    }

    @Override
    public Editor edit() {
        return delegate.edit();
    }

    @Override
    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        delegate.registerOnSharedPreferenceChangeListener(listener);
    }

    @Override
    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        delegate.unregisterOnSharedPreferenceChangeListener(listener);
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/github/ReadmeRepository.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.data.github

import javax.inject.Inject

class ReadmeRepository @Inject constructor(private val service: ReadmeService) {

    fun getRawReadme(languageTag: String): Result<String> = runCatching {
        when (languageTag) {
            "zh-CN", "zh-TW" -> service.zh.execute().body() ?: throw NullPointerException()
            /* en-US */ else -> service.en.execute().body() ?: throw NullPointerException()
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/github/ReadmeService.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.data.github

import android.content.Context
import me.gm.cleaner.plugin.ktx.hasWifiTransport
import okhttp3.Cache
import okhttp3.OkHttpClient
import retrofit2.Call
import retrofit2.Retrofit
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.GET
import java.io.File

interface ReadmeService {
    @get:GET("README.md")
    val en: Call<String>

    @get:GET("README_zh-CN.md")
    val zh: Call<String>

    companion object {
        const val BASE_URL =
            "https://raw.githubusercontent.com/MaterialCleaner/Media-Provider-Manager/main/"

        fun create(context: Context): ReadmeService {
            val client = OkHttpClient.Builder()
                .addInterceptor { chain ->
                    val originalResponse = chain.proceed(chain.request())
                    if (context.hasWifiTransport) {
                        val maxAge = 60 * 60 * 24 * 7 // read from cache for 1 week
                        originalResponse.newBuilder()
                            .header("Cache-Control", "public, max-age=$maxAge")
                            .build()
                    } else {
                        val maxStale = 60 * 60 * 24 * 28 // tolerate 4-weeks stale
                        originalResponse.newBuilder()
                            .header("Cache-Control", "public, only-if-cached, max-stale=$maxStale")
                            .build()
                    }
                }
                .cache(Cache(File(context.cacheDir, "okhttp"), 1024L * 1024L))
                .build()

            return Retrofit.Builder()
                .baseUrl(BASE_URL)
                .client(client)
                .addConverterFactory(ScalarsConverterFactory.create())
                .build()
                .create(ReadmeService::class.java)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashPhoto.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.data.unsplash

import com.google.gson.annotations.SerializedName

/**
 * Data class that represents a photo from Unsplash.
 */
data class UnsplashPhoto(
    @field:SerializedName("format") val format: String,
    @field:SerializedName("width") val width: Int,
    @field:SerializedName("height") val height: Int,
    @field:SerializedName("filename") val filename: String,
    @field:SerializedName("id") val id: Int,
    @field:SerializedName("author") val author: String,
    @field:SerializedName("author_url") val authorUrl: String,
    @field:SerializedName("post_url") val postUrl: String,
) {
    fun getPhotoUrl(requestWidth: Int) = PHOTO_URL_BASE.format(requestWidth, id)

    companion object {
        private const val PHOTO_URL_BASE = "https://unsplash.it/%d?image=%d"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashRepository.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.data.unsplash

import javax.inject.Inject

class UnsplashRepository @Inject constructor(private val service: UnsplashService) {

    fun fetchUnsplashPhotoList(): Result<List<UnsplashPhoto>> = runCatching {
        service.feed.execute().body() ?: throw NullPointerException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashService.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.data.unsplash

import retrofit2.Call
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET

/**
 * Modeling the unsplash.it API.
 */
interface UnsplashService {
    @get:GET("/list")
    val feed: Call<List<UnsplashPhoto>>

    companion object {
        const val BASE_URL = "https://unsplash.it"

        fun create(): UnsplashService = Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(UnsplashService::class.java)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/AppGlideModule.java
================================================
```
/*
 * Copyright 2020 Google LLC
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.di;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.graphics.Bitmap;
import android.net.Uri;

import androidx.annotation.NonNull;

import com.bumptech.glide.Glide;
import com.bumptech.glide.Registry;
import com.bumptech.glide.annotation.GlideModule;

import java.nio.ByteBuffer;

import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.MediaModelLoader;
import me.zhanghai.android.appiconloader.glide.AppIconModelLoader;

@GlideModule
public class AppGlideModule extends com.bumptech.glide.module.AppGlideModule {
    @Override
    public boolean isManifestParsingEnabled() {
        return false;
    }

    @Override
    public void registerComponents(@NonNull Context context, @NonNull Glide glide,
                                   @NonNull Registry registry) {
        int iconSize = context.getResources().getDimensionPixelSize(R.dimen.badge_size);
        registry.prepend(PackageInfo.class, Bitmap.class, new AppIconModelLoader.Factory(iconSize,
                false, context))
                .prepend(Uri.class, ByteBuffer.class, new MediaModelLoader.Factory(context));
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/BinderModule.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.di

import android.content.Context
import android.provider.MediaStore
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@InstallIn(SingletonComponent::class)
@Module
class BinderModule {

    @Singleton
    @Provides
    fun provideBinder(@ApplicationContext context: Context) = context.contentResolver.query(
        MediaStore.Images.Media.INTERNAL_CONTENT_URI, null, null, null, null
    )?.use {
        it.extras.getBinder("me.gm.cleaner.plugin.cursor.extra.BINDER")
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/NetworkModule.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.di

import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import me.gm.cleaner.plugin.data.github.ReadmeService
import me.gm.cleaner.plugin.data.unsplash.UnsplashService
import javax.inject.Singleton

@InstallIn(SingletonComponent::class)
@Module
class NetworkModule {

    @Singleton
    @Provides
    fun provideReadmeService(@ApplicationContext context: Context) = ReadmeService.create(context)

    @Singleton
    @Provides
    fun provideUnsplashService() = UnsplashService.create()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Configuration.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.content.res.Configuration
import android.os.Build
import android.view.View

val Configuration.isNightModeActiveCompat
    get() = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        isNightModeActive
    } else {
        uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
    }

val Configuration.isRtl
    get() = layoutDirection == View.LAYOUT_DIRECTION_RTL

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Context.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.res.ColorStateList
import android.content.res.TypedArray
import android.graphics.drawable.Drawable
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.style.ForegroundColorSpan
import android.text.style.TextAppearanceSpan
import android.widget.Toast
import androidx.annotation.AnyRes
import androidx.annotation.AttrRes
import androidx.annotation.ColorInt

fun Context.buildSpannableString(
    text: CharSequence,
    style: Int = com.google.android.material.R.attr.textAppearanceBody2,
    color: Int? = colorAccent
): SpannableStringBuilder = SpannableStringBuilder(text).apply {
    setSpan(
        TextAppearanceSpan(this@buildSpannableString, getResourceIdByAttr(style)), 0, length,
        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
    )
    if (color != null) {
        setSpan(ForegroundColorSpan(color), 0, length, Spannable.SPAN_INCLUSIVE_INCLUSIVE)
    }
}

fun Context.startActivitySafe(intent: Intent) {
    try {
        startActivity(intent)
    } catch (e: ActivityNotFoundException) {
        Toast.makeText(this, e.message, Toast.LENGTH_SHORT).show()
    }
}

val Context.hasWifiTransport: Boolean
    get() {
        val connManager =
            getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val capabilities = connManager.getNetworkCapabilities(connManager.activeNetwork)
        return capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true
    }

inline fun <T : TypedArray, R> T.use(block: (T) -> R): R = try {
    block(this)
} finally {
    recycle()
}

fun Context.getDimenByAttr(@AttrRes attr: Int): Float =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getDimension(0, 0F)
    }

@ColorInt
fun Context.getColorByAttr(@AttrRes attr: Int): Int? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getColorStateList(0)?.defaultColor
    }

fun Context.getColorStateListByAttr(@AttrRes attr: Int): ColorStateList? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getColorStateList(0)
    }

fun Context.getDrawableByAttr(@AttrRes attr: Int): Drawable? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getDrawable(0)
    }

@AnyRes
fun Context.getResourceIdByAttr(@AttrRes attr: Int, index: Int = 0): Int =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getResourceId(index, 0)
    }

fun Context.dpToPx(dps: Int): Int {
    val density = resources.displayMetrics.density
    return (dps * density + 0.5F).toInt()
}

fun Context.pxToDp(px: Int): Int {
    val density = resources.displayMetrics.density
    return (px / density).toInt()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/ContextConstants.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.content.Context
import android.content.res.ColorStateList
import androidx.annotation.ColorInt

val Context.colorPrimary: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorPrimary)!!

val Context.colorPrimaryContainer: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorPrimaryContainer)!!

val Context.colorOnPrimaryContainer: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnPrimaryContainer)!!

val Context.colorAccent: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorAccent)!!

val Context.colorBackground: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorBackground)!!

val Context.colorBackgroundFloating: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorBackgroundFloating)!!

val Context.colorSurface: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorSurface)!!

val Context.colorOnSurface: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnSurface)!!

val Context.colorOnSurfaceVariant: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnSurfaceVariant)!!

val Context.colorError: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorError)!!

val Context.colorControlNormal: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorControlNormal)!!

val Context.colorControlHighlight: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorControlHighlight)!!

val Context.textColorPrimary: ColorStateList
    get() = getColorStateListByAttr(android.R.attr.textColorPrimary)!!

val Context.textColorPrimaryInverse: ColorStateList
    get() = getColorStateListByAttr(android.R.attr.textColorPrimaryInverse)!!

val Context.navAnimTime: Long
    get() = resources.getInteger(androidx.navigation.ui.R.integer.config_navAnimTime).toLong()

val Context.shortAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_shortAnimTime).toLong()

val Context.mediumAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_mediumAnimTime).toLong()

val Context.longAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_longAnimTime).toLong()

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Flow.kt
================================================
```
/*
 * Copyright 2024 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlin.reflect.KProperty

operator fun <T> StateFlow<T>.getValue(thisObj: Any?, property: KProperty<*>): T = value

operator fun <T> MutableStateFlow<T>.setValue(
    thisObj: Any?, property: KProperty<*>, value: T
) {
    this.value = value
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/MaterialDialog.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.ColorStateList
import android.graphics.Rect
import android.os.Build
import android.os.Build.VERSION_CODES
import android.util.TypedValue
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes
import androidx.appcompat.view.ContextThemeWrapper
import com.google.android.material.R
import com.google.android.material.color.MaterialColors
import com.google.android.material.dialog.MaterialDialogs
import com.google.android.material.resources.MaterialAttributes
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.theme.overlay.MaterialThemeOverlay

@AttrRes
val DEF_STYLE_ATTR = R.attr.alertDialogStyle

@StyleRes
val DEF_STYLE_RES = R.style.MaterialAlertDialog_MaterialComponents

@AttrRes
val MATERIAL_ALERT_DIALOG_THEME_OVERLAY = R.attr.materialAlertDialogTheme

@SuppressLint("RestrictedApi")
private fun getMaterialAlertDialogThemeOverlay(context: Context): Int {
    val materialAlertDialogThemeOverlay =
        MaterialAttributes.resolve(context, MATERIAL_ALERT_DIALOG_THEME_OVERLAY) ?: return 0
    return materialAlertDialogThemeOverlay.data
}

fun Context.createMaterialAlertDialogThemedContext(): Context {
    val themeOverlayId = getMaterialAlertDialogThemeOverlay(this)
    val themedContext = MaterialThemeOverlay.wrap(this, null, DEF_STYLE_ATTR, DEF_STYLE_RES)
    if (themeOverlayId == 0) {
        return themedContext
    }
    return ContextThemeWrapper(themedContext, themeOverlayId)
}

@SuppressLint("RestrictedApi")
fun Context.materialDialogBackgroundInsets(): Rect = MaterialDialogs.getDialogBackgroundInsets(
    this, DEF_STYLE_ATTR, DEF_STYLE_RES
)

fun Context.materialDialogBackgroundDrawable(): MaterialShapeDrawable {
    val surfaceColor = MaterialColors.getColor(this, R.attr.colorSurface, javaClass.canonicalName)
    val materialShapeDrawable = MaterialShapeDrawable(this, null, DEF_STYLE_ATTR, DEF_STYLE_RES)
    materialShapeDrawable.initializeElevationOverlay(this)
    materialShapeDrawable.fillColor = ColorStateList.valueOf(surfaceColor)

    // dialogCornerRadius first appeared in Android Pie
    if (Build.VERSION.SDK_INT >= VERSION_CODES.P) {
        val dialogCornerRadiusValue = TypedValue()
        theme.resolveAttribute(android.R.attr.dialogCornerRadius, dialogCornerRadiusValue, true)
        val dialogCornerRadius = dialogCornerRadiusValue.getDimension(resources.displayMetrics)
        if (dialogCornerRadiusValue.type === TypedValue.TYPE_DIMENSION && dialogCornerRadius >= 0) {
            materialShapeDrawable.setCornerSize(dialogCornerRadius)
        }
    }
    return materialShapeDrawable
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/NavController.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.os.Bundle
import androidx.navigation.NavController
import androidx.navigation.NavController.OnDestinationChangedListener
import androidx.navigation.NavDestination

private val destinationToListener: MutableMap<NavDestination, OneShotDestinationChangedListener> =
    mutableMapOf()

fun NavController.addOnExitListener(action: (controller: NavController, destination: NavDestination, arguments: Bundle?) -> Unit) {
    val newListener = OneShotDestinationChangedListener(this, action)
    val oldListener = destinationToListener.put(currentDestination!!, newListener)
    if (oldListener != null) {
        removeOnDestinationChangedListener(oldListener)
    }
    addOnDestinationChangedListener(newListener)
}

class OneShotDestinationChangedListener(
    navController: NavController,
    private val action: (controller: NavController, destination: NavDestination, arguments: Bundle?) -> Unit
) : OnDestinationChangedListener {
    private val callerDestination = navController.currentDestination

    override fun onDestinationChanged(
        controller: NavController, destination: NavDestination, arguments: Bundle?
    ) {
        if (destination != callerDestination) {
            destinationToListener.remove(callerDestination)
            controller.removeOnDestinationChangedListener(this)
            action(controller, destination, arguments)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/RecyclerView.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.view.View
import androidx.core.view.doOnPreDraw
import androidx.core.view.forEach
import androidx.recyclerview.widget.DefaultItemAnimator
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.zhanghai.android.fastscroll.FastScroller

private val rect = Rect()

fun <T, VH : RecyclerView.ViewHolder> ListAdapter<T, VH>.submitListKeepPosition(
    list: List<T>, recyclerView: RecyclerView, commitCallback: Runnable? = null
) {
    val layoutManager = recyclerView.layoutManager as LinearLayoutManager
    val position = layoutManager.findFirstVisibleItemPosition()
    if (position == RecyclerView.NO_POSITION) {
        submitList(list, commitCallback)
    } else {
        recyclerView.getDecoratedBoundsWithMargins(
            layoutManager.findViewByPosition(position)!!, rect
        )
        submitList(list) {
            layoutManager.scrollToPositionWithOffset(position, rect.top - recyclerView.paddingTop)
            commitCallback?.run()
        }
    }
}

class DividerDecoration(private val list: RecyclerView) : RecyclerView.ItemDecoration() {
    private lateinit var divider: Drawable
    private var dividerHeight = 0
    private var allowDividerAfterLastItem = true

    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        if (!::divider.isInitialized) {
            return
        }
        val width = parent.width
        parent.forEach { view ->
            if (shouldDrawDividerBelow(view, parent)) {
                val top = view.y.toInt() + view.height
                divider.setBounds(0, top, width, top + dividerHeight)
                divider.setTint(parent.context.colorControlHighlight)
                divider.draw(c)
            }
        }
    }

    override fun getItemOffsets(
        outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State
    ) {
        if (shouldDrawDividerBelow(view, parent)) {
            outRect.bottom = dividerHeight
        }
    }

    private fun shouldDrawDividerBelow(view: View, parent: RecyclerView): Boolean {
        val holder = parent.getChildViewHolder(view)
        val dividerAllowedBelow = holder is DividerViewHolder && holder.isDividerAllowedBelow
        if (dividerAllowedBelow) {
            return true
        }
        var nextAllowed = allowDividerAfterLastItem
        val index = parent.indexOfChild(view)
        if (index < parent.childCount - 1) {
            val nextView = parent.getChildAt(index + 1)
            val nextHolder = parent.getChildViewHolder(nextView)
            nextAllowed = nextHolder is DividerViewHolder && nextHolder.isDividerAllowedAbove
        }
        return nextAllowed
    }

    fun setDivider(divider: Drawable) {
        dividerHeight = divider.intrinsicHeight
        this.divider = divider
        list.invalidateItemDecorations()
    }

    fun setDividerHeight(dividerHeight: Int) {
        this.dividerHeight = dividerHeight
        list.invalidateItemDecorations()
    }

    fun setAllowDividerAfterLastItem(allowDividerAfterLastItem: Boolean) {
        this.allowDividerAfterLastItem = allowDividerAfterLastItem
    }
}

abstract class DividerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {

    /**
     * Dividers are only drawn between items if both items allow it, or above the first and below
     * the last item if that item allows it.
     *
     * @return `true` if dividers are allowed above this item
     */
    var isDividerAllowedAbove = false

    /**
     * Dividers are only drawn between items if both items allow it, or above the first and below
     * the last item if that item allows it.
     *
     * @return `true` if dividers are allowed below this item
     */
    var isDividerAllowedBelow = false
}

fun RecyclerView.overScrollIfContentScrollsPersistent(supportsChangeAnimations: Boolean = true) {
    doOnPreDraw {
        overScrollIfContentScrolls()
    }
    addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ -> overScrollIfContentScrolls() }
    itemAnimator = object : DefaultItemAnimator() {
        init {
            this.supportsChangeAnimations = supportsChangeAnimations
        }

        override fun onAnimationFinished(viewHolder: RecyclerView.ViewHolder) {
            super.onAnimationFinished(viewHolder)
            overScrollIfContentScrolls()
        }
    }
}

fun RecyclerView.overScrollIfContentScrolls() {
    overScrollMode = if (isContentScrolls(this)) {
        View.OVER_SCROLL_IF_CONTENT_SCROLLS
    } else {
        View.OVER_SCROLL_NEVER
    }
}

private fun isContentScrolls(list: RecyclerView): Boolean {
    val layoutManager = list.layoutManager
    if (layoutManager == null || list.adapter == null || list.adapter?.itemCount == 0) {
        return false
    }
    if (!list.isItemCompletelyVisible(0)) {
        return true
    }
    return !list.isItemCompletelyVisible(layoutManager.itemCount - 1)
}

fun RecyclerView.isItemCompletelyVisible(position: Int): Boolean {
    val vh = findViewHolderForAdapterPosition(position)
    vh ?: return false
    val layoutManager = layoutManager!!
    return layoutManager.isViewPartiallyVisible(vh.itemView, true, true)
}

fun RecyclerView.isItemCompletelyInvisible(position: Int): Boolean {
    val vh = findViewHolderForAdapterPosition(position)
    vh ?: return true
    val layoutManager = layoutManager!!
    return !layoutManager.isViewPartiallyVisible(vh.itemView, true, true) &&
            !layoutManager.isViewPartiallyVisible(vh.itemView, false, false)
}

fun View.fitsSystemWindowInsets(fastScroller: FastScroller? = null) {
    val paddingLeft = paddingLeft
    val paddingTop = paddingTop
    val paddingRight = paddingRight
    val paddingBottom = paddingBottom
    setOnApplyWindowInsetsListener { view, insets ->
        view.setPadding(
            paddingLeft, paddingTop + insets.systemWindowInsetTop,
            paddingRight, paddingBottom + insets.systemWindowInsetBottom
        )
        fastScroller?.setPadding(
            0, paddingTop + insets.systemWindowInsetTop,
            0, paddingBottom + insets.systemWindowInsetBottom
        )
        insets
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Reflection.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ktx

inline fun <reified T> Any.getObjectField(sourceCls: Class<*> = javaClass) =
    sourceCls.declaredFields
        .first { it.type == T::class.java }
        .apply { isAccessible = true }[this] as T

inline fun <reified T> Any.setObjectField(value: T, sourceCls: Class<*> = javaClass) {
    sourceCls.declaredFields
        .first { it.type == T::class.java }
        .apply { isAccessible = true }[this] = value
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/BaseParceledListSlice.java
================================================
```
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.model;

import android.os.Binder;
import android.os.IBinder;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.RemoteException;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Transfer a large list of Parcelable objects across an IPC.  Splits into
 * multiple transactions if needed.
 * <p>
 * Caveat: for efficiency and security, all elements must be the same concrete type.
 * In order to avoid writing the class name of each object, we must ensure that
 * each object is the same type, or else unparceling then reparceling the data may yield
 * a different result if the class name encoded in the Parcelable is a Base type.
 * See b/17671747.
 */
abstract class BaseParceledListSlice<T> implements Parcelable {
    private static String TAG = "ParceledListSlice";
    private static final int MAX_IPC_SIZE = 64 * 1024;
    private final List<T> mList;
    private int mInlineCountLimit = Integer.MAX_VALUE;

    public BaseParceledListSlice(List<T> list) {
        if (list == null) {
            mList = Collections.emptyList();
        } else {
            mList = list;
        }
    }

    @SuppressWarnings("unchecked")
    BaseParceledListSlice(Parcel p, ClassLoader loader) {
        final int N = p.readInt();
        mList = new ArrayList<T>(N);
        if (N <= 0) {
            return;
        }
        Creator<?> creator = readParcelableCreator(p, loader);
        Class<?> listElementClass = null;
        int i = 0;
        while (i < N) {
            if (p.readInt() == 0) {
                break;
            }
            final T parcelable = readCreator(creator, p, loader);
            if (listElementClass == null) {
                listElementClass = parcelable.getClass();
            } else {
                verifySameType(listElementClass, parcelable.getClass());
            }
            mList.add(parcelable);
            i++;
        }
        if (i >= N) {
            return;
        }
        final IBinder retriever = p.readStrongBinder();
        while (i < N) {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            data.writeInt(i);
            try {
                retriever.transact(IBinder.FIRST_CALL_TRANSACTION, data, reply, 0);
            } catch (RemoteException e) {
                Log.w(TAG, "Failure retrieving array; only received " + i + " of " + N, e);
                return;
            }
            while (i < N && reply.readInt() != 0) {
                final T parcelable = readCreator(creator, reply, loader);
                verifySameType(listElementClass, parcelable.getClass());
                mList.add(parcelable);
                i++;
            }
            reply.recycle();
            data.recycle();
        }
    }

    private T readCreator(Creator<?> creator, Parcel p, ClassLoader loader) {
        if (creator instanceof ClassLoaderCreator<?>) {
            ClassLoaderCreator<?> classLoaderCreator =
                    (ClassLoaderCreator<?>) creator;
            return (T) classLoaderCreator.createFromParcel(p, loader);
        }
        return (T) creator.createFromParcel(p);
    }

    private static void verifySameType(final Class<?> expected, final Class<?> actual) {
        if (!actual.equals(expected)) {
            throw new IllegalArgumentException("Can't unparcel type "
                    + (actual == null ? null : actual.getName()) + " in list of type "
                    + (expected == null ? null : expected.getName()));
        }
    }

    public List<T> getList() {
        return mList;
    }

    /**
     * Set a limit on the maximum number of entries in the array that will be included
     * inline in the initial parcelling of this object.
     */
    public void setInlineCountLimit(int maxCount) {
        mInlineCountLimit = maxCount;
    }

    /**
     * Write this to another Parcel. Note that this discards the internal Parcel
     * and should not be used anymore. This is so we can pass this to a Binder
     * where we won't have a chance to call recycle on this.
     */
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        final int N = mList.size();
        final int callFlags = flags;
        dest.writeInt(N);
        if (N > 0) {
            final Class<?> listElementClass = mList.get(0).getClass();
            writeParcelableCreator(mList.get(0), dest);
            int i = 0;
            while (i < N && i < mInlineCountLimit && dest.dataSize() < MAX_IPC_SIZE) {
                dest.writeInt(1);
                final T parcelable = mList.get(i);
                verifySameType(listElementClass, parcelable.getClass());
                writeElement(parcelable, dest, callFlags);
                i++;
            }
            if (i < N) {
                dest.writeInt(0);
                Binder retriever = new Binder() {
                    @Override
                    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
                            throws RemoteException {
                        if (code != FIRST_CALL_TRANSACTION) {
                            return super.onTransact(code, data, reply, flags);
                        }
                        int i = data.readInt();
                        while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                            reply.writeInt(1);
                            final T parcelable = mList.get(i);
                            verifySameType(listElementClass, parcelable.getClass());
                            writeElement(parcelable, reply, callFlags);
                            i++;
                        }
                        if (i < N) {
                            reply.writeInt(0);
                        }
                        return true;
                    }
                };
                dest.writeStrongBinder(retriever);
            }
        }
    }

    protected abstract void writeElement(T parcelable, Parcel reply, int callFlags);

    protected abstract void writeParcelableCreator(T parcelable, Parcel dest);

    protected abstract Creator<?> readParcelableCreator(Parcel from, ClassLoader loader);
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/ParceledListSlice.java
================================================
```
/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.model;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.os.BadParcelableException;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

/**
 * Transfer a large list of Parcelable objects across an IPC.  Splits into
 * multiple transactions if needed.
 *
 * @see BaseParceledListSlice
 */
public class ParceledListSlice<T extends Parcelable> extends BaseParceledListSlice<T> {

    private static final String TAG = "ParceledListSlice";

    // Cache of previously looked up CREATOR.createFromParcel() methods for
    // particular classes.  Keys are the names of the classes, values are
    // Method objects.
    private static final HashMap<ClassLoader, HashMap<String, Creator<?>>>
            CREATORS = new HashMap<>();

    static {
        putCreator(PackageInfo.class.getName(), PackageInfo.CREATOR);
        putCreator(ApplicationInfo.class.getName(), ApplicationInfo.CREATOR);
    }

    public static void putCreator(String name, Creator<?> creator) {
        HashMap<String, Creator<?>> map = CREATORS.get(null);
        if (map == null) {
            map = new HashMap<>();
            CREATORS.put(null, map);
        }
        map.put(name, creator);
    }

    public ParceledListSlice(List<T> list) {
        super(list);
    }

    private ParceledListSlice(Parcel in, ClassLoader loader) {
        super(in, loader);
    }

    public static <T extends Parcelable> ParceledListSlice<T> emptyList() {
        return new ParceledListSlice<T>(Collections.<T>emptyList());
    }

    @Override
    public int describeContents() {
        int contents = 0;
        final List<T> list = getList();
        for (int i = 0; i < list.size(); i++) {
            contents |= list.get(i).describeContents();
        }
        return contents;
    }

    @Override
    protected void writeElement(T parcelable, Parcel dest, int callFlags) {
        parcelable.writeToParcel(dest, callFlags);
    }

    @Override
    protected void writeParcelableCreator(T parcelable, Parcel dest) {
        String name = parcelable.getClass().getName();
        dest.writeString(name);
    }

    @Override
    protected Creator<?> readParcelableCreator(Parcel from, ClassLoader loader) {
        String name = from.readString();
        if (name == null) {
            return null;
        }
        Creator<?> creator;
        synchronized (CREATORS) {
            HashMap<String, Creator<?>> map = CREATORS.get(loader);
            if (map == null) {
                map = new HashMap<>();
                CREATORS.put(loader, map);
            }
            creator = map.get(name);
            if (creator == null) {
                try {
                    // If loader == null, explicitly emulate Class.forName(String) "caller
                    // classloader" behavior.
                    ClassLoader parcelableClassLoader =
                            (loader == null ? getClass().getClassLoader() : loader);
                    // Avoid initializing the Parcelable class until we know it implements
                    // Parcelable and has the necessary CREATOR field. http://b/1171613.
                    Class<?> parcelableClass = Class.forName(name, false /* initialize */,
                            parcelableClassLoader);
                    if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
                        throw new BadParcelableException("Parcelable protocol requires subclassing "
                                + "from Parcelable on class " + name);
                    }
                    Field f = parcelableClass.getField("CREATOR");
                    if ((f.getModifiers() & Modifier.STATIC) == 0) {
                        throw new BadParcelableException("Parcelable protocol requires "
                                + "the CREATOR object to be static on class " + name);
                    }
                    Class<?> creatorType = f.getType();
                    if (!Creator.class.isAssignableFrom(creatorType)) {
                        // Fail before calling Field.get(), not after, to avoid initializing
                        // parcelableClass unnecessarily.
                        throw new BadParcelableException("Parcelable protocol requires a "
                                + "Parcelable.Creator object called "
                                + "CREATOR on class " + name);
                    }
                    creator = (Creator<?>) f.get(null);
                } catch (IllegalAccessException e) {
                    Log.e(TAG, "Illegal access when unmarshalling: " + name, e);
                    throw new BadParcelableException(
                            "IllegalAccessException when unmarshalling: " + name);
                } catch (ClassNotFoundException e) {
                    Log.e(TAG, "Class not found when unmarshalling: " + name, e);
                    throw new BadParcelableException(
                            "ClassNotFoundException when unmarshalling: " + name);
                } catch (NoSuchFieldException e) {
                    throw new BadParcelableException("Parcelable protocol requires a "
                            + "Parcelable.Creator object called "
                            + "CREATOR on class " + name);
                }
                if (creator == null) {
                    throw new BadParcelableException("Parcelable protocol requires a "
                            + "non-null Parcelable.Creator object called "
                            + "CREATOR on class " + name);
                }

                map.put(name, creator);
            }
        }

        return creator;
    }

    public static final ClassLoaderCreator<ParceledListSlice> CREATOR =
            new ClassLoaderCreator<ParceledListSlice>() {
                public ParceledListSlice createFromParcel(Parcel in) {
                    return new ParceledListSlice(in, null);
                }

                @Override
                public ParceledListSlice createFromParcel(Parcel in, ClassLoader loader) {
                    return new ParceledListSlice(in, loader);
                }

                @Override
                public ParceledListSlice[] newArray(int size) {
                    return new ParceledListSlice[size];
                }
            };
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/Template.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.model

import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import me.gm.cleaner.plugin.xposed.hooker.InsertHooker
import me.gm.cleaner.plugin.xposed.hooker.QueryHooker
import me.gm.cleaner.plugin.xposed.util.FileUtils
import me.gm.cleaner.plugin.xposed.util.MimeUtils

data class Template(
    @field:SerializedName("template_name") val templateName: String,
    @field:SerializedName("hook_operation") val hookOperation: List<String>,
    @field:SerializedName("apply_to_app") val applyToApp: List<String>?,
    @field:SerializedName("permitted_media_types") val permittedMediaTypes: List<Int>?,
    @field:SerializedName("filter_path") val filterPath: List<String>?,
)

class Templates(json: String?) {
    private val _values = mutableListOf<Template>()
    val values: List<Template>
        get() = _values
    private lateinit var matchingTemplates: List<Template>

    init {
        if (!json.isNullOrEmpty()) {
            _values.addAll(
                Gson().fromJson(json, Array<Template>::class.java)
            )
        }
    }

    fun filterTemplate(cls: Class<*>, packageName: String): Templates {
        matchingTemplates = _values.filter { template ->
            when (cls) {
                QueryHooker::class.java -> template.hookOperation.contains("query")
                InsertHooker::class.java -> template.hookOperation.contains("insert")
                else -> throw IllegalArgumentException()
            } && template.applyToApp?.contains(packageName) == true
        }
        return this
    }

    fun applyTemplates(dataList: List<String>, mimeTypeList: List<String>): List<Boolean> =
        dataList.zip(mimeTypeList).map { (data, mimeType) ->
            (if (::matchingTemplates.isInitialized) matchingTemplates else _values)
                .any { template ->
                    MimeUtils.resolveMediaType(mimeType) !in
                            (template.permittedMediaTypes ?: emptyList()) ||
                            template.filterPath?.any { FileUtils.contains(it, data) } == true
                }
        }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/DrawerActivity.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer

import android.annotation.SuppressLint
import android.content.Intent
import android.os.Bundle
import android.widget.TextView
import androidx.activity.viewModels
import androidx.core.os.bundleOf
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.NavController
import androidx.navigation.findNavController
import androidx.navigation.ui.AppBarConfiguration
import androidx.navigation.ui.navigateUp
import androidx.navigation.ui.setupActionBarWithNavController
import androidx.navigation.ui.setupWithNavController
import com.google.android.material.internal.NavigationMenuPresenter
import com.google.android.material.internal.NavigationMenuView
import com.google.android.material.navigation.NavigationView
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseActivity
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.DrawerActivityBinding
import me.gm.cleaner.plugin.ktx.getObjectField
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.mediastore.ToolbarActionModeIndicator
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import rikka.recyclerview.fixEdgeEffect

abstract class DrawerActivity : BaseActivity() {
    private val viewModel: BinderViewModel by viewModels()
    private lateinit var drawerLayout: DrawerLayout
    private lateinit var navController: NavController
    private val appBarConfiguration by lazy {
        // Passing each menu ID as a set of Ids because each
        // menu should be considered as top level destinations.
        AppBarConfiguration(topLevelDestinationIds, drawerLayout)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val binding = DrawerActivityBinding.inflate(layoutInflater)
        setContentView(binding.root)
        navController = findNavController(R.id.nav_host)
        // NavController's backend
        val action = intent.action
        val shouldAlterStartDestination = savedInstanceState == null &&
                (action != Intent.ACTION_MAIN ||
                        RootPreferences.startDestination in topLevelDestinationIds)
        if (shouldAlterStartDestination) {
            when (action) {
                "me.gm.cleaner.plugin.intent.action.AUDIO" ->
                    RootPreferences.startDestination = R.id.audio_fragment

                "me.gm.cleaner.plugin.intent.action.FILES" ->
                    RootPreferences.startDestination = R.id.files_fragment

                "me.gm.cleaner.plugin.intent.action.IMAGES" ->
                    RootPreferences.startDestination = R.id.images_fragment

                "me.gm.cleaner.plugin.intent.action.VIDEO" ->
                    RootPreferences.startDestination = R.id.video_fragment
            }
            val navGraph = navController.navInflater.inflate(R.navigation.nav_graph).apply {
                val startDestId = if (action == Intent.ACTION_VIEW) {
                    when {
                        MimeUtils.isAudioMimeType(intent.type) -> R.id.audio_fragment
                        MimeUtils.isImageMimeType(intent.type) -> R.id.image_pager_fragment
                        MimeUtils.isVideoMimeType(intent.type) -> R.id.video_player_fragment
                        else -> throw IllegalArgumentException(intent.type)
                    }
                } else {
                    RootPreferences.startDestination
                }
                setStartDestination(startDestId)
            }
            val args = if (action == Intent.ACTION_VIEW) {
                bundleOf(
                    "uri" to intent.data,
                    "uris" to arrayOf(intent.data),
                )
            } else {
                null
            }
            navController.setGraph(navGraph, args)
        }
        navController.addOnDestinationChangedListener { _, destination, _ ->
            if (destination.id in topLevelDestinationIds) {
                RootPreferences.startDestination = destination.id

                supportFragmentManager.findFragmentById(R.id.nav_host)
                    ?.childFragmentManager?.fragments?.forEach {
                        if (it.exitTransition is Hold) {
                            it.exitTransition = null
                        }
                    }
            }
        }

        // NavController's frontend
        drawerLayout = binding.drawerLayout
        setupActionBarWithNavController(navController, appBarConfiguration)
        val navView = binding.navView
        navView.setupWithNavController(navController)
        customizeNavViewStyle(navView)
        if (shouldAlterStartDestination) {
            navView.setCheckedItem(RootPreferences.startDestination)
        }

        navView.getHeaderView(0).findViewById<TextView>(R.id.status).setText(
            when {
                !viewModel.pingBinder() -> R.string.not_active
                viewModel.moduleVersion != BuildConfig.VERSION_CODE -> R.string.restart_system
                else -> R.string.active
            }
        )
    }

    @SuppressLint("RestrictedApi")
    private fun customizeNavViewStyle(navView: NavigationView) {
        val presenter = navView.getObjectField<NavigationMenuPresenter>()
        val menuView = presenter.getMenuView(navView) as NavigationMenuView
        menuView.fixEdgeEffect(false)
        menuView.overScrollIfContentScrollsPersistent()
    }

    override fun onBackPressed() {
        when {
            drawerLayout.isOpen -> drawerLayout.close()
            navController.currentDestination?.id in topLevelDestinationIds &&
                    supportFragmentManager.findFragmentById(R.id.nav_host)
                        ?.childFragmentManager?.fragments?.first()?.let {
                            it !is ToolbarActionModeIndicator || !it.isInActionMode()
                        } == true -> super.onSupportNavigateUp()

            else -> super.onBackPressed()
        }
    }

    override fun onSupportNavigateUp() =
        navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()

    companion object {
        val topLevelDestinationIds = setOf(
            R.id.applist_fragment,
            R.id.usage_record_fragment,
            R.id.settings_fragment,
            R.id.audio_fragment,
            R.id.downloads_fragment,
            R.id.files_fragment,
            R.id.images_fragment,
            R.id.video_fragment,
            R.id.playground_fragment,
            R.id.about_fragment,
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/about/AboutFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.about

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.noties.markwon.Markwon
import io.noties.markwon.ext.strikethrough.StrikethroughPlugin
import io.noties.markwon.html.HtmlPlugin
import io.noties.markwon.image.ImagesPlugin
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.AboutFragmentBinding
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import java.lang.ref.WeakReference

@AndroidEntryPoint
class AboutFragment : BaseFragment() {
    private val viewModel: AboutViewModel by viewModels()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = AboutFragmentBinding.inflate(layoutInflater)

        liftOnScrollTargetView = WeakReference(binding.listContainer)
        binding.listContainer.fitsSystemWindowInsets()

        lifecycleScope.launch {
            val rawReadme = viewModel.getRawReadmeAsync().await()
            binding.progress.hide()
            val md = rawReadme.getOrElse {
                binding.content.text = it.stackTraceToString()
                return@launch
            }
            val markwon = Markwon.builder(requireContext())
                .usePlugin(StrikethroughPlugin.create())
                .usePlugin(HtmlPlugin.create())
                .usePlugin(ImagesPlugin.create())
                .build()
            markwon.setMarkdown(binding.content, md)
        }
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/about/AboutViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.about

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.data.github.ReadmeRepository
import java.util.Locale
import javax.inject.Inject

@HiltViewModel
class AboutViewModel @Inject constructor(private val repository: ReadmeRepository) : ViewModel() {
    private var rawReadme: Result<String> = Result.failure(UninitializedPropertyAccessException())

    fun getRawReadmeAsync() = viewModelScope.async {
        if (rawReadme.isFailure) {
            withContext(Dispatchers.IO) {
                rawReadme = repository.getRawReadme(Locale.getDefault().toLanguageTag())
            }
        }
        rawReadme
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.playground

import android.annotation.SuppressLint
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.coordinatorlayout.widget.CoordinatorLayout
import androidx.lifecycle.viewModelScope
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.behavior.SwipeDismissBehavior
import com.google.android.material.divider.MaterialDivider
import kotlinx.coroutines.CoroutineStart
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.ConfirmationDialog
import me.gm.cleaner.plugin.databinding.PlaygroundCardActionBinding
import me.gm.cleaner.plugin.databinding.PlaygroundCardHeaderBinding
import me.gm.cleaner.plugin.databinding.PlaygroundCardSubheaderBinding
import me.gm.cleaner.plugin.ktx.hasWifiTransport

@SuppressLint("PrivateResource")
class PlaygroundAdapter(
    private val fragment: PlaygroundFragment, private val viewModel: PlaygroundViewModel
) : ListAdapter<PlaygroundContentItem, RecyclerView.ViewHolder>(CALLBACK) {

    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is PlaygroundContentSeparatorItem -> com.google.android.material.R.layout.design_navigation_item_separator
        is PlaygroundContentHeaderItem -> R.layout.playground_card_header
        is PlaygroundContentSubHeaderItem -> R.layout.playground_card_subheader
        is PlaygroundContentActionItem -> R.layout.playground_card_action
        else -> throw IndexOutOfBoundsException()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder =
        when (viewType) {
            com.google.android.material.R.layout.design_navigation_item_separator ->
                SeparatorViewHolder(parent.context)

            R.layout.playground_card_header -> HeaderCardViewHolder(
                PlaygroundCardHeaderBinding.inflate(LayoutInflater.from(parent.context))
            )

            R.layout.playground_card_subheader -> SubHeaderCardViewHolder(
                PlaygroundCardSubheaderBinding.inflate(LayoutInflater.from(parent.context))
            )

            R.layout.playground_card_action -> ActionCardViewHolder(
                PlaygroundCardActionBinding.inflate(LayoutInflater.from(parent.context))
            )

            else -> throw IndexOutOfBoundsException()
        }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is HeaderCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentHeaderItem
                binding.title.text = item.title
            }

            is SubHeaderCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentSubHeaderItem
                binding.cardContextText.text = item.content
                val card = binding.card
                val swipeDismissBehavior = SwipeDismissBehavior<View>().apply {
                    setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_ANY)
                    setListener(object : SwipeDismissBehavior.OnDismissListener {
                        override fun onDragStateChanged(state: Int) {
                            when (state) {
                                SwipeDismissBehavior.STATE_DRAGGING,
                                SwipeDismissBehavior.STATE_SETTLING -> card.isDragged = true

                                SwipeDismissBehavior.STATE_IDLE -> card.isDragged = false
                            }
                        }

                        override fun onDismiss(view: View) {
                            viewModel.dismissedCards.add(item.id)
                            viewModel.prepareContentItems(fragment, this@PlaygroundAdapter)
                        }
                    })
                }
                val coordinatorParams = card.layoutParams as CoordinatorLayout.LayoutParams
                coordinatorParams.behavior = swipeDismissBehavior
            }

            is ActionCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentActionItem
                binding.title.text = item.title
                binding.summary.text = item.summary
                val button = binding.button
                button.addOnCheckedChangeListener { _, isChecked ->
                    button.setText(
                        if (isChecked) android.R.string.cancel
                        else R.string.start
                    )
                }
                val deferred = viewModel.actions[item.id]
                button.isChecked = deferred != null && deferred.isActive

                button.setOnClickListener {
                    var deferred = viewModel.actions[item.id] as? Deferred<Unit>
                    if (deferred == null || !deferred.isActive) {
                        deferred = viewModel.viewModelScope
                            .async(Dispatchers.Main.immediate, CoroutineStart.LAZY) {
                                item.action!!()
                            }
                        viewModel.actions.put(item.id, deferred)
                        if (item.needsNetwork && !fragment.requireContext().hasWifiTransport) {
                            ConfirmationDialog
                                .newInstance(fragment.getString(R.string.no_wifi))
                                .apply {
                                    addOnPositiveButtonClickListener {
                                        startAction(deferred)
                                    }
                                }
                                .show(fragment.childFragmentManager, null)
                        } else {
                            startAction(deferred)
                        }
                    } else {
                        deferred.cancel()
                    }
                }
            }
        }
    }

    private fun startAction(deferred: Deferred<Unit>): Job = viewModel.viewModelScope.launch {
        deferred.await()
    }

    override fun getItemId(position: Int): Long = getItem(position).id.toLong()

    class SeparatorViewHolder(context: Context) :
        RecyclerView.ViewHolder(FrameLayout(context).apply {
            val cardMargin = context.resources.getDimensionPixelSize(R.dimen.card_margin)
            addView(MaterialDivider(context).apply {
                dividerInsetStart = cardMargin
                dividerInsetEnd = cardMargin
            })
            setPaddingRelative(0, cardMargin, 0, 0)
        })

    class HeaderCardViewHolder(val binding: PlaygroundCardHeaderBinding) :
        RecyclerView.ViewHolder(binding.root)

    class SubHeaderCardViewHolder(val binding: PlaygroundCardSubheaderBinding) :
        RecyclerView.ViewHolder(binding.root)

    class ActionCardViewHolder(val binding: PlaygroundCardActionBinding) :
        RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<PlaygroundContentItem>() {
            override fun areItemsTheSame(
                oldItem: PlaygroundContentItem, newItem: PlaygroundContentItem
            ): Boolean = oldItem.id == newItem.id

            @SuppressLint("DiffUtilEquals")
            override fun areContentsTheSame(
                oldItem: PlaygroundContentItem, newItem: PlaygroundContentItem
            ): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundContentItem.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.playground

import android.annotation.SuppressLint
import android.view.View
import androidx.appcompat.view.menu.MenuBuilder
import kotlinx.coroutines.CoroutineScope

/** Unified data model for all sorts of playground content items. */
abstract class PlaygroundContentItem(
    open val id: Int
)

/** Separator items. */
data class PlaygroundContentSeparatorItem(
    override val id: Int = View.generateViewId()
) : PlaygroundContentItem(id)

/** Normal or header items. */
data class PlaygroundContentHeaderItem(
    override val id: Int,
    var title: CharSequence?
) : PlaygroundContentItem(id)

/** Normal or subheader items. */
data class PlaygroundContentSubHeaderItem(
    override val id: Int,
    var content: CharSequence?,
    var dismissed: Boolean
) : PlaygroundContentItem(id)

/** Action items. */
data class PlaygroundContentActionItem(
    override val id: Int,
    var title: CharSequence?,
    var summary: CharSequence?,
    var action: (suspend CoroutineScope.() -> Unit)? = null,
    var needsNetwork: Boolean
) : PlaygroundContentItem(id)

object PlaygroundContentItems {

    /** Convert MenuItemImpl to PlaygroundMenuItem. */
    fun forMenuBuilder(menu: MenuBuilder): MutableList<PlaygroundContentItem> {
        val items = mutableListOf<PlaygroundContentItem>()
        convertTo(items, menu)
        return items
    }

    @SuppressLint("RestrictedApi")
    private fun convertTo(items: MutableList<PlaygroundContentItem>, menu: MenuBuilder) {
        menu.visibleItems.forEach { menuItemImpl ->
            when {
                menuItemImpl.hasSubMenu() -> {
                    if (items.isNotEmpty()) {
                        items.add(PlaygroundContentSeparatorItem())
                    }
                    items.add(PlaygroundContentHeaderItem(menuItemImpl.itemId, menuItemImpl.title))
                    convertTo(items, menuItemImpl.subMenu as MenuBuilder)
                }

                menuItemImpl.isCheckable -> items.add(
                    PlaygroundContentSubHeaderItem(
                        menuItemImpl.itemId, menuItemImpl.title, menuItemImpl.isChecked
                    )
                )

                else -> items.add(
                    PlaygroundContentActionItem(
                        menuItemImpl.itemId,
                        menuItemImpl.title,
                        menuItemImpl.titleCondensed,
                        needsNetwork = menuItemImpl.isChecked
                    )
                )
            }
        }
    }

    inline fun <reified T : PlaygroundContentItem> Collection<PlaygroundContentItem>.findItemById(id: Int) =
        first { id == it.id } as T

    fun Collection<PlaygroundContentItem>.findIndexById(id: Int) = indexOfFirst { id == it.id }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.playground

import android.graphics.Rect
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.util.keyIterator
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import dagger.hilt.android.AndroidEntryPoint
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.PlaygroundFragmentBinding
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findIndexById
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference

@AndroidEntryPoint
class PlaygroundFragment : BaseFragment() {
    private val viewModel: PlaygroundViewModel by viewModels()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = PlaygroundFragmentBinding.inflate(layoutInflater)

        val adapter = PlaygroundAdapter(this, viewModel).apply {
            setHasStableIds(true)
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        list.addItemDecoration(object : RecyclerView.ItemDecoration() {
            private var dividerHeight = resources.getDimensionPixelSize(R.dimen.card_margin)

            override fun getItemOffsets(
                outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State
            ) {
                outRect.bottom = dividerHeight
            }
        })

        viewModel.prepareContentItems(this, adapter)
        viewModel.unsplashPhotosLiveData.observe(viewLifecycleOwner) {
            val changedItemIds = mutableListOf<Int>()
            viewModel.actions.keyIterator().forEach { id ->
                if (!viewModel.actions[id].isActive) {
                    changedItemIds.add(id)
                    val position = adapter.currentList.findIndexById(id)
                    adapter.notifyItemChanged(position)
                }
            }
            changedItemIds.forEach { id ->
                viewModel.actions.remove(id)
            }
        }
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.drawer.playground

import android.annotation.SuppressLint
import android.app.DownloadManager
import android.content.ContentValues
import android.content.Context
import android.os.Environment
import android.os.FileUtils
import android.provider.MediaStore
import android.util.SparseArray
import android.widget.Toast
import androidx.appcompat.view.menu.MenuBuilder
import androidx.core.net.toUri
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.navigation.fragment.findNavController
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ensureActive
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.data.unsplash.UnsplashPhoto
import me.gm.cleaner.plugin.data.unsplash.UnsplashRepository
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findIndexById
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findItemById
import java.io.File
import java.net.URL
import javax.inject.Inject

@HiltViewModel
class PlaygroundViewModel @Inject constructor(private val repository: UnsplashRepository) :
    ViewModel() {
    val dismissedCards = mutableListOf<Int>()

    @SuppressLint("RestrictedApi")
    fun prepareContentItems(fragment: PlaygroundFragment, adapter: PlaygroundAdapter) {
        val activity = fragment.requireActivity()
        val menu = MenuBuilder(activity)
        activity.menuInflater.inflate(R.menu.playground_content, menu)
        val items = PlaygroundContentItems.forMenuBuilder(menu)
        dismissedCards.asSequence()
            .map { id -> items.findIndexById(id) }
            .sortedDescending()
            .forEach { indexOfSubHeader ->
                if (indexOfSubHeader + 1 <= items.size &&
                    items[indexOfSubHeader + 1] is PlaygroundContentSeparatorItem
                ) {
                    items.removeAt(indexOfSubHeader + 1)
                }
                items.removeAt(indexOfSubHeader)
            }

        items.findItemById<PlaygroundContentActionItem>(R.id.unsplash_download_manager).action =
            unsplashDownloadManager(activity)
        items.findItemById<PlaygroundContentActionItem>(R.id.unsplash_insert).action =
            unsplashInsert(activity)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_insert).action =
            interceptInsert(fragment)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_download_manager).action =
            interceptDownloadManager(fragment)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_query).action =
            interceptQuery(fragment)

        adapter.submitList(items)
    }

    val actions = SparseArray<Deferred<*>>()

    private val _unsplashPhotosLiveData: MutableLiveData<Result<List<UnsplashPhoto>>> =
        MutableLiveData(Result.failure(UninitializedPropertyAccessException()))
    val unsplashPhotosLiveData: LiveData<Result<List<UnsplashPhoto>>> = _unsplashPhotosLiveData
    private var unsplashPhotos: Result<List<UnsplashPhoto>>
        get() = _unsplashPhotosLiveData.value!!
        set(value) {
            _unsplashPhotosLiveData.postValue(value)
        }

    private var width = 0
    private lateinit var downloadManager: DownloadManager
    private fun unsplashDownloadManager(context: Context): suspend CoroutineScope.() -> Unit {
        if (!::downloadManager.isInitialized) {
            width = context.resources.displayMetrics.widthPixels
            downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
        }
        return {
            val unsplashPhotoListResult = withContext(Dispatchers.IO) {
                if (unsplashPhotos.isSuccess) unsplashPhotos
                else repository.fetchUnsplashPhotoList()
            }
            unsplashPhotoListResult.onSuccess { unsplashPhotos ->
                withContext(Dispatchers.IO) {
                    repeat(10) {
                        ensureActive()
                        val unsplashPhoto = unsplashPhotos.random()
                        val request = DownloadManager
                            .Request(unsplashPhoto.getPhotoUrl(width).toUri())
                            .setDestinationInExternalPublicDir(
                                Environment.DIRECTORY_PICTURES,
                                File.separator + "MPM" + File.separator + unsplashPhoto.filename
                            )
                        val id = downloadManager.enqueue(request)
                    }
                }
            }.onFailure { e ->
                e.printStackTrace()
                Toast.makeText(context, e.message, Toast.LENGTH_LONG).show()
            }
            unsplashPhotos = unsplashPhotoListResult
        }
    }

    private fun unsplashInsert(context: Context): suspend CoroutineScope.() -> Unit {
        if (!::downloadManager.isInitialized) {
            width = context.resources.displayMetrics.widthPixels
        }
        return {
            val unsplashPhotoListResult = withContext(Dispatchers.IO) {
                if (unsplashPhotos.isSuccess) unsplashPhotos
                else repository.fetchUnsplashPhotoList()
            }
            unsplashPhotoListResult.onSuccess { unsplashPhotos ->
                withContext(Dispatchers.IO) {
                    val resolver = context.contentResolver
                    repeat(10) {
                        ensureActive()
                        val unsplashPhoto = unsplashPhotos.random()
                        val imageDetails = ContentValues().apply {
                            put(
                                MediaStore.MediaColumns.RELATIVE_PATH,
                                Environment.DIRECTORY_PICTURES + File.separator + "MPM"
                            )
                            put(MediaStore.MediaColumns.DISPLAY_NAME, unsplashPhoto.filename)
                            put(
                                MediaStore.MediaColumns.MIME_TYPE,
                                "image/${unsplashPhoto.filename.substringAfterLast('.')}"
                            )
                            put(MediaStore.Audio.Media.IS_PENDING, 1)
                        }
                        val imageUri = resolver.insert(
                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageDetails
                        ) ?: return@repeat
                        runCatching {
                            val `is` = URL(unsplashPhoto.getPhotoUrl(width)).openStream()
                            val os = resolver.openOutputStream(imageUri, "w") ?: return@runCatching
                            FileUtils.copy(`is`, os)
                        }
                        imageDetails.clear()
                        imageDetails.put(MediaStore.Audio.Media.IS_PENDING, 0)
                        resolver.update(imageUri, imageDetails, null, null)
                    }
                }
            }.onFailure { e ->
                e.printStackTrace()
                Toast.makeText(context, e.message, Toast.LENGTH_LONG).show()
            }
            unsplashPhotos = unsplashPhotoListResult
        }
    }

    private fun interceptInsert(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_insert_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_query),
                packageNames = arrayOf(BuildConfig.APPLICATION_ID),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }

    private fun interceptDownloadManager(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_download_manager_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_query),
                packageNames = fragment.resources.getStringArray(R.array.recommend_package),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }

    private fun interceptQuery(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_query_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_insert),
                packageNames = arrayOf(BuildConfig.APPLICATION_ID),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }
}

private inline operator fun <reified T> Array<T>.minus(string: T): Array<T> {
    return (toMutableSet() - string).toTypedArray()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaModelLoader.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore;

import android.content.Context;
import android.media.MediaMetadataRetriever;
import android.net.Uri;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.DataSource;
import com.bumptech.glide.load.Options;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.model.ModelLoaderFactory;
import com.bumptech.glide.load.model.MultiModelLoaderFactory;
import com.bumptech.glide.signature.ObjectKey;

import java.nio.ByteBuffer;

/**
 * An implementation of {@link ModelLoader} to support {@link com.bumptech.glide.Glide} loading for
 * media store {@link Uri}.
 * <p>
 * You should register this in {@link com.bumptech.glide.module.AppGlideModule}, see
 * <a href="https://bumptech.github.io/glide/tut/custom-modelloader.html#registering-our-modelloader-with-glide">
 * Registering our ModelLoader with Glide</a> for more information.
 * <p>
 * This is backed by {@link MediaMetadataRetriever}.
 */
public class MediaModelLoader implements ModelLoader<Uri, ByteBuffer> {
    private final Context mContext;

    MediaModelLoader(Context context) {
        mContext = context;
    }

    @Override
    public boolean handles(@NonNull Uri uri) {
        return true;
    }

    @Nullable
    @Override
    public LoadData<ByteBuffer> buildLoadData(@NonNull Uri uri, int width, int height,
                                              @NonNull Options options) {
        return new LoadData<>(new ObjectKey(uri), new MediaMetadataFetcher(uri));
    }

    class MediaMetadataFetcher implements DataFetcher<ByteBuffer> {
        private final Uri mUri;

        private MediaMetadataFetcher(Uri uri) {
            mUri = uri;
        }

        @Override
        public void loadData(@NonNull Priority priority,
                             @NonNull DataCallback<? super ByteBuffer> callback) {
            try (var retriever = new MediaMetadataRetriever()) {
                retriever.setDataSource(mContext, mUri);
                var data = retriever.getEmbeddedPicture();
                var byteBuffer = ByteBuffer.wrap(data);
                callback.onDataReady(byteBuffer);
            } catch (Exception e) {
                callback.onLoadFailed(e);
            }
        }

        @Override
        public void cleanup() {
        }

        @Override
        public void cancel() {
        }

        @NonNull
        @Override
        public Class<ByteBuffer> getDataClass() {
            return ByteBuffer.class;
        }

        @NonNull
        @Override
        public DataSource getDataSource() {
            return DataSource.LOCAL;
        }
    }

    public static class Factory implements ModelLoaderFactory<Uri, ByteBuffer> {
        @NonNull
        private final Context mContext;

        public Factory(@NonNull Context context) {
            mContext = context.getApplicationContext();
        }

        @NonNull
        @Override
        public ModelLoader<Uri, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
            return new MediaModelLoader(mContext);
        }

        @Override
        public void teardown() {
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.net.Uri
import android.text.format.DateUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import androidx.annotation.CallSuper
import androidx.fragment.app.Fragment
import androidx.recyclerview.selection.ItemDetailsLookup
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import androidx.recyclerview.selection.SelectionTracker
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.databinding.MediaStoreHeaderBinding
import java.util.Calendar

abstract class MediaStoreAdapter(private val fragment: Fragment) :
    ListAdapter<MediaStoreModel, MediaStoreAdapter.ViewHolder>(
        MediaStoreModel.createCallback<MediaStoreModel>()
    ) {
    lateinit var selectionTracker: SelectionTracker<Long>

    protected val selectionTrackerInitialized: Boolean
        get() = ::selectionTracker.isInitialized

    @CallSuper
    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreHeader -> R.layout.media_store_header
        else -> throw IndexOutOfBoundsException()
    }

    @CallSuper
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.media_store_header -> HeaderViewHolder(
                MediaStoreHeaderBinding.inflate(LayoutInflater.from(parent.context), parent, false)
            )

            else -> throw IndexOutOfBoundsException()
        }

    @CallSuper
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is HeaderViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreHeader
                binding.title.text = item.title
            }
        }
    }

    // Id is unique in media store, hence we can use it as stable id directly.
    override fun getItemId(position: Int): Long = getItem(position).id

    protected val then: Calendar = Calendar.getInstance()
    protected val now: Calendar = Calendar.getInstance()
    protected open fun formatDateTime(timeMillis: Long): String {
        fun onTheSameDay(): Boolean = then[Calendar.YEAR] == now[Calendar.YEAR] &&
                then[Calendar.DAY_OF_YEAR] == now[Calendar.DAY_OF_YEAR]

        then.timeInMillis = timeMillis
        now.timeInMillis = System.currentTimeMillis()
        return when {
            onTheSameDay() -> {
                fragment.getString(R.string.today)
            }

            run {
                now.add(Calendar.DATE, -1)
                onTheSameDay()
            } -> {
                fragment.getString(R.string.yesterday)
            }

            else -> {
                val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                        DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_DATE
                DateUtils.formatDateTime(fragment.requireContext(), timeMillis, flags)
            }
        }
    }

    private val uriPositionMap: MutableList<Int> = mutableListOf()
    fun getHolderPositionForUriPosition(position: Int): Int? = uriPositionMap.getOrNull(position)

    protected fun getUriPositionForAdapterPosition(position: Int): Int =
        uriPositionMap.binarySearch(position)

    protected open fun onPreSubmitList(list: List<MediaStoreModel>): List<MediaStoreModel> {
        uriPositionMap.clear()
        return when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH -> {
                val groupedList = mutableListOf<MediaStoreModel>()
                var lastHeader = ""
                list.forEach { model ->
                    val header = model.relativePath
                    if (lastHeader != header) {
                        lastHeader = header
                        groupedList += MediaStoreHeader(header)
                    }
                    uriPositionMap += groupedList.size
                    groupedList += model
                }
                groupedList
            }

            SORT_BY_DATE_TAKEN -> {
                val groupedList = mutableListOf<MediaStoreModel>()
                var lastHeader = ""
                list.forEach { model ->
                    val header = formatDateTime(model.dateTaken)
                    if (lastHeader != header) {
                        lastHeader = header
                        groupedList += MediaStoreHeader(header)
                    }
                    uriPositionMap += groupedList.size
                    groupedList += model
                }
                groupedList
            }

            else -> {
                repeat(list.size) { position ->
                    uriPositionMap += position
                }
                list
            }
        }
    }

    override fun submitList(list: List<MediaStoreModel>?) {
        submitList(list, null)
    }

    override fun submitList(list: List<MediaStoreModel>?, commitCallback: Runnable?) {
        if (list != null) {
            super.submitList(onPreSubmitList(list), commitCallback)
        } else {
            super.submitList(list, commitCallback)
        }
    }

    abstract class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        var details: ItemDetails<Long>? = null
    }

    class HeaderViewHolder(val binding: MediaStoreHeaderBinding) : ViewHolder(binding.root)
}

class DetailsLookup(private val list: RecyclerView) : ItemDetailsLookup<Long>() {

    override fun getItemDetails(e: MotionEvent): ItemDetails<Long>? {
        val view = list.findChildViewUnder(e.x, e.y)
        if (view != null) {
            val viewHolder = list.getChildViewHolder(view)
            if (viewHolder is MediaStoreAdapter.ViewHolder) {
                return viewHolder.details
            }
        }
        return null
    }
}

class MediaStoreHeader(val title: String) :
    MediaStoreModel(title.hashCode().toLong(), Uri.EMPTY, "", "", "", -1L) {
    override fun hashCode(): Int = title.hashCode()
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as MediaStoreHeader

        if (title != other.title) return false

        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.app.Activity
import android.content.ActivityNotFoundException
import android.content.Intent
import android.media.MediaScannerConnection
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.view.ActionMode
import androidx.core.view.children
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.selection.SelectionTracker
import androidx.recyclerview.selection.SelectionTracker.SelectionPredicate
import androidx.recyclerview.selection.StorageStrategy
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.app.ConfirmationDialog
import me.gm.cleaner.plugin.app.InfoDialog
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.submitListKeepPosition
import me.gm.cleaner.plugin.ui.mediastore.audio.AudioFragment
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment
import me.gm.cleaner.plugin.ui.mediastore.files.MediaStoreFiles
import me.gm.cleaner.plugin.ui.mediastore.images.ImagesFragment
import me.gm.cleaner.plugin.ui.mediastore.video.VideoFragment
import me.gm.cleaner.plugin.util.MediaStoreCompat
import me.gm.cleaner.plugin.util.MediaStoreCompat.DELETE_PERMISSION_REQUEST
import me.gm.cleaner.plugin.util.PermissionUtils
import me.gm.cleaner.plugin.util.RequesterFragment
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import me.zhanghai.android.fastscroll.ItemsHeightsObserver
import me.zhanghai.android.fastscroll.PreciseRecyclerViewHelper
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import java.util.function.Supplier

abstract class MediaStoreFragment : BaseFragment(), ToolbarActionModeIndicator {
    protected abstract val viewModel: MediaStoreViewModel<*>
    protected abstract val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment>
    protected lateinit var selectionTracker: SelectionTracker<Long>
    private var actionMode: ActionMode? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View? {
        val binding = MediaStoreFragmentBinding.inflate(inflater)

        val adapter = onCreateAdapter().apply {
            setHasStableIds(true)
            stateRestorationPolicy = RecyclerView.Adapter.StateRestorationPolicy.PREVENT_WHEN_EMPTY
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        selectionTracker = SelectionTracker
            .Builder(
                /* selectionId = */ javaClass.name,
                list,
                StableIdKeyProvider(adapter),
                DetailsLookup(list),
                StorageStrategy.createLongStorage()
            )
            .withSelectionPredicate(object : SelectionPredicate<Long>() {
                override fun canSetStateForKey(key: Long, nextState: Boolean): Boolean =
                    !nextState || viewModel.medias.any { it.id == key }

                override fun canSetStateAtPosition(position: Int, nextState: Boolean): Boolean {
                    if (position == RecyclerView.NO_POSITION) {
                        return false
                    }
                    val currentList = adapter.currentList
                    // empty onConfigurationChanged
                    return currentList.isEmpty() || currentList[position] !is MediaStoreHeader
                }

                override fun canSelectMultiple(): Boolean = true
            })
            .build()
        selectionTracker.onRestoreInstanceState(savedInstanceState)
        selectionTracker.addObserver(object : SelectionTracker.SelectionObserver<Long>() {
            override fun onSelectionChanged() {
                if (selectionTracker.hasSelection()) {
                    startActionMode()
                } else {
                    actionMode?.finish()
                }
            }
        })
        adapter.selectionTracker = selectionTracker
        onBindView(binding, list, adapter)

        findNavController().addOnExitListener { _, destination, _ ->
            actionMode?.finish()
            supportActionBar?.title = destination.label
        }

        lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.mediasFlow.collect { medias ->
                    val mediaIds = medias.map { it.id }.toSet()
                    val deletedItems =
                        selectionTracker.selection.filterNot { mediaIds.contains(it) }
                    deletedItems.forEach { key ->
                        selectionTracker.deselect(key)
                    }
                    adapter.submitListKeepPosition(medias, list)
                }
            }
        }
        if (savedInstanceState == null) {
            PermissionUtils.requestPermissions(
                childFragmentManager, requesterFragmentClass.newInstance()
            )
        }
        return binding.root
    }

    abstract fun onCreateAdapter(): MediaStoreAdapter

    open fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
    }

    class MediaStoreRecyclerViewHelper(
        list: RecyclerView, currentListSupplier: Supplier<List<MediaStoreModel>>
    ) : PreciseRecyclerViewHelper(
        list, null, false, object : ItemsHeightsObserver(list, false) {
            private fun guessItemOffset(isHeader: Boolean): Int? {
                for (child in list.children) {
                    val vh = list.getChildViewHolder(child)
                    val position = vh.bindingAdapterPosition
                    if (isHeader && currentListSupplier.get()[position] is MediaStoreHeader ||
                        !isHeader && currentListSupplier.get()[position] !is MediaStoreHeader
                    ) {
                        return child.measuredHeight
                    }
                }
                return null
            }

            override fun guessItemOffsetAt(position: Int): Int? = try {
                if (currentListSupplier.get()[position] is MediaStoreHeader) {
                    guessItemOffset(true)
                } else {
                    guessItemOffset(false)
                }
            } catch (e: IndexOutOfBoundsException) {
                super.guessItemOffsetAt(position)
            }
        }
    )

    fun startActionMode() {
        if (!isInActionMode()) {
            val activity = requireActivity() as AppCompatActivity
            actionMode = activity.startToolbarActionMode(object : ActionMode.Callback {
                override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
                    mode.menuInflater.inflate(R.menu.mediastore_actionmode, menu)
                    return true
                }

                override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = false
                override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
                    val medias = selectionTracker.selection.mapNotNull { selection ->
                        viewModel.medias.firstOrNull { it.id == selection }
                    }
                    if (medias.isEmpty()) {
                        return true
                    }
                    when (item.itemId) {
                        R.id.menu_share -> {
                            val mimeType = when (this@MediaStoreFragment) {
                                is AudioFragment -> "audio/*"
                                is ImagesFragment -> "image/*"
                                is VideoFragment -> "video/*"
                                is FilesFragment -> when {
                                    medias.all { MimeUtils.isAudioMimeType((it as MediaStoreFiles).mimeType) } -> "audio/*"
                                    medias.all { MimeUtils.isImageMimeType((it as MediaStoreFiles).mimeType) } -> "image/*"
                                    medias.all { MimeUtils.isVideoMimeType((it as MediaStoreFiles).mimeType) } -> "video/*"
                                    else -> "*/*"
                                }

                                else -> throw UnsupportedOperationException()
                            }
                            val sendIntent = if (medias.size == 1) {
                                Intent(Intent.ACTION_SEND)
                                    .setType(mimeType)
                                    .putExtra(Intent.EXTRA_STREAM, medias.first().contentUri)
                                    .putExtra(Intent.EXTRA_TEXT, medias.first().displayName)
                            } else {
                                val mediaUris = ArrayList<Uri>(medias.size)
                                medias.mapTo(mediaUris) { it.contentUri }
                                Intent(Intent.ACTION_SEND_MULTIPLE)
                                    .setType(mimeType)
                                    .putParcelableArrayListExtra(Intent.EXTRA_STREAM, mediaUris)
                            }
                            val shareIntent = Intent.createChooser(sendIntent, null)
                            try {
                                startActivity(shareIntent)
                            } catch (e: ActivityNotFoundException) {
                                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT)
                                    .show()
                            }
                        }

                        R.id.menu_delete -> deleteSelectedMedias(true)

                        else -> return false
                    }
                    return true
                }

                override fun onDestroyActionMode(mode: ActionMode) {
                    selectionTracker.clearSelection()
                    actionMode = null
                }
            })
        }
        actionMode?.title = selectionTracker.selection.size().toString()
    }

    private fun deleteSelectedMedias(allowBulkDelete: Boolean) {
        lifecycleScope.launch {
            val medias = selectionTracker.selection.mapNotNull { selection ->
                viewModel.medias.firstOrNull { it.id == selection }
            }
            when {
                medias.size == 1 -> MediaStoreCompat.delete(
                    this@MediaStoreFragment, medias.single().contentUri
                )

                Build.VERSION.SDK_INT <= Build.VERSION_CODES.Q -> InfoDialog
                    // @see https://stackoverflow.com/questions/58283850/scoped-storage-how-to-delete-multiple-audio-files-via-mediastore
                    .newInstance(getString(R.string.unsupported_delete_in_bulk))
                    .show(childFragmentManager, null)

                else -> if (allowBulkDelete) {
                    MediaStoreCompat.delete(
                        this@MediaStoreFragment, medias.map { it.contentUri }
                    )
                }
            }
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == DELETE_PERMISSION_REQUEST) {
            deleteSelectedMedias(false)
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        if (::selectionTracker.isInitialized) {
            selectionTracker.onSaveInstanceState(outState)
        }
    }

    override fun isInActionMode(): Boolean = actionMode != null

    abstract class MediaPermissionsRequesterFragment : RequesterFragment() {
        private val parentFragment: MediaStoreFragment by lazy {
            requireParentFragment() as MediaStoreFragment
        }
        private val viewModel: MediaStoreViewModel<*> by lazy {
            parentFragment.viewModel
        }

        override fun onRequestPermissionsSuccess(permissions: Set<String>) {
            viewModel.load()
        }

        override fun onRequestPermissionsFailure(
            shouldShowRationale: Set<String>, denied: Set<String>
        ) {
            if (shouldShowRationale.isNotEmpty()) {
                ConfirmationDialog
                    .newInstance(getString(R.string.rationale_shouldShowRationale))
                    .apply {
                        addOnPositiveButtonClickListener {
                            onRequestPermissions(
                                shouldShowRationale.toTypedArray()
                            )
                        }
                    }
                    .show(childFragmentManager, null)
            }
        }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        if (selectionTracker.hasSelection()) {
            startActionMode()
            return
        }
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.mediastore_toolbar, menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean = when (item.itemId) {
        R.id.menu_refresh -> {
            viewModel.load()
            true
        }

        R.id.menu_scan_external_storage -> {
            MediaScannerConnection.scanFile(
                requireContext(), arrayOf(Environment.getExternalStorageDirectory().path),
                null, null
            )
            true
        }

        else -> super.onOptionsItemSelected(item)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.net.Uri
import androidx.recyclerview.widget.DiffUtil

abstract class MediaStoreModel(
    open val id: Long,
    open val contentUri: Uri,
    open val displayName: String,
    open val relativePath: String,
    open val data: String,
    open val dateTaken: Long,
) {
    companion object {
        fun <M : MediaStoreModel> createCallback() = object : DiffUtil.ItemCallback<M>() {
            override fun areItemsTheSame(oldItem: M, newItem: M): Boolean = oldItem.id == newItem.id
            override fun areContentsTheSame(oldItem: M, newItem: M): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.annotation.SuppressLint
import android.app.Application
import android.database.ContentObserver
import android.net.Uri
import android.os.Handler
import android.os.Looper
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import java.text.SimpleDateFormat
import java.util.concurrent.TimeUnit

abstract class MediaStoreViewModel<M : MediaStoreModel>(application: Application) :
    AndroidViewModel(application) {
    protected val _mediasFlow: MutableStateFlow<List<M>> = MutableStateFlow(emptyList())
    val mediasFlow: StateFlow<List<M>> = _mediasFlow.asStateFlow()
    val medias: List<M>
        get() = _mediasFlow.value

    protected lateinit var uriToLoad: Uri

    /**
     * Performs a one shot load of medias from [uri] [Uri] into
     * the [_mediasFlow] [MutableStateFlow] above.
     */
    fun load() {
        if (::uriToLoad.isInitialized) {
            viewModelScope.launch {
                _mediasFlow.value =
                    queryMedias(uriToLoad, RootPreferences.sortMediaByFlowable.value)
            }
        }
    }

    protected abstract suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<M>

    /**
     * Convenience method to convert a day/month/year date into a UNIX timestamp.
     *
     * We're suppressing the lint warning because we're not actually using the date formatter
     * to format the date to display, just to specify a format to use to parse it, and so the
     * locale warning doesn't apply.
     */
    @Suppress("SameParameterValue")
    @SuppressLint("SimpleDateFormat")
    protected fun dateToTimestamp(day: Int, month: Int, year: Int): Long =
        SimpleDateFormat("dd.MM.yyyy").let { formatter ->
            TimeUnit.MICROSECONDS.toSeconds(formatter.parse("$day.$month.$year")?.time ?: 0)
        }

    protected var contentObserver: ContentObserver =
        object : ContentObserver(Handler(Looper.getMainLooper())) {
            override fun onChange(selfChange: Boolean) {
                load()
            }
        }

    /**
     * Since we register a [ContentObserver], we want to unregister this when the `ViewModel`
     * is being released.
     */
    override fun onCleared() {
        contentObserver.let { contentObserver ->
            getApplication<Application>().contentResolver.unregisterContentObserver(contentObserver)
        }
    }

    companion object {
        const val TAG = "MediaStoreVM"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/SelectionDetector.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.content.Context
import android.view.GestureDetector
import android.view.MotionEvent

class LongPressingListener : GestureDetector.SimpleOnGestureListener() {
    var isSelecting = false

    override fun onLongPress(e: MotionEvent) {
        isSelecting = true
    }
}

class SelectionDetector(context: Context, private val l: LongPressingListener) :
    GestureDetector(context, l) {
    val isSelecting: Boolean
        get() = l.isSelecting

    private val onUp = setOf(MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL)

    override fun onTouchEvent(ev: MotionEvent): Boolean {
        if (ev.action in onUp) {
            l.isSelecting = false
        }
        return super.onTouchEvent(ev)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/StableIdKeyProvider.java
================================================
```
/*
 * Copyright 2017 The Android Open Source Project
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore;

import androidx.annotation.NonNull;
import androidx.recyclerview.selection.ItemKeyProvider;
import androidx.recyclerview.widget.RecyclerView;

/**
 * An {@link ItemKeyProvider} that provides item keys by way of native
 * {@link RecyclerView.Adapter} stable ids.
 *
 * <p>The corresponding RecyclerView.Adapter instance must:
 * <ol>
 *     <li> Enable stable ids using {@link RecyclerView.Adapter#setHasStableIds(boolean)}
 *     <li> Override {@link RecyclerView.Adapter#getItemId(int)} with a real implementation.
 * </ol>
 *
 * <p>
 * There are trade-offs with this implementation:
 * <ul>
 *     <li>It necessarily auto-boxes {@code long} stable id values into {@code Long} values for
 *     use as selection keys.
 *     <li>It deprives Chromebook users (actually, any device with an attached pointer) of support
 *     for band-selection.
 * </ul>
 *
 * <p>See com.example.android.supportv7.widget.selection.fancy.DemoAdapter.KeyProvider in the
 * SupportV7 Demos package for an example of how to implement a better ItemKeyProvider.
 */
public final class StableIdKeyProvider extends ItemKeyProvider<Long> {

    private static final String TAG = "StableIdKeyProvider";

    private final RecyclerView.Adapter<?> mAdapter;

    /**
     * Creates a new key provider that uses cached {@code long} stable ids associated
     * with the RecyclerView items.
     *
     * @param adapter the adapter of the owner RecyclerView
     */
    public StableIdKeyProvider(@NonNull RecyclerView.Adapter<?> adapter) {
        // Since this provide is based on stable ids based on whats laid out in the window
        // we can only satisfy "window" scope key access.
        super(SCOPE_CACHED);

        mAdapter = adapter;
    }

    @NonNull
    @Override
    public Long getKey(int position) {
        return mAdapter.getItemId(position);
    }

    @Override
    public int getPosition(@NonNull Long key) {
        for (int i = 0, itemCount = mAdapter.getItemCount(); i < itemCount; i++) {
            if (key == mAdapter.getItemId(i)) {
                return i;
            }
        }
        return RecyclerView.NO_POSITION;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/ToolbarActionMode.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.animation.ObjectAnimator
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.view.Window
import android.view.accessibility.AccessibilityEvent
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.graphics.drawable.DrawerArrowDrawable
import androidx.appcompat.view.ActionMode
import androidx.appcompat.view.menu.MenuBuilder
import androidx.appcompat.widget.Toolbar
import me.gm.cleaner.plugin.R

@SuppressLint("RestrictedApi")
class ToolbarActionMode(private val activity: AppCompatActivity, private val toolbar: Toolbar) {
    private val menu: MenuBuilder
        get() = toolbar.menu as MenuBuilder
    private val arrowDrawable = DrawerArrowDrawable(activity)
    private var animator: ValueAnimator? = null

    private val originalToolbarTitle = toolbar.title to toolbar.subtitle
    private var actionMode: ToolbarActionModeImpl? = null
    private var cancellable: OnBackPressedCallback? = null

    fun startActionMode(callback: ActionMode.Callback): ActionMode? {
        actionMode?.finish()

        val mode = object : ToolbarActionModeImpl(toolbar, callback) {
            override fun finish() {
                super.finish()
                actionMode = null
                closeMode()
            }
        }
        initForMode(mode)
        if (mode.dispatchOnCreate()) {
            // This needs to be set before invalidate() so that it calls
            // onPrepareActionMode()
            actionMode = mode
            mode.invalidate()
            animateToMode(true)
            toolbar.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
            return mode
        }
        closeMode()
        return null
    }

    private fun initForMode(mode: ToolbarActionModeImpl) {
        menu.close()
        menu.clear()
        toolbar.setNavigationOnClickListener {
            mode.finish()
        }
        toolbar.setOnMenuItemClickListener { item ->
            mode.onMenuItemSelected(menu, item)
        }
        val onBackPressedCallback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                mode.finish()
            }
        }
        activity.onBackPressedDispatcher.addCallback(activity, onBackPressedCallback)
        cancellable = onBackPressedCallback
    }

    private fun closeMode() {
        toolbar.title = originalToolbarTitle.first
        toolbar.subtitle = originalToolbarTitle.second
        menu.close()
        menu.clear()
        activity.onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, menu)
        toolbar.setNavigationOnClickListener {
            activity.onSupportNavigateUp()
        }
        toolbar.setOnMenuItemClickListener { item ->
            activity.onMenuItemSelected(Window.FEATURE_OPTIONS_PANEL, item)
        }
        cancellable?.remove()
        cancellable = null
        animateToMode(false)
    }

    fun animateToMode(toActionMode: Boolean) {
        setActionBarUpIndicator(!toActionMode)
    }

    @SuppressLint("PrivateResource")
    private fun setActionBarUpIndicator(showAsDrawerIndicator: Boolean) {
        toolbar.navigationIcon = arrowDrawable
        toolbar.setNavigationContentDescription(
            if (showAsDrawerIndicator) androidx.navigation.ui.R.string.nav_app_bar_open_drawer_description
            else androidx.navigation.ui.R.string.nav_app_bar_navigate_up_description
        )

        val endValue = if (showAsDrawerIndicator) 0f else 1f
        val startValue = arrowDrawable.progress
        animator?.cancel()
        animator = ObjectAnimator.ofFloat(arrowDrawable, "progress", startValue, endValue)
        animator?.start()
    }
}

interface ToolbarActionModeIndicator {
    fun isInActionMode(): Boolean
}

fun AppCompatActivity.startToolbarActionMode(callback: ActionMode.Callback) =
    ToolbarActionMode(this, findViewById(R.id.toolbar)).startActionMode(callback)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/ToolbarActionModeImpl.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore

import android.annotation.SuppressLint
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.view.accessibility.AccessibilityEvent
import androidx.annotation.StringRes
import androidx.appcompat.view.ActionMode
import androidx.appcompat.view.SupportMenuInflater
import androidx.appcompat.view.menu.MenuBuilder
import androidx.appcompat.widget.Toolbar

@SuppressLint("RestrictedApi")
open class ToolbarActionModeImpl(private val toolbar: Toolbar, private val callback: Callback) :
    ActionMode(), MenuBuilder.Callback {
    private val menu: MenuBuilder
        get() = toolbar.menu as MenuBuilder

    override fun setTitle(title: CharSequence?) {
        toolbar.title = title
    }

    override fun setTitle(@StringRes resId: Int) {
        toolbar.setTitle(resId)
    }

    override fun setSubtitle(subtitle: CharSequence?) {
        toolbar.subtitle = subtitle
    }

    override fun setSubtitle(@StringRes resId: Int) {
        toolbar.setSubtitle(resId)
    }

    override fun invalidate() {
        menu.stopDispatchingItemsChanged()
        callback.onPrepareActionMode(this, menu)
        menu.startDispatchingItemsChanged()
    }

    fun dispatchOnCreate(): Boolean {
        menu.stopDispatchingItemsChanged()
        try {
            return callback.onCreateActionMode(this, menu)
        } finally {
            menu.startDispatchingItemsChanged()
        }
    }

    override fun finish() {
        callback.onDestroyActionMode(this)
        toolbar.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
    }

    override fun getMenu(): Menu = toolbar.menu
    override fun getTitle(): CharSequence = toolbar.title
    override fun getSubtitle(): CharSequence = toolbar.subtitle
    override fun getMenuInflater() = SupportMenuInflater(toolbar.context)

    override fun onMenuItemSelected(menu: MenuBuilder, item: MenuItem) =
        callback.onActionItemClicked(this, item)

    override fun onMenuModeChange(menu: MenuBuilder) {
        invalidate()
    }

    override fun setCustomView(view: View?) {
        throw UnsupportedOperationException()
    }

    override fun getCustomView(): View {
        throw UnsupportedOperationException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/audio/AudioFragment.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.audio

import android.Manifest
import android.os.Build
import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment

class AudioFragment : FilesFragment() {
    override val viewModel: AudioViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        AudioPermissionsRequesterFragment::class.java

//    override fun onCreateAdapter() = AudioAdapter(this)

    class AudioPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_AUDIO)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/audio/AudioViewModel.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.audio

import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel

class AudioViewModel(application: Application) : FilesViewModel(application) {
     private val uri: Uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI

     init {
          viewModelScope.launch {
               combine(
                    _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
               ) { isSearching, queryText, sortMediaBy ->
                    queryMedias(uri, sortMediaBy)
               }.collect {
                    _mediasFlow.value = it
               }
          }
          application.contentResolver.registerContentObserver(
               uri, true, contentObserver
          )
     }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/downloads/DownloadsFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.downloads

import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment

class DownloadsFragment : FilesFragment() {
    override val viewModel: DownloadsViewModel by viewModels()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/downloads/DownloadsViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.downloads

import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel

class DownloadsViewModel(application: Application) : FilesViewModel(application) {
    private val uri: Uri = MediaStore.Downloads.EXTERNAL_CONTENT_URI

    init {
        viewModelScope.launch {
            combine(
                _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
            ) { isSearching, queryText, sortMediaBy ->
                queryMedias(uri, sortMediaBy)
            }.collect {
                _mediasFlow.value = it
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.files

import android.annotation.SuppressLint
import android.content.ActivityNotFoundException
import android.content.Intent
import android.text.format.DateUtils
import android.text.format.Formatter
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import com.bumptech.glide.Glide
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.databinding.FilesItemBinding
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import java.util.Calendar

open class FilesAdapter(private val fragment: Fragment) : MediaStoreAdapter(fragment) {

    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreFiles -> R.layout.files_item
        else -> super.getItemViewType(position)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.files_item -> ItemViewHolder(
                FilesItemBinding.inflate(LayoutInflater.from(parent.context))
            )

            else -> super.onCreateViewHolder(parent, viewType)
        }

    private fun formatDateTimeForItem(timeMillis: Long): String {
        then.timeInMillis = timeMillis
        now.timeInMillis = System.currentTimeMillis()
        val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                DateUtils.FORMAT_ABBREV_ALL or when {
            RootPreferences.sortMediaByFlowable.value == SORT_BY_DATE_TAKEN -> {
                DateUtils.FORMAT_SHOW_TIME
            }

            then[Calendar.YEAR] != now[Calendar.YEAR] -> {
                DateUtils.FORMAT_SHOW_YEAR or DateUtils.FORMAT_SHOW_DATE
            }

            then[Calendar.DAY_OF_YEAR] != now[Calendar.DAY_OF_YEAR] -> {
                DateUtils.FORMAT_SHOW_DATE
            }

            else -> {
                DateUtils.FORMAT_SHOW_TIME
            }
        }
        return DateUtils.formatDateTime(fragment.requireContext(), timeMillis, flags)
    }

    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreFiles
                Glide.with(fragment)
                    .load(item.contentUri)
                    .centerCrop()
                    .into(binding.icon)
                binding.title.text = item.displayName
                binding.summary.text = formatDateTimeForItem(item.dateTaken) +
                        "\u0020\u0020\u0020\u0020" +
                        Formatter.formatFileSize(fragment.requireContext(), item.size)
                binding.card.setOnClickListener {
                    val viewIntent = Intent(Intent.ACTION_VIEW)
                        .setDataAndType(item.contentUri, item.mimeType)
                        .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                    with(fragment) {
                        try {
                            startActivity(Intent.createChooser(viewIntent, null))
                        } catch (e: ActivityNotFoundException) {
                            Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
                        }
                    }
                }

                holder.details = object : ItemDetails<Long>() {
                    override fun getPosition(): Int = holder.bindingAdapterPosition
                    override fun getSelectionKey(): Long = item.id
                    override fun inSelectionHotspot(e: MotionEvent): Boolean = false
                    override fun inDragRegion(e: MotionEvent): Boolean = true
                }
                if (selectionTrackerInitialized) {
                    binding.card.isChecked = selectionTracker.isSelected(item.id)
                }
            }

            else -> super.onBindViewHolder(holder, position)
        }
    }

    class ItemViewHolder(val binding: FilesItemBinding) : ViewHolder(binding.root)
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.files

import android.Manifest
import android.os.Build
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import me.zhanghai.android.fastscroll.PopupStyle

open class FilesFragment : MediaStoreFragment() {
    override val viewModel: FilesViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        FilesPermissionsRequesterFragment::class.java

    override fun onCreateAdapter(): FilesAdapter = FilesAdapter(this)

    override fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .setPopupStyle(PopupStyle.MD3)
            .setViewHelper(MediaStoreRecyclerViewHelper(list) { adapter.currentList })
            .build()
        list.fitsSystemWindowInsets(fastScroller)
    }

    class FilesPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(
                    Manifest.permission.READ_MEDIA_AUDIO,
                    Manifest.permission.READ_MEDIA_IMAGES,
                    Manifest.permission.READ_MEDIA_VIDEO
                )
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (selectionTracker.hasSelection()) {
            return
        }
        inflater.inflate(R.menu.files_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                return true
            }

            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as SearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }

            override fun onQueryTextChange(newText: String): Boolean {
                viewModel.queryText = newText
                return false
            }
        })

        when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH ->
                menu.findItem(R.id.menu_sort_by_path).isChecked = true

            SORT_BY_DATE_TAKEN ->
                menu.findItem(R.id.menu_sort_by_date_taken).isChecked = true

            SORT_BY_SIZE ->
                menu.findItem(R.id.menu_sort_by_size).isChecked = true
        }
        arrayOf(menu.findItem(R.id.menu_header_sort)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_path -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_PATH
            }

            R.id.menu_sort_by_date_taken -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_DATE_TAKEN
            }

            R.id.menu_sort_by_size -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_SIZE
            }

            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.files

import android.app.Application
import android.content.ContentUris
import android.net.Uri
import android.provider.MediaStore
import android.util.Log
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreViewModel
import me.gm.cleaner.plugin.util.fileNameComparator
import me.gm.cleaner.plugin.xposed.util.MimeUtils

open class FilesViewModel(application: Application) :
    MediaStoreViewModel<MediaStoreFiles>(application) {
    private val uri: Uri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL)

    protected val _isSearchingFlow: MutableStateFlow<Boolean> = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    protected val _queryTextFlow: MutableStateFlow<String> = MutableStateFlow("")
    var queryText: String by _queryTextFlow

    override suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<MediaStoreFiles> {
        uriToLoad = uri
        val files = mutableListOf<MediaStoreFiles>()

        withContext(Dispatchers.IO) {

            val projection = arrayOf(
                MediaStore.MediaColumns._ID,
                MediaStore.MediaColumns.DATA,
                MediaStore.MediaColumns.DISPLAY_NAME,
                MediaStore.MediaColumns.RELATIVE_PATH,
                MediaStore.MediaColumns.DATE_TAKEN,
                MediaStore.MediaColumns.MIME_TYPE,
                MediaStore.MediaColumns.SIZE,
            )

            val selection = "${MediaStore.MediaColumns.DATE_TAKEN} >= ?"

            val selectionArgs = arrayOf(
                dateToTimestamp(day = 1, month = 1, year = 1970).toString()
            )

            val sortOrder = when (sortMediaBy) {
                SORT_BY_PATH -> MediaStore.MediaColumns.RELATIVE_PATH + ", " +
                        MediaStore.MediaColumns.DISPLAY_NAME

                SORT_BY_DATE_TAKEN -> "${MediaStore.MediaColumns.DATE_TAKEN} DESC"
                SORT_BY_SIZE -> "${MediaStore.MediaColumns.SIZE} DESC"
                else -> throw IllegalArgumentException()
            }

            getApplication<Application>().contentResolver.query(
                uri,
                projection,
                null,
                null,
                sortOrder
            )?.use { cursor ->

                val idColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
                val displayNameColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME)
                val relativePathColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.RELATIVE_PATH)
                val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
                val dateTakenColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_TAKEN)
                val mimeTypeColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE)
                val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.SIZE)

                Log.i(TAG, "Found ${cursor.count} files")
                while (cursor.moveToNext()) {

                    val id = cursor.getLong(idColumn)
                    val displayName = cursor.getString(displayNameColumn)
                    val relativePath = cursor.getString(relativePathColumn)
                    val data = cursor.getString(dataColumn)
                    val dateTaken = cursor.getLong(dateTakenColumn)
                    val mimeType = cursor.getString(mimeTypeColumn)
                    val size = cursor.getLong(sizeColumn)
                    val contentUri = ContentUris.withAppendedId(
                        when (MimeUtils.resolveMediaType(mimeType)) {
                            MediaStore.Files.FileColumns.MEDIA_TYPE_AUDIO -> MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
                            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -> MediaStore.Video.Media.EXTERNAL_CONTENT_URI
                            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -> MediaStore.Images.Media.EXTERNAL_CONTENT_URI
                            // Unsupported type
                            else -> uri
                        },
                        id
                    )

                    if (isSearching) {
                        if (!data.contains(queryText, true)) {
                            continue
                        }
                    }
                    val file = MediaStoreFiles(
                        id, contentUri, displayName, relativePath, data, dateTaken, mimeType, size
                    )
                    files += file

                    Log.v(TAG, "Added file: $file")
                }
            }
        }

        if (sortMediaBy == SORT_BY_PATH) {
            files.sortWith(fileNameComparator { it.displayName })
            files.sortWith(fileNameComparator { it.relativePath })
        }

        Log.v(TAG, "Found ${files.size} files")
        return files
    }

    init {
        if (this.javaClass === FilesViewModel::class.java) {
            viewModelScope.launch {
                combine(
                    _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
                ) { isSearching, queryText, sortMediaBy ->
                    queryMedias(uri, sortMediaBy)
                }.collect {
                    _mediasFlow.value = it
                }
            }
            application.contentResolver.registerContentObserver(
                uri, true, contentObserver
            )
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/MediaStoreFiles.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.files

import android.net.Uri
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreModel

data class MediaStoreFiles(
    override val id: Long,
    override val contentUri: Uri,
    override val displayName: String,
    override val relativePath: String,
    override val data: String,
    override val dateTaken: Long,
    val mimeType: String?,
    val size: Long,
) : MediaStoreModel(id, contentUri, displayName, relativePath, data, dateTaken)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselAdapter.java
================================================
```
/*
 * Copyright 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager;

import android.view.LayoutInflater;
import android.view.ViewGroup;

import androidx.annotation.LayoutRes;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.DiffUtil;
import androidx.recyclerview.widget.ListAdapter;

import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;

/**
 * An adapter that displays {@link MediaStoreImage}s for a Carousel.
 */
class CarouselAdapter extends ListAdapter<MediaStoreImage, CarouselItemViewHolder> {

    private static final DiffUtil.ItemCallback<MediaStoreImage> DIFF_CALLBACK =
            new DiffUtil.ItemCallback<MediaStoreImage>() {
                @Override
                public boolean areItemsTheSame(
                        @NonNull MediaStoreImage oldItem, @NonNull MediaStoreImage newItem) {
                    // User properties may have changed if reloaded from the DB, but ID is fixed
                    return oldItem.getId() == newItem.getId();
                }

                @Override
                public boolean areContentsTheSame(
                        @NonNull MediaStoreImage oldItem, @NonNull MediaStoreImage newItem) {
                    return oldItem.equals(newItem);
                }
            };

    private final CarouselItemListener listener;
    @LayoutRes
    private final int itemLayoutRes;

    CarouselAdapter(CarouselItemListener listener) {
        this(listener, R.layout.cat_carousel_item);
    }

    CarouselAdapter(CarouselItemListener listener, @LayoutRes int itemLayoutRes) {
        super(DIFF_CALLBACK);
        this.listener = listener;
        this.itemLayoutRes = itemLayoutRes;
    }

    @NonNull
    @Override
    public CarouselItemViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int pos) {
        return new CarouselItemViewHolder(
                LayoutInflater.from(viewGroup.getContext())
                        .inflate(itemLayoutRes, viewGroup, false), listener);
    }

    @Override
    public void onBindViewHolder(@NonNull CarouselItemViewHolder carouselItemViewHolder, int pos) {
        carouselItemViewHolder.bind(getItem(pos));
    }

}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselItemListener.java
================================================
```
/*
 * Copyright 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager;

import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;

/**
 * An interface for items in a carousel.
 */
interface CarouselItemListener {
    void onItemClicked(MediaStoreImage item, int position);
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselItemViewHolder.java
================================================
```
/*
 * Copyright 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager;

import android.view.View;
import android.widget.ImageView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import com.bumptech.glide.Glide;

import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;

/**
 * An {@link RecyclerView.ViewHolder} that displays an item inside a Carousel.
 */
class CarouselItemViewHolder extends RecyclerView.ViewHolder {

  private final ImageView imageView;
  private final CarouselItemListener listener;

  CarouselItemViewHolder(@NonNull View itemView, CarouselItemListener listener) {
    super(itemView);
    imageView = itemView.findViewById(R.id.carousel_image_view);
    this.listener = listener;
  }

  void bind(MediaStoreImage item) {
    Glide.with(imageView.getContext()).load(item.getContentUri()).centerCrop().into(imageView);
    imageView.setContentDescription(item.getDisplayName());
    itemView.setOnClickListener(v -> listener.onItemClicked(item, getBindingAdapterPosition()));
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CustomChangeImageTransform.java
================================================
```
/*
 * Copyright (C) 2017 The Android Open Source Project
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.TypeEvaluator;
import android.content.Context;
import android.graphics.Matrix;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.transition.Transition;
import android.transition.TransitionListenerAdapter;
import android.transition.TransitionValues;
import android.util.AttributeSet;
import android.util.Property;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.github.chrisbanes.photoview.PhotoView;

import java.util.Map;

/**
 * This Transition captures an ImageView's matrix before and after the
 * scene change and animates it during the transition.
 *
 * <p>In combination with ChangeBounds, ChangeImageTransform allows ImageViews
 * that change size, shape, or {@link android.widget.ImageView.ScaleType} to animate contents
 * smoothly.</p>
 */
public class CustomChangeImageTransform extends Transition implements PhotoViewTransition {

    private static final String PROPNAME_MATRIX = "android:changeImageTransform:matrix";
    private static final String PROPNAME_BOUNDS = "android:changeImageTransform:bounds";

    private static final String[] sTransitionProperties = {
            PROPNAME_MATRIX,
            PROPNAME_BOUNDS,
    };

    private static final TypeEvaluator<Matrix> NULL_MATRIX_EVALUATOR = new TypeEvaluator<Matrix>() {
        @Override
        public Matrix evaluate(float fraction, Matrix startValue, Matrix endValue) {
            return null;
        }
    };

    private static final Property<ImageView, Matrix> ANIMATED_TRANSFORM_PROPERTY =
            new Property<ImageView, Matrix>(Matrix.class, "animatedTransform") {
                @Override
                public void set(ImageView view, Matrix matrix) {
                    view.animateTransform(matrix);
                }

                @Override
                public Matrix get(ImageView object) {
                    return null;
                }
            };

    public CustomChangeImageTransform() {
    }

    public CustomChangeImageTransform(@NonNull Context context, @NonNull AttributeSet attrs) {
        super(context, attrs);
    }

    private void captureValues(TransitionValues transitionValues) {
        View view = transitionValues.view;
        if (!(view instanceof ImageView) || view.getVisibility() != View.VISIBLE) {
            return;
        }
        ImageView imageView = (ImageView) view;
        Drawable drawable = imageView.getDrawable();
        if (drawable == null) {
            return;
        }
        Map<String, Object> values = transitionValues.values;

        int left = view.getLeft();
        int top = view.getTop();
        int right = view.getRight();
        int bottom = view.getBottom();

        Rect bounds = new Rect(left, top, right, bottom);
        values.put(PROPNAME_BOUNDS, bounds);
        if (PhotoViewTransition.isPhotoView(imageView)) {
            values.put(PROPNAME_MATRIX, copyImageMatrix(imageView));
        }
    }

    @Override
    public void captureStartValues(@NonNull TransitionValues transitionValues) {
        captureValues(transitionValues);
    }

    @Override
    public void captureEndValues(@NonNull TransitionValues transitionValues) {
        captureValues(transitionValues);
    }

    @Override
    @NonNull
    public String[] getTransitionProperties() {
        return sTransitionProperties;
    }

    private static Matrix calcCenterCropMatrix(@NonNull Rect bounds, @NonNull Drawable image) {
        final int imageWidth = image.getIntrinsicWidth();
        final int imageViewWidth = bounds.width();
        final float scaleX = ((float) imageViewWidth) / imageWidth;

        final int imageHeight = image.getIntrinsicHeight();
        final int imageViewHeight = bounds.height();
        final float scaleY = ((float) imageViewHeight) / imageHeight;

        final float maxScale = Math.max(scaleX, scaleY);

        final float width = imageWidth * maxScale;
        final float height = imageHeight * maxScale;
        final int tx = Math.round((imageViewWidth - width) / 2f);
        final int ty = Math.round((imageViewHeight - height) / 2f);

        final Matrix matrix = new Matrix();
        matrix.postScale(maxScale, maxScale);
        matrix.postTranslate(tx, ty);
        return matrix;
    }

    /**
     * Creates an Animator for ImageViews moving, changing dimensions, and/or changing
     * {@link android.widget.ImageView.ScaleType}.
     *
     * @param sceneRoot   The root of the transition hierarchy.
     * @param startValues The values for a specific target in the start scene.
     * @param endValues   The values for the target in the end scene.
     * @return An Animator to move an ImageView or null if the View is not an ImageView,
     * the Drawable changed, the View is not VISIBLE, or there was no change.
     */
    @Nullable
    @Override
    public Animator createAnimator(@NonNull ViewGroup sceneRoot,
                                   @Nullable TransitionValues startValues,
                                   final @Nullable TransitionValues endValues) {
        if (startValues == null || endValues == null) {
            return null;
        }
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        if (startBounds == null || endBounds == null) {
            return null;
        }

        final ImageView endView = (ImageView) endValues.view;
        final boolean isAnimViewPhotoView = PhotoViewTransition.isPhotoView(endView);
        final TransitionValues photoViewValues;
        if (isAnimViewPhotoView) {
            photoViewValues = endValues;
        } else {
            photoViewValues = startValues;
        }
        final PhotoView photoView = (PhotoView) photoViewValues.view;

        Matrix matrix = (Matrix) photoViewValues.values.get(PROPNAME_MATRIX);
        Matrix centerCropMatrix;
        if (isAnimViewPhotoView) {
            centerCropMatrix = calcCenterCropMatrix(startBounds, photoView.getDrawable());
        } else {
            centerCropMatrix = calcCenterCropMatrix(endBounds, photoView.getDrawable());
        }

        boolean matricesEqual = matrix != null && matrix.equals(centerCropMatrix);

        if (startBounds.equals(endBounds) && matricesEqual) {
            return null;
        }

        Drawable drawable = photoView.getDrawable();
        int drawableWidth = drawable.getIntrinsicWidth();
        int drawableHeight = drawable.getIntrinsicHeight();

        ObjectAnimator animator;
        if (drawableWidth <= 0 || drawableHeight <= 0) {
            animator = createNullAnimator(endView);
        } else {
            if (matrix == null) {
                matrix = IDENTITY_MATRIX;
            }
            if (centerCropMatrix == null) {
                centerCropMatrix = IDENTITY_MATRIX;
            }
            if (isAnimViewPhotoView) {
                ANIMATED_TRANSFORM_PROPERTY.set(endView, centerCropMatrix);
                animator = createMatrixAnimator(endView, centerCropMatrix, matrix);
            } else {
                ANIMATED_TRANSFORM_PROPERTY.set(endView, matrix);
                animator = createMatrixAnimator(endView, matrix, centerCropMatrix);
            }
            if (!isAnimViewPhotoView) {
                final MatrixAnimatorListener listener = new MatrixAnimatorListener(endView);
                animator.addListener(listener);
                addListener(new TransitionListenerAdapter() {
                    @Override
                    public void onTransitionEnd(Transition transition) {
                        listener.onAnimationEnd(animator);
                        transition.removeListener(this);
                    }
                });

                endView.setImageDrawable(photoView.getDrawable());
            }
        }

        return animator;
    }

    @NonNull
    private ObjectAnimator createNullAnimator(@NonNull ImageView imageView) {
        return ObjectAnimator.ofObject(imageView, ANIMATED_TRANSFORM_PROPERTY,
                NULL_MATRIX_EVALUATOR, IDENTITY_MATRIX, IDENTITY_MATRIX);
    }

    private ObjectAnimator createMatrixAnimator(final ImageView imageView, Matrix startMatrix,
                                                final Matrix endMatrix) {
        return ObjectAnimator.ofObject(imageView, ANIMATED_TRANSFORM_PROPERTY,
                new TransitionUtils_MatrixEvaluator(), startMatrix, endMatrix);
    }

    @NonNull
    private static Matrix copyImageMatrix(@NonNull ImageView view) {
        final Drawable image = view.getDrawable();
        if (image.getIntrinsicWidth() > 0 && image.getIntrinsicHeight() > 0) {
            switch (view.getScaleType()) {
                case FIT_XY:
                    return fitXYMatrix(view);
                case CENTER_CROP:
                    return centerCropMatrix(view);
                default:
                    return new Matrix(view.getImageMatrix());
            }
        }
        return new Matrix(view.getImageMatrix());
    }

    /**
     * Calculates the image transformation matrix for an ImageView with ScaleType FIT_XY. This
     * needs to be manually calculated as the platform does not give us the value for this case.
     */
    private static Matrix fitXYMatrix(ImageView view) {
        final Drawable image = view.getDrawable();
        final Matrix matrix = new Matrix();
        matrix.postScale(
                ((float) view.getWidth()) / image.getIntrinsicWidth(),
                ((float) view.getHeight()) / image.getIntrinsicHeight());
        return matrix;
    }

    /**
     * Calculates the image transformation matrix for an ImageView with ScaleType CENTER_CROP. This
     * needs to be manually calculated for consistent behavior across all the API levels.
     */
    private static Matrix centerCropMatrix(ImageView view) {
        final Drawable image = view.getDrawable();
        final int imageWidth = image.getIntrinsicWidth();
        final int imageViewWidth = view.getWidth();
        final float scaleX = ((float) imageViewWidth) / imageWidth;

        final int imageHeight = image.getIntrinsicHeight();
        final int imageViewHeight = view.getHeight();
        final float scaleY = ((float) imageViewHeight) / imageHeight;

        final float maxScale = Math.max(scaleX, scaleY);

        final float width = imageWidth * maxScale;
        final float height = imageHeight * maxScale;
        final int tx = Math.round((imageViewWidth - width) / 2f);
        final int ty = Math.round((imageViewHeight - height) / 2f);

        final Matrix matrix = new Matrix();
        matrix.postScale(maxScale, maxScale);
        matrix.postTranslate(tx, ty);
        return matrix;
    }

    static final Matrix IDENTITY_MATRIX = new Matrix() {

        void oops() {
            throw new IllegalStateException("Matrix can not be modified");
        }

        @Override
        public void set(Matrix src) {
            oops();
        }

        @Override
        public void reset() {
            oops();
        }

        @Override
        public void setTranslate(float dx, float dy) {
            oops();
        }

        @Override
        public void setScale(float sx, float sy, float px, float py) {
            oops();
        }

        @Override
        public void setScale(float sx, float sy) {
            oops();
        }

        @Override
        public void setRotate(float degrees, float px, float py) {
            oops();
        }

        @Override
        public void setRotate(float degrees) {
            oops();
        }

        @Override
        public void setSinCos(float sinValue, float cosValue, float px, float py) {
            oops();
        }

        @Override
        public void setSinCos(float sinValue, float cosValue) {
            oops();
        }

        @Override
        public void setSkew(float kx, float ky, float px, float py) {
            oops();
        }

        @Override
        public void setSkew(float kx, float ky) {
            oops();
        }

        @Override
        public boolean setConcat(Matrix a, Matrix b) {
            oops();
            return false;
        }

        @Override
        public boolean preTranslate(float dx, float dy) {
            oops();
            return false;
        }

        @Override
        public boolean preScale(float sx, float sy, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean preScale(float sx, float sy) {
            oops();
            return false;
        }

        @Override
        public boolean preRotate(float degrees, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean preRotate(float degrees) {
            oops();
            return false;
        }

        @Override
        public boolean preSkew(float kx, float ky, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean preSkew(float kx, float ky) {
            oops();
            return false;
        }

        @Override
        public boolean preConcat(Matrix other) {
            oops();
            return false;
        }

        @Override
        public boolean postTranslate(float dx, float dy) {
            oops();
            return false;
        }

        @Override
        public boolean postScale(float sx, float sy, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean postScale(float sx, float sy) {
            oops();
            return false;
        }

        @Override
        public boolean postRotate(float degrees, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean postRotate(float degrees) {
            oops();
            return false;
        }

        @Override
        public boolean postSkew(float kx, float ky, float px, float py) {
            oops();
            return false;
        }

        @Override
        public boolean postSkew(float kx, float ky) {
            oops();
            return false;
        }

        @Override
        public boolean postConcat(Matrix other) {
            oops();
            return false;
        }

        @Override
        public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf) {
            oops();
            return false;
        }

        @Override
        public boolean setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex,
                                     int pointCount) {
            oops();
            return false;
        }

        @Override
        public void setValues(float[] values) {
            oops();
        }

    };

    static class TransitionUtils_MatrixEvaluator implements TypeEvaluator<Matrix> {

        final float[] mTempStartValues = new float[9];

        final float[] mTempEndValues = new float[9];

        final Matrix mTempMatrix = new Matrix();

        @Override
        public Matrix evaluate(float fraction, Matrix startValue, Matrix endValue) {
            startValue.getValues(mTempStartValues);
            endValue.getValues(mTempEndValues);
            for (int i = 0; i < 9; i++) {
                float diff = mTempEndValues[i] - mTempStartValues[i];
                mTempEndValues[i] = mTempStartValues[i] + (fraction * diff);
            }
            mTempMatrix.setValues(mTempEndValues);
            return mTempMatrix;
        }

    }

    private static class MatrixAnimatorListener extends AnimatorListenerAdapter {
        private final ImageView mView;
        private final Drawable mBackup;
        private boolean mLayerTypeChanged = false;

        public MatrixAnimatorListener(ImageView view) {
            mView = view;
            mBackup = view.getDrawable();
        }

        @Override
        public void onAnimationStart(Animator animator) {
            if (mView.hasOverlappingRendering() && mView.getLayerType() == View.LAYER_TYPE_NONE) {
                mLayerTypeChanged = true;
                mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
            }
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            mView.setImageDrawable(mBackup);
            if (mLayerTypeChanged) {
                mView.setLayerType(View.LAYER_TYPE_NONE, null);
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager

import android.app.Activity
import android.content.ActivityNotFoundException
import android.content.Intent
import android.content.pm.ActivityInfo
import android.content.res.Configuration
import android.net.Uri
import android.os.Bundle
import android.transition.TransitionInflater
import android.transition.TransitionSet
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.Toast
import androidx.core.app.SharedElementCallback
import androidx.core.math.MathUtils.clamp
import androidx.core.os.bundleOf
import androidx.core.transition.doOnEnd
import androidx.core.transition.doOnStart
import androidx.core.view.get
import androidx.core.view.isVisible
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.activityViewModels
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager2.adapter.FragmentStateAdapter
import androidx.viewpager2.widget.ViewPager2
import com.github.chrisbanes.photoview.PhotoView
import com.google.android.material.carousel.CarouselLayoutManager
import com.google.android.material.carousel.CarouselSnapHelper
import com.google.android.material.carousel.CustomHeroCarouselStrategy
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ImagePagerFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ui.mediastore.images.ImagesViewModel
import me.gm.cleaner.plugin.util.MediaStoreCompat
import me.gm.cleaner.plugin.util.MediaStoreCompat.DELETE_PERMISSION_REQUEST

/**
 * A fragment for displaying a series of images in a [ViewPager2].
 *
 * This is implemented with [androidx.navigation.Navigation] and has 4 [androidx.navigation.NavArgs].
 * See nav_graph.xml for more details.
 */
class ImagePagerFragment : BaseFragment() {
    private val viewModel: ImagePagerViewModel by viewModels()
    private val imagesViewModel: ImagesViewModel by activityViewModels()
    private val args: ImagePagerFragmentArgs by navArgs()
    private val lastPosition by lazy { bundleOf(KEY_POSITION to args.initialPosition) }
    private lateinit var viewPager: ViewPager2
    private lateinit var bottomBar: LinearLayout

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = ImagePagerFragmentBinding.inflate(inflater)

        viewModel.isOverlayingLiveData.observe(viewLifecycleOwner) { isOverlaying ->
            appBarLayout?.post {
                appBarLayout?.isLifted = isOverlaying
            }
        }

        bottomBar = binding.bottomBar
        binding.bottomActionBar.setOnMenuItemClickListener(::onOptionsItemSelected)
        val carouselRecyclerView = binding.carouselRecyclerView

        viewPager = binding.viewPager
        if (args.uri == null) {
            bindForMediaStoreImages(savedInstanceState, carouselRecyclerView)
        } else {
            bindForContentProviderImage(carouselRecyclerView)
        }

        findNavController().addOnExitListener { _, destination, _ ->
            restoreAppBar(destination)
            appBarLayout?.setLiftableOverrideEnabled(false)
            requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
                .setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED)
        }

        prepareSharedElementTransition()
        // Avoid a postponeEnterTransition on orientation change, and postpone only of first creation.
        if (savedInstanceState == null && args.uri == null) {
            postponeEnterTransition()
        }
        return binding.root
    }

    private fun bindForMediaStoreImages(
        savedInstanceState: Bundle?, carouselRecyclerView: RecyclerView
    ) {
        val adapter = CarouselAdapter { _, position ->
            viewPager.setCurrentItem(position, true)
        }
        carouselRecyclerView.adapter = adapter
        carouselRecyclerView.layoutManager =
            CarouselLayoutManager(CustomHeroCarouselStrategy()).apply {
                carouselAlignment = CarouselLayoutManager.ALIGNMENT_CENTER
            }
        carouselRecyclerView.isNestedScrollingEnabled = false
        val enableFlingSnapHelper = CarouselSnapHelper(false)
        enableFlingSnapHelper.attachToRecyclerView(carouselRecyclerView)

        viewPager.adapter = object : FragmentStateAdapter(this) {
            val initialItemId: Long = if (savedInstanceState == null) {
                imagesViewModel.medias[args.initialPosition].id
            } else {
                0
            }

            override fun createFragment(position: Int): ImagePagerItem {
                val media = imagesViewModel.medias[position]
                return ImagePagerItem.newInstance(
                    media.contentUri, savedInstanceState == null && initialItemId == media.id
                )
            }

            override fun getItemCount(): Int = imagesViewModel.medias.size

            // Override to support collections that remove items.
            override fun getItemId(position: Int): Long = imagesViewModel.medias[position].id

            override fun containsItem(itemId: Long): Boolean =
                imagesViewModel.medias.any { itemId == it.id }
        }
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                lastPosition.putInt(KEY_POSITION, position)
                viewModel.currentItemId = imagesViewModel.medias[position].id
                updateTitle(position)
                if (carouselRecyclerView.scrollState != RecyclerView.SCROLL_STATE_DRAGGING) {
                    carouselRecyclerView.smoothScrollToPosition(position)
                }
            }
        })

        carouselRecyclerView.addOnScrollListener(
            object : RecyclerView.OnScrollListener() {
                private var dragged: Boolean = false

                private fun scrollToSnapView(recyclerView: RecyclerView) {
                    val snapView = enableFlingSnapHelper.findSnapView(recyclerView.layoutManager)
                        ?: return
                    val position = recyclerView.getChildAdapterPosition(snapView)
                    viewPager.setCurrentItem(position, true)
                }

                override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                    if (newState == RecyclerView.SCROLL_STATE_DRAGGING) {
                        dragged = true
                    } else if (dragged && newState == RecyclerView.SCROLL_STATE_IDLE) {
                        scrollToSnapView(recyclerView)
                        dragged = false
                    }
                }

                override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                    if (recyclerView.scrollState != RecyclerView.SCROLL_STATE_DRAGGING ||
                        viewPager.scrollState != ViewPager2.SCROLL_STATE_IDLE
                    ) {
                        return
                    }
                    scrollToSnapView(recyclerView)
                }
            }
        )

        lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                imagesViewModel.mediasFlow.collect { medias ->
                    if (medias.isEmpty()) {
                        findNavController().navigateUp()
                    } else {
                        var position = medias.indexOfFirst { viewModel.currentItemId == it.id }
                        if (position == -1) {
                            viewPager.adapter!!.notifyItemRemoved(viewPager.currentItem)
                            position = clamp(viewPager.currentItem, 0, medias.size - 1)
                        } else {
                            viewPager.setCurrentItem(position, false)
                        }
                        updateTitle(position)
                        adapter.submitList(medias) {
                            carouselRecyclerView.scrollToPosition(position)
                        }
                    }
                }
            }
        }
        // Set the current position and add a listener that will update the selection coordinator when
        // paging the images.
        if (savedInstanceState == null) {
            val position = args.initialPosition
            viewPager.setCurrentItem(position, false)
            viewModel.currentItemId = imagesViewModel.medias[position].id
        }
    }

    private fun bindForContentProviderImage(carouselRecyclerView: RecyclerView) {
        carouselRecyclerView.isVisible = false

        viewPager.adapter = object : FragmentStateAdapter(this) {

            override fun createFragment(position: Int): ImagePagerItem =
                ImagePagerItem.newInstance(args.uri!!, true)

            override fun getItemCount(): Int = 1
        }

        updateTitle(0)
    }

    private fun updateTitle(position: Int) {
        supportActionBar?.apply {
            if (args.uri == null) {
                title = imagesViewModel.medias[position].displayName
                subtitle = "${position + 1} / ${imagesViewModel.medias.size}"
            } else {
                lifecycleScope.launch {
                    val result = viewModel
                        .queryImageTitleAsync(args.uri!!)
                        .await()
                    title = result.getOrNull()
                }
            }
        }
    }

    private fun findPhotoViewForAdapterPosition(position: Int): PhotoView? =
        (viewPager[0] as RecyclerView)
            .findViewHolderForAdapterPosition(position)
            ?.itemView
            ?.findViewById(R.id.photo_view)

    private fun prepareSharedElementTransition() {
        setFragmentResult(ImagePagerFragment::class.java.name, lastPosition)

        sharedElementEnterTransition = (TransitionInflater.from(requireContext())
            .inflateTransition(R.transition.grid_pager_transition) as TransitionSet)
            .addTransition(CustomChangeImageTransform())
            .apply {
                doOnStart {
                    viewPager.isUserInputEnabled = false
                }
                doOnEnd {
                    viewPager.isUserInputEnabled = true
                }
            }

        enterTransition = TransitionInflater.from(requireContext())
            .inflateTransition(R.transition.pager_enter_transition)

        // A similar mapping is set at the GridFragment with a setExitSharedElementCallback.
        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                // Locate the image view at the primary fragment (the ImageFragment that is currently
                // visible). To locate the fragment, call instantiateItem with the selection position.
                // At this stage, the method will simply return the fragment at the position and will
                // not create a new one.
                val photoView = findPhotoViewForAdapterPosition(viewPager.currentItem) ?: return
                if (names.isNotEmpty()) {
                    // Map the first shared element name to the child ImageView.
                    sharedElements[names[0]] = photoView
                }
            }
        })
    }

    private fun getCurrentImageUri(): Uri = if (args.uri == null) {
        imagesViewModel.medias[viewPager.currentItem].contentUri
    } else {
        args.uri!!
    }

    private fun deleteCurrentImage() {
        lifecycleScope.launch {
            try {
                val isSuccessfullyDeleted =
                    MediaStoreCompat.delete(this@ImagePagerFragment, getCurrentImageUri())
                if (isSuccessfullyDeleted && args.uri != null) {
                    activity?.finish()
                }
            } catch (e: Throwable) {
                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
            }
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == DELETE_PERMISSION_REQUEST) {
            deleteCurrentImage()
        }
    }

    override fun toggleAppBar(show: Boolean) {
        super.toggleAppBar(show)
        bottomBar.isVisible = show
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.image_pager_toolbar, menu)
    }

    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
        R.id.menu_screen_rotation -> {
            requireActivity().requestedOrientation = when (resources.configuration.orientation) {
                Configuration.ORIENTATION_PORTRAIT -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                Configuration.ORIENTATION_LANDSCAPE -> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                else -> throw IllegalArgumentException()
            }
            true
        }

        R.id.menu_info -> {
            lifecycleScope.launch {
                val result = viewModel
                    .queryImageInfoAsync(getCurrentImageUri())
                    .await()
                TextSelectableInfoDialog
                    .newInstance(result.getOrElse { it.stackTraceToString() })
                    .show(childFragmentManager, null)
            }
            true
        }

        R.id.menu_share -> {
            val sendIntent = Intent(Intent.ACTION_SEND)
                .setType("image/*")
                .putExtra(Intent.EXTRA_STREAM, getCurrentImageUri())
            val shareIntent = Intent.createChooser(sendIntent, null)
            try {
                startActivity(shareIntent)
            } catch (e: ActivityNotFoundException) {
                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
            }
            true
        }

        R.id.menu_delete -> {
            deleteCurrentImage()
            true
        }

        else -> super.onOptionsItemSelected(item)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putCharSequence(SAVED_TITLE, supportActionBar?.title)
        outState.putCharSequence(SAVED_SUBTITLE, supportActionBar?.subtitle)
        outState.putBoolean(SAVED_SHOWS_APPBAR, supportActionBar?.isShowing ?: true)
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        appBarLayout?.setLiftableOverrideEnabled(true)
        savedInstanceState?.run {
            supportActionBar?.apply {
                title = getCharSequence(SAVED_TITLE)
                subtitle = getCharSequence(SAVED_SUBTITLE)
            }
            toggleAppBar(getBoolean(SAVED_SHOWS_APPBAR))
        }
        requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
            .setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)
    }

    companion object {
        const val KEY_POSITION = "me.gm.cleaner.plugin.key.position"
        private const val SAVED_TITLE = "android:title"
        private const val SAVED_SUBTITLE = "android:subtitle"
        private const val SAVED_SHOWS_APPBAR = "android:showsAppBar"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerItem.kt
================================================
```
/*
* Copyright 2018 Google LLC
* Copyright 2021 Green Mushroom
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     https://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package me.gm.cleaner.plugin.ui.mediastore.imagepager

import android.graphics.Matrix
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Bundle
import android.transition.TransitionSet
import android.view.GestureDetector
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.core.graphics.values
import androidx.core.os.BundleCompat
import androidx.core.os.bundleOf
import androidx.core.transition.doOnEnd
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.target.Target
import com.github.chrisbanes.photoview.PhotoView
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ImagePagerItemBinding
import kotlin.math.max

/**
 * A fragment for displaying an image.
 */
class ImagePagerItem : BaseFragment() {
    private val viewModel: ImagePagerViewModel by viewModels({ requireParentFragment() })
    private val uri: Uri by lazy {
        BundleCompat.getParcelable(requireArguments(), KEY_IMAGE_URI, Uri::class.java)!!
    }
    private val parentFragment: ImagePagerFragment by lazy {
        requireParentFragment() as ImagePagerFragment
    }
    private lateinit var photoView: PhotoView

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = ImagePagerItemBinding.inflate(inflater)

        photoView = binding.photoView
        // Just like we do when binding views at the grid, we set the transition name to be the string
        // value of the image res.
        photoView.transitionName = uri.toString()
        photoView.setOnScaleChangeListener { _, _, _ ->
            parentFragment.toggleAppBar(false)
            viewModel.isOverlaying(photoView.displayRect)
        }
        photoView.setOnDoubleTapListener(object : GestureDetector.SimpleOnGestureListener() {

            override fun onSingleTapConfirmed(e: MotionEvent): Boolean {
                parentFragment.toggleAppBar(supportActionBar?.isShowing == false)
                viewModel.isOverlaying(photoView.displayRect)
                return true
            }

            override fun onDoubleTap(e: MotionEvent): Boolean {
                try {
                    val scale = photoView.scale
                    val x = e.x
                    val y = e.y
                    if (scale < photoView.mediumScale) {
                        photoView.setScale(photoView.mediumScale, x, y, true)
                    } else {
                        photoView.setScale(photoView.minimumScale, x, y, true)
                    }
                } catch (e: ArrayIndexOutOfBoundsException) {
                    // Can sometimes happen when getX() and getY() is called
                }
                return true
            }
        })
        Glide.with(this)
            .load(uri)
            .listener(object : RequestListener<Drawable?> {
                override fun onLoadFailed(
                    e: GlideException?, model: Any?, target: Target<Drawable?>,
                    isFirstResource: Boolean
                ): Boolean {
                    Toast
                        .makeText(requireContext(), e?.message.toString(), Toast.LENGTH_SHORT)
                        .show()

                    parentFragment.startPostponedEnterTransition()
                    return false
                }

                override fun onResourceReady(
                    resource: Drawable, model: Any, target: Target<Drawable?>,
                    dataSource: DataSource, isFirstResource: Boolean
                ): Boolean {
                    photoView.post {
                        val displayRect = photoView.displayRect
                        var midScale = max(
                            photoView.width / displayRect.width(),
                            photoView.height / displayRect.height()
                        )
                        if (midScale == 1F) {
                            midScale = 3F
                        }
                        val maxScale = max(3 * midScale, 9F)
                        photoView.setScaleLevels(1F, midScale, maxScale)

                        if (savedInstanceState != null) {
                            val matrix = Matrix()
                            matrix.setValues(savedInstanceState.getFloatArray(KEY_MATRIX))
                            photoView.setSuppMatrix(matrix)
                        }

                        parentFragment.startPostponedEnterTransition()
                    }

                    if (resource is BitmapDrawable) {
                        val initialEntry = requireArguments().getBoolean(KEY_INITIAL_ENTRY)
                        if (savedInstanceState == null && initialEntry &&
                            findNavController().previousBackStackEntry?.destination?.id == R.id.images_fragment
                        ) {
                            (parentFragment.sharedElementEnterTransition as TransitionSet).doOnEnd {
                                setupTilesProvider()
                            }
                        } else {
                            setupTilesProvider()
                        }
                    }
                    return false
                }
            })
            .into(photoView)
        return binding.root
    }

    private fun setupTilesProvider() {
        lifecycleScope.launch(Dispatchers.IO) {
            // runCatching is needed because the loaded resource may be from Glide cache.
            runCatching {
                requireContext().contentResolver.openFileDescriptor(uri, "r").use { pfd ->
                    photoView.setupTilesProvider(pfd)
                }
            }
        }
    }

    override fun onResume() {
        super.onResume()
        viewModel.isOverlaying(photoView.displayRect)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        if (::photoView.isInitialized) {
            val matrix = Matrix()
            photoView.getSuppMatrix(matrix)
            outState.putFloatArray(KEY_MATRIX, matrix.values())
        }
    }

    companion object {
        private const val KEY_IMAGE_URI: String = "me.gm.cleaner.plugin.key.imageUri"
        private const val KEY_INITIAL_ENTRY: String = "me.gm.cleaner.plugin.key.initialEntry"
        private const val KEY_MATRIX: String = "me.gm.cleaner.plugin.key.matrix"
        fun newInstance(uri: Uri, initialEntry: Boolean): ImagePagerItem = ImagePagerItem().apply {
            arguments = bundleOf(
                KEY_IMAGE_URI to uri,
                KEY_INITIAL_ENTRY to initialEntry
            )
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager

import android.app.Application
import android.graphics.RectF
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import android.text.format.DateUtils
import android.text.format.Formatter
import androidx.core.os.bundleOf
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.R
import java.io.FileNotFoundException

class ImagePagerViewModel(application: Application, state: SavedStateHandle) :
    AndroidViewModel(application) {

    init {
        state.setSavedStateProvider(::currentItemId.name) {
            bundleOf(::currentItemId.name to currentItemId)
        }
    }

    private val _isOverlayingLiveData: MutableLiveData<Boolean> = MutableLiveData(false)
    val isOverlayingLiveData: LiveData<Boolean>
        get() = _isOverlayingLiveData
    private val top: Int by lazy {
        val res = getApplication<Application>().resources
        val actionBarSize =
            res.getDimensionPixelSize(com.google.android.material.R.dimen.m3_appbar_size_compact)
        val resourceId = res.getIdentifier("status_bar_height", "dimen", "android")
        res.getDimensionPixelSize(resourceId) + actionBarSize
    }

    var currentItemId: Long = state.get<Bundle>(::currentItemId.name).let { bundle ->
        bundle?.getLong(::currentItemId.name) ?: 0L
    }

    fun isOverlaying(displayRect: RectF?): Boolean {
        displayRect ?: return false
        val isOverlaying = displayRect.top < top
        _isOverlayingLiveData.postValue(isOverlaying)
        return isOverlaying
    }

    fun queryImageInfoAsync(uri: Uri) = viewModelScope.async {
        queryImageInfo(uri)
    }

    private suspend fun queryImageInfo(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(
            MediaStore.Images.Media.DATA,
            MediaStore.Images.Media.DATE_TAKEN,
            MediaStore.Images.Media.SIZE,
            MediaStore.Images.Media.WIDTH,
            MediaStore.Images.Media.HEIGHT,
        )

        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->

            val dataColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATA)
            val dateTakenColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)
            val sizeColumn = cursor.getColumnIndex(MediaStore.Images.Media.SIZE)
            val widthColumn = cursor.getColumnIndex(MediaStore.Images.Media.WIDTH)
            val heightColumn = cursor.getColumnIndex(MediaStore.Images.Media.HEIGHT)

            if (cursor.moveToNext()) {
                val nameStrIdToValue = mutableListOf<Pair<Int, String>>()
                if (dataColumn != -1) {
                    val data = cursor.getString(dataColumn)
                    nameStrIdToValue += R.string.menu_sort_by_path_title to data
                }
                if (dateTakenColumn != -1) {
                    val dateTaken = cursor.getLong(dateTakenColumn)
                    nameStrIdToValue += R.string.menu_sort_by_date_taken_title to
                            DateUtils.formatDateTime(
                                context, dateTaken,
                                DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                                        DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_YEAR or
                                        DateUtils.FORMAT_SHOW_DATE or DateUtils.FORMAT_SHOW_TIME
                            )
                }
                if (sizeColumn != -1) {
                    val size = cursor.getLong(sizeColumn)
                    nameStrIdToValue += R.string.menu_sort_by_size_title to
                            Formatter.formatFileSize(context, size)
                }
                if (widthColumn != -1 && heightColumn != -1) {
                    val width = cursor.getLong(widthColumn)
                    val height = cursor.getLong(heightColumn)
                    val resolution = "$width x $height"
                    nameStrIdToValue += R.string.resolution to resolution
                }

                val info = nameStrIdToValue.map { (nameStrId, value) ->
                    context.getString(
                        R.string.info_item, context.getString(nameStrId), value
                    )
                }
                return@withContext Result.success(info.joinToString("\n"))
            }
        }
        Result.failure(FileNotFoundException())
    }

    fun queryImageTitleAsync(uri: Uri) = viewModelScope.async {
        queryImageTitle(uri)
    }

    private suspend fun queryImageTitle(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(MediaStore.Images.Media.DISPLAY_NAME)
        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->

            val displayNameColumn =
                cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)

            if (cursor.moveToNext()) {
                val displayName = cursor.getString(displayNameColumn)

                return@withContext Result.success(displayName)
            }
        }
        Result.failure(FileNotFoundException())
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/PhotoViewTransition.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager;

import android.view.View;

import androidx.annotation.NonNull;

import com.github.chrisbanes.photoview.PhotoView;

public interface PhotoViewTransition {

    static boolean isPhotoView(@NonNull View view) {
        return view instanceof PhotoView;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/TextSelectableInfoDialog.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.imagepager

import android.os.Bundle
import android.view.View
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import com.google.android.material.dialog.MaterialAlertDialogBuilder

class TextSelectableInfoDialog : AppCompatDialogFragment() {

    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getString(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok, null)
            .create().apply {
                setOnShowListener {
                    window?.findViewById<TextView>(android.R.id.message)?.apply {
                        textAlignment = View.TEXT_ALIGNMENT_VIEW_START
                        setTextIsSelectable(true)
                    }
                }
            }

    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"
        fun newInstance(message: String): TextSelectableInfoDialog =
            TextSelectableInfoDialog().apply { arguments = bundleOf(KEY_MESSAGE to message) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.images

import android.graphics.drawable.Drawable
import android.transition.TransitionInflater
import android.transition.TransitionSet
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewGroup
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.target.Target
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.ImagesItemBinding
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter

class ImagesAdapter(private val fragment: ImagesFragment) : MediaStoreAdapter(fragment) {

    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreImage -> R.layout.images_item
        else -> super.getItemViewType(position)
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.images_item -> ItemViewHolder(
                ImagesItemBinding.inflate(LayoutInflater.from(parent.context))
            )

            else -> super.onCreateViewHolder(parent, viewType)
        }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position)
                // Load the image with Glide to prevent OOM error when the image drawables are very large.
                Glide.with(fragment)
                    .load(item.contentUri)
                    .listener(object : RequestListener<Drawable?> {
                        override fun onLoadFailed(
                            e: GlideException?, model: Any?, target: Target<Drawable?>,
                            isFirstResource: Boolean
                        ): Boolean {
                            if (fragment.lastPosition == getUriPositionForAdapterPosition(holder.bindingAdapterPosition)) {
                                fragment.startPostponedEnterTransition()
                            }
                            return false
                        }

                        override fun onResourceReady(
                            resource: Drawable, model: Any, target: Target<Drawable?>,
                            dataSource: DataSource, isFirstResource: Boolean
                        ): Boolean {
                            if (fragment.lastPosition == getUriPositionForAdapterPosition(holder.bindingAdapterPosition)) {
                                fragment.startPostponedEnterTransition()
                            }
                            return false
                        }
                    })
                    .centerCrop()
                    .into(binding.image)
                binding.image.transitionName = item.contentUri.toString()
                binding.card.setOnClickListener {
                    val uriPosition = getUriPositionForAdapterPosition(
                        holder.bindingAdapterPosition
                    )
                    fragment.lastPosition = uriPosition

                    val exitTransition = TransitionInflater.from(fragment.requireContext())
                        .inflateTransition(R.transition.grid_exit_transition)
                    // Exclude the clicked card from the exit transition (e.g. the card will disappear immediately
                    // instead of fading out with the rest to prevent an overlapping animation of fade and move).
                    (exitTransition as TransitionSet).excludeTarget(binding.card, true)
                    fragment.exitTransition = exitTransition

                    val direction = ImagesFragmentDirections.actionImagesToImagePager(
                        initialPosition = uriPosition,
                        uri = null
                    )
                    val extras = FragmentNavigatorExtras(
                        binding.image to binding.image.transitionName
                    )
                    fragment.findNavController().navigate(direction, extras)
                }

                holder.details = object : ItemDetails<Long>() {
                    override fun getPosition(): Int = holder.bindingAdapterPosition
                    override fun getSelectionKey(): Long = item.id
                    override fun inSelectionHotspot(e: MotionEvent): Boolean = false
                    override fun inDragRegion(e: MotionEvent): Boolean = true
                }
                if (selectionTrackerInitialized) {
                    binding.card.isChecked = selectionTracker.isSelected(item.id)
                }
            }

            else -> super.onBindViewHolder(holder, position)
        }
    }

    class ItemViewHolder(val binding: ImagesItemBinding) : ViewHolder(binding.root)
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.images

import android.Manifest
import android.os.Build
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.widget.ImageView
import androidx.core.app.SharedElementCallback
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.activityViewModels
import androidx.fragment.app.setFragmentResultListener
import androidx.recyclerview.widget.GridLayoutManager.SpanSizeLookup
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreHeader
import me.gm.cleaner.plugin.ui.mediastore.imagepager.ImagePagerFragment
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import me.zhanghai.android.fastscroll.PopupStyle

class ImagesFragment : MediaStoreFragment() {
    override val viewModel: ImagesViewModel by activityViewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        ImagesPermissionsRequesterFragment::class.java
    var lastPosition: Int = 0

    override fun onCreateAdapter(): MediaStoreAdapter = ImagesAdapter(this)

    override fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
        val layoutManager =
            ProgressionGridLayoutManager(
                requireContext(),
                RootPreferences.spanCountFlowable.value
            ).apply {
                spanSizeLookup = object : SpanSizeLookup() {
                    override fun getSpanSize(position: Int): Int =
                        if (adapter.currentList[position] is MediaStoreHeader) {
                            spanCount
                        } else {
                            1
                        }
                }
            }
        list.layoutManager = layoutManager
        val viewHelper = MediaStoreRecyclerViewHelper(list) { adapter.currentList }
        // Build FastScroller after SelectionTracker so that we can intercept SelectionTracker's OnItemTouchListener.
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .setPopupStyle(PopupStyle.MD3)
            .setViewHelper(viewHelper)
            .build()
        list.fitsSystemWindowInsets(fastScroller)
        list.addOnItemTouchListener(
            ScaleGestureListener(requireContext(), layoutManager, viewHelper)
        )

        prepareTransitions(list, adapter)
        setFragmentResultListener(ImagePagerFragment::class.java.name) { _, bundle ->
            lastPosition = bundle.getInt(ImagePagerFragment.KEY_POSITION)
            postponeEnterTransition()
            list.post {
                val lastUriPosition = adapter.getHolderPositionForUriPosition(lastPosition)
                if (lastUriPosition != null) {
                    scrollToPosition(list, lastUriPosition)
                } else {
                    startPostponedEnterTransition()
                }
            }
        }
    }

    /**
     * Prepares the shared element transition to the pager fragment, as well as the other transitions
     * that affect the flow.
     */
    private fun prepareTransitions(list: RecyclerView, adapter: MediaStoreAdapter) {
        // A similar mapping is set at the ImagePagerFragment with a setEnterSharedElementCallback.
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                // Locate the ViewHolder for the clicked position.
                val lastUriPosition = adapter.getHolderPositionForUriPosition(lastPosition)
                    ?: return
                val selectedViewHolder = list.findViewHolderForAdapterPosition(lastUriPosition)
                    ?: return

                // Map the first shared element name to the child ImageView.
                val image = selectedViewHolder.itemView.findViewById<ImageView>(R.id.image)
                    ?: return
                sharedElements[names[0]] = image
            }
        })
    }

    /**
     * Scrolls the recycler view to show the last viewed item in the grid. This is important when
     * navigating back from the grid.
     */
    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            // Scroll to position if the view for the current position is null (not currently part of
            // layout manager children), or it's not completely visible.
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }

    class ImagesPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_IMAGES)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (selectionTracker.hasSelection()) {
            return
        }
        inflater.inflate(R.menu.images_toolbar, menu)

        when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH ->
                menu.findItem(R.id.menu_sort_by_path).isChecked = true

            SORT_BY_DATE_TAKEN, SORT_BY_SIZE ->
                menu.findItem(R.id.menu_sort_by_date_taken).isChecked = true
        }
        arrayOf(menu.findItem(R.id.menu_header_sort)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_path -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_PATH
            }

            R.id.menu_sort_by_date_taken -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_DATE_TAKEN
            }

            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesViewModel.kt
================================================
```
/*
 * Copyright (C) 2019 The Android Open Source Project
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://github.com/android/storage-samples/blob/master/MediaStore/app/src/main/java/com/android/samples/mediastore/MainActivityViewModel.kt

package me.gm.cleaner.plugin.ui.mediastore.images

import android.app.Application
import android.content.ContentProvider
import android.content.ContentResolver
import android.content.ContentUris
import android.database.Cursor
import android.net.Uri
import android.provider.MediaStore
import android.util.Log
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreViewModel
import me.gm.cleaner.plugin.util.fileNameComparator

class ImagesViewModel(application: Application) :
    MediaStoreViewModel<MediaStoreImage>(application) {
    private val uri: Uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI

    override suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<MediaStoreImage> {
        uriToLoad = uri
        val images = mutableListOf<MediaStoreImage>()

        /**
         * Working with [ContentResolver]s can be slow, so we'll do this off the main
         * thread inside a coroutine.
         */
        withContext(Dispatchers.IO) {

            /**
             * A key concept when working with Android [ContentProvider]s is something called
             * "projections". A projection is the list of columns to request from the provider,
             * and can be thought of (quite accurately) as the "SELECT ..." clause of a SQL
             * statement.
             *
             * It's not _required_ to provide a projection. In this case, one could pass `null`
             * in place of `projection` in the call to [ContentResolver.query], but requesting
             * more data than is required has a performance impact.
             *
             * For this sample, we only use a few columns of data, and so we'll request just a
             * subset of columns.
             */
            val projection = arrayOf(
                MediaStore.MediaColumns._ID,
                MediaStore.MediaColumns.DISPLAY_NAME,
                MediaStore.MediaColumns.RELATIVE_PATH,
                MediaStore.MediaColumns.DATA,
                MediaStore.MediaColumns.DATE_TAKEN,
            )

            /**
             * The `selection` is the "WHERE ..." clause of a SQL statement. It's also possible
             * to omit this by passing `null` in its place, and then all rows will be returned.
             * In this case we're using a selection based on the date the image was taken.
             *
             * Note that we've included a `?` in our selection. This stands in for a variable
             * which will be provided by the next variable.
             */
            val selection = "${MediaStore.MediaColumns.DATE_TAKEN} >= ?"

            /**
             * The `selectionArgs` is a list of values that will be filled in for each `?`
             * in the `selection`.
             */
            val selectionArgs = arrayOf(
                dateToTimestamp(day = 1, month = 1, year = 1970).toString()
            )

            /**
             * Sort order to use. This can also be null, which will use the default sort
             * order. For [MediaStore.Images], the default sort order is ascending by date taken.
             */
            val sortOrder = when (sortMediaBy) {
                SORT_BY_PATH -> MediaStore.MediaColumns.RELATIVE_PATH + ", " +
                        MediaStore.MediaColumns.DISPLAY_NAME

                SORT_BY_DATE_TAKEN, SORT_BY_SIZE -> "${MediaStore.MediaColumns.DATE_TAKEN} DESC"
                else -> throw IllegalArgumentException()
            }

            getApplication<Application>().contentResolver.query(
                uri,
                projection,
                null,
                null,
                sortOrder
            )?.use { cursor ->

                /**
                 * In order to retrieve the data from the [Cursor] that's returned, we need to
                 * find which index matches each column that we're interested in.
                 *
                 * There are two ways to do this. The first is to use the method
                 * [Cursor.getColumnIndex] which returns -1 if the column ID isn't found. This
                 * is useful if the code is programmatically choosing which columns to request,
                 * but would like to use a single method to parse them into objects.
                 *
                 * In our case, since we know exactly which columns we'd like, and we know
                 * that they must be included (since they're all supported from API 1), we'll
                 * use [Cursor.getColumnIndexOrThrow]. This method will throw an
                 * [IllegalArgumentException] if the column named isn't found.
                 *
                 * In either case, while this method isn't slow, we'll want to cache the results
                 * to avoid having to look them up for each row.
                 */
                val idColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
                val displayNameColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME)
                val relativePathColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.RELATIVE_PATH)
                val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
                val dateTakenColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_TAKEN)

                Log.i(TAG, "Found ${cursor.count} images")
                while (cursor.moveToNext()) {

                    // Here we'll use the column indexs that we found above.
                    val id = cursor.getLong(idColumn)
                    val displayName = cursor.getString(displayNameColumn)
                    val relativePath = cursor.getString(relativePathColumn)
                    val data = cursor.getString(dataColumn)
                    val dateTaken = cursor.getLong(dateTakenColumn)

                    /**
                     * This is one of the trickiest parts:
                     *
                     * Since we're accessing images (using
                     * [MediaStore.Images.Media.EXTERNAL_CONTENT_URI], we'll use that
                     * as the base URI and append the ID of the image to it.
                     *
                     * This is the exact same way to do it when working with [MediaStore.Video] and
                     * [MediaStore.Audio] as well. Whatever `Media.EXTERNAL_CONTENT_URI` you
                     * query to get the items is the base, and the ID is the document to
                     * request there.
                     */
                    val contentUri = ContentUris.withAppendedId(
                        uri,
                        id
                    )

                    val image = MediaStoreImage(
                        id, contentUri, displayName, relativePath, data, dateTaken
                    )
                    images += image

                    // For debugging, we'll output the image objects we create to logcat.
                    Log.v(TAG, "Added image: $image")
                }
            }
        }

        if (sortMediaBy == SORT_BY_PATH) {
            images.sortWith(fileNameComparator { it.displayName })
            images.sortWith(fileNameComparator { it.relativePath })
        }

        Log.v(TAG, "Found ${images.size} images")
        return images
    }

    init {
        viewModelScope.launch {
            RootPreferences.sortMediaByFlowable.asFlow().collect { sortMediaBy ->
                _mediasFlow.value = queryMedias(uri, sortMediaBy)
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/MediaStoreImage.kt
================================================
```
/*
 * Copyright (C) 2019 The Android Open Source Project
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://github.com/android/storage-samples/blob/master/MediaStore/app/src/main/java/com/android/samples/mediastore/MediaStoreImage.kt

package me.gm.cleaner.plugin.ui.mediastore.images

import android.net.Uri
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreModel

/**
 * Simple data class to hold information about an image included in the device's MediaStore.
 */
data class MediaStoreImage(
    override val id: Long,
    override val contentUri: Uri,
    override val displayName: String,
    override val relativePath: String,
    override val data: String,
    override val dateTaken: Long,
) : MediaStoreModel(id, contentUri, displayName, relativePath, data, dateTaken)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ProgressionGridLayoutManager.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.images;

import android.animation.TimeInterpolator;
import android.content.Context;
import android.graphics.Rect;
import android.util.SparseArray;
import android.view.View;
import android.view.animation.LinearInterpolator;

import androidx.annotation.FloatRange;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.interpolator.view.animation.FastOutSlowInInterpolator;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.util.function.Consumer;

/**
 * A {@link RecyclerView.LayoutManager} implementation that lays out items in a grid,
 * and supports animate between different spans.
 */
public class ProgressionGridLayoutManager extends GridLayoutManager {

    private static final boolean DEBUG = false;
    private static final String TAG = "ProgressionGridLayoutManager";

    int mLastSpanCount;
    boolean mLayoutInfoStale = false;
    SparseArray<Rect> mLastLayoutInfo = new SparseArray<>();
    SparseArray<Rect> mCurLayoutInfo = new SparseArray<>();

    @FloatRange(from = 0F, to = 1F)
    float mProgress = 1F;
    @NonNull
    TimeInterpolator mInterpolator = new FastOutSlowInInterpolator();

    public ProgressionGridLayoutManager(Context context, int spanCount) {
        super(context, spanCount);
    }

    public ProgressionGridLayoutManager(Context context, int spanCount,
                                        @RecyclerView.Orientation int orientation,
                                        boolean reverseLayout) {
        super(context, spanCount, orientation, reverseLayout);
    }

    private static class VisibleChild {
        final int index;
        final View child;

        private VisibleChild(int index, View child) {
            this.index = index;
            this.child = child;
        }
    }

    private void forEachIndexed(Consumer<VisibleChild> action) {
        final int fromIndex = findFirstVisibleItemPosition();
        if (fromIndex == RecyclerView.NO_POSITION) {
            return;
        }
        final int toIndex = findLastVisibleItemPosition();
        for (int i = fromIndex; i <= toIndex; i++) {
            final View child = findViewByPosition(i);
            assert child != null;
            action.accept(new VisibleChild(i, child));
        }
    }

    void layoutInfoSnapshot(SparseArray<Rect> layoutInfo) {
        layoutInfo.clear();
        forEachIndexed(visibleChild -> {
            final int i = visibleChild.index;
            final View child = visibleChild.child;

            final Rect rect = new Rect();
            child.getHitRect(rect);
            layoutInfo.put(i, rect);
        });
    }

    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // Note that this method is not just called when spanCount change.
        // We shall check the state carefully.
        if (mLayoutInfoStale) {
            layoutInfoSnapshot(mLastLayoutInfo);
        }
        super.onLayoutChildren(recycler, state);
    }

    @Override
    public void onLayoutCompleted(RecyclerView.State state) {
        super.onLayoutCompleted(state);
        // Note that this method is not just called when spanCount change.
        // We shall check the state carefully.
        if (mLayoutInfoStale) {
            layoutInfoSnapshot(mCurLayoutInfo);
            mLayoutInfoStale = false;
            if (mLastSpanCount != DEFAULT_SPAN_COUNT) {
                setProgress(0F);
            }
        }
    }

    @Override
    public boolean canScrollVertically() {
        return getProgress() == 1F && super.canScrollVertically();
    }

    private float getInterpolatedProgress() {
        return mInterpolator.getInterpolation(getProgress());
    }

    void mockLayout(@NonNull View child, int left, int top, int right, int bottom,
                    int lastLeft, int lastTop, int lastRight, int lastBottom) {
        final float progress = getInterpolatedProgress();

        final int lastWidth = lastRight - lastLeft;
        final int lastHeight = lastBottom - lastTop;
        final int width = right - left;
        final int height = bottom - top;
        child.setScaleX((lastWidth + (width - lastWidth) * progress) / width);
        child.setScaleY((lastHeight + (height - lastHeight) * progress) / height);

        final float lastHorizontalCenter = (lastRight + lastLeft) >> 1;
        final float lastVerticalCenter = (lastBottom + lastTop) >> 1;
        final float horizontalCenter = (right + left) >> 1;
        final float verticalCenter = (bottom + top) >> 1;
        child.setTranslationX((lastHorizontalCenter - horizontalCenter) * (1 - progress));
        child.setTranslationY((lastVerticalCenter - verticalCenter) * (1 - progress));
    }

    @Override
    public void setSpanCount(int spanCount) {
        if (spanCount == getSpanCount()) {
            return;
        }
        if (getProgress() != 1F &&
                // ensure not called by the constructor
                getSpanCount() != DEFAULT_SPAN_COUNT) {
            throw new IllegalStateException(
                    "Must finish the previous animation first before setting a new span count");
        }
        mLastSpanCount = getSpanCount();
        mLayoutInfoStale = true;
        super.setSpanCount(spanCount);
    }

    public float getProgress() {
        return mProgress;
    }

    public void setProgress(@FloatRange(from = 0F, to = 1F) float progress) {
        if (progress == mProgress) {
            return;
        }
        if (mLayoutInfoStale) {
            return;
        }
        mProgress = progress;
        final boolean setAlphaNeeded = mLastSpanCount < getSpanCount();

        forEachIndexed(visibleChild -> {
            final int i = visibleChild.index;
            final View child = visibleChild.child;

            final Rect last = mLastLayoutInfo.get(i);
            if (last != null) {
                final Rect cur = mCurLayoutInfo.get(i);
                if (cur == null) {
                    throw new IllegalStateException("Are you scrolling?");
                }
                mockLayout(child, cur.left, cur.top, cur.right, cur.bottom,
                        last.left, last.top, last.right, last.bottom
                );
            } else if (setAlphaNeeded) {
                final float interpolatedProgress = getInterpolatedProgress();
                child.setAlpha(interpolatedProgress);
            }
        });
    }

    public TimeInterpolator getInterpolator() {
        return mInterpolator;
    }

    public void setInterpolator(@Nullable TimeInterpolator i) {
        mInterpolator = i != null ? i : new LinearInterpolator();
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ScaleGestureListener.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.images

import android.animation.Animator
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.content.Context
import android.view.MotionEvent
import android.view.ScaleGestureDetector
import androidx.core.animation.doOnEnd
import androidx.core.math.MathUtils.clamp
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.animation.AnimationUtils
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import kotlin.math.abs

class ScaleGestureListener(
    private val context: Context,
    private val layoutManager: ProgressionGridLayoutManager,
    private val viewHelper: MediaStoreFragment.MediaStoreRecyclerViewHelper
) : RecyclerView.SimpleOnItemTouchListener() {
    private var scaleEndAnimator: ValueAnimator? = null
    private val gestureDetector: ScaleGestureDetector by lazy {
        ScaleGestureDetector(context, object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
            private var prevProgress = 0F
            private var isNewSpanCountSet = false

            override fun onScale(detector: ScaleGestureDetector): Boolean {
                val scaleFactor = detector.scaleFactor

                if (!isNewSpanCountSet && layoutManager.progress == 1F) {
                    layoutManager.spanCount = when {
                        scaleFactor > 1F -> {
                            // zoom in
                            if (layoutManager.spanCount - spanCountInterval < minSpanCount ||
                                layoutManager.spanCount == minSpanCount && layoutManager.progress == 1F
                            ) {
                                return true
                            }
                            layoutManager.spanCount - spanCountInterval
                        }

                        scaleFactor < 1F -> {
                            // zoom out
                            if (layoutManager.spanCount + spanCountInterval > maxSpanCount ||
                                layoutManager.spanCount == maxSpanCount && layoutManager.progress == 1F
                            ) {
                                return true
                            }
                            layoutManager.spanCount + spanCountInterval
                        }

                        else -> return false
                    }
                    isNewSpanCountSet = true
                }

                val newProgress = when {
                    scaleFactor > 1F -> abs(1F - scaleFactor) / SCALE_FACTOR
                    scaleFactor < 1F -> abs(1F - 1 / scaleFactor) / SCALE_FACTOR
                    else -> 0F
                }
                if (layoutManager.progress == 1F) {
                    prevProgress = newProgress
                    isNewSpanCountSet = false
                }
                layoutManager.progress = clamp(newProgress - prevProgress, 0F, 1F)
                return false
            }

            override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
                if (scaleEndAnimator?.isRunning == true) {
                    return false
                }
                prevProgress = 0F
                isNewSpanCountSet = false
                return true
            }

            override fun onScaleEnd(detector: ScaleGestureDetector) {
                animateProgress(layoutManager.progress, 1F) {
                    RootPreferences.spanCountFlowable.value = layoutManager.spanCount
                    // manually invalidate itemsHeights
                    viewHelper.observer.onChanged()
                }
            }
        })
    }

    @SuppressLint("RestrictedApi")
    private fun animateProgress(
        from: Float, to: Float, doOnEnd: ((animator: Animator) -> Unit)? = null
    ) {
        scaleEndAnimator?.cancel()
        scaleEndAnimator = ValueAnimator.ofFloat(from, to).apply {
            duration = (context.mediumAnimTime * abs(to - from)).toLong()
            interpolator = AnimationUtils.LINEAR_INTERPOLATOR
            addUpdateListener { valueAnimator ->
                layoutManager.progress = valueAnimator.animatedValue as Float
            }
            doOnEnd {
                doOnEnd?.invoke(it)
            }
            start()
        }
    }

    override fun onInterceptTouchEvent(rv: RecyclerView, e: MotionEvent): Boolean {
        if (scaleEndAnimator?.isRunning == true) {
            // Disable fastScroller.
            return true
        } else {
            scaleEndAnimator = null
        }
        return e.pointerCount >= 2
    }

    override fun onTouchEvent(rv: RecyclerView, e: MotionEvent) {
        val scaleEndAnimator = scaleEndAnimator
        when {
            scaleEndAnimator == null -> {
                gestureDetector.onTouchEvent(e)
            }

            scaleEndAnimator.isRunning -> {
                // Request intercept SelectionTracker's OnItemTouchListener.
                rv.requestDisallowInterceptTouchEvent(true)
            }

            !scaleEndAnimator.isRunning -> {
                // TODO: I don't know what to do.
                //  rv.requestDisallowInterceptTouchEvent(false)
            }
        }
    }

    companion object {
        const val SCALE_FACTOR: Float = 1F
        const val minSpanCount: Int = 1
        const val maxSpanCount: Int = 5
        const val spanCountInterval: Int = 1
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoAdapter.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video

import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ui.mediastore.files.FilesAdapter
import me.gm.cleaner.plugin.ui.mediastore.files.MediaStoreFiles

class VideoAdapter(private val fragment: VideoFragment) : FilesAdapter(fragment) {
    private val viewModel: VideoViewModel by fragment.viewModels()

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        super.onBindViewHolder(holder, position)
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreFiles
                binding.card.setOnClickListener {
                    val navController = fragment.findNavController()
                    if (navController.currentDestination?.id != R.id.video_fragment) {
                        return@setOnClickListener
                    }

                    // TODO
//                    val videos = viewModel.medias
//                    val direction = VideoFragmentDirections.actionVideoToVideoPlayer(
//                        initialPosition = holder.bindingAdapterPosition,
//                        isMediaStoreUri = true,
//                        uris = videos.map { it.contentUri }.toTypedArray(),
//                        displayNames = videos.map { it.displayName }.toTypedArray()
//                    )
                    val direction = VideoFragmentDirections.actionVideoToVideoPlayer(
                        uris = arrayOf(item.contentUri),
                    )
                    navController.navigate(direction)
                }
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoFragment.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video

import android.Manifest
import android.os.Build
import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment

class VideoFragment : FilesFragment() {
    override val viewModel: VideoViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        FilesPermissionsRequesterFragment::class.java

    override fun onCreateAdapter(): VideoAdapter = VideoAdapter(this)

    class VideoPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_VIDEO)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoPlayerFragment.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video

import android.content.pm.ActivityInfo
import android.content.res.Configuration
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.AudioAttributes
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.common.VideoSize
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.DefaultRenderersFactory
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.SeekParameters
import androidx.media3.exoplayer.trackselection.DefaultTrackSelector
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import androidx.media3.ui.TimeBar
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.VideoPlayerFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomOnHorizontalScrubListener
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomOnVerticalScrubListener
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomTimeBar
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.VideoGestureDetector
import kotlin.math.max

@UnstableApi
class VideoPlayerFragment : BaseFragment() {
    private val viewModel: VideoPlayerViewModel by viewModels()
    private val args: VideoPlayerFragmentArgs by navArgs()
    private lateinit var trackSelectionParameters: DefaultTrackSelector.Parameters
    private var startItemIndex: Int = 0
    private var startPosition: Long = 0L
    private var isPlaying: Boolean = true
    private var playbackSpeed: Float = RootPreferences.playbackSpeedFlowable.value
    private lateinit var trackSelector: DefaultTrackSelector
    private var player: ExoPlayer? = null
    private var playerView: PlayerView? = null
    private lateinit var topBar: Toolbar

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = VideoPlayerFragmentBinding.inflate(inflater)
        playerView = binding.playerView
        customizePlayerViewBehavior(playerView!!, binding.gestureView)

        viewModel.screenOrientationLiveData.observe(viewLifecycleOwner) { orientation ->
            requireActivity().requestedOrientation = orientation
        }

        if (savedInstanceState != null) {
            // Restore as DefaultTrackSelector.Parameters in case ExoPlayer specific parameters were set.
            trackSelectionParameters = DefaultTrackSelector.Parameters.CREATOR.fromBundle(
                savedInstanceState.getBundle(KEY_TRACK_SELECTION_PARAMETERS)!!
            )
            startItemIndex = savedInstanceState.getInt(KEY_ITEM_INDEX)
            startPosition = savedInstanceState.getLong(KEY_POSITION)
            isPlaying = savedInstanceState.getBoolean(KEY_IS_PLAYING, isPlaying)
            playbackSpeed = RootPreferences.playbackSpeedFlowable.value
        } else {
            trackSelectionParameters = DefaultTrackSelector
                .ParametersBuilder(requireContext())
                .build()
        }

        findNavController().addOnExitListener { _, destination, _ ->
            restoreAppBar(destination)
            requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
                .setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED)
        }
        return binding.root
    }

    private fun customizePlayerViewBehavior(playerView: PlayerView, gestureView: View) {
        playerView.controllerAutoShow = false
        playerView.isClickable = false

        val controller =
            playerView.findViewById<PlayerControlView>(androidx.media3.ui.R.id.exo_controller)!!
        val controlViewLayoutManager = PlayerControlViewLayoutManagerAccessor(controller)
        val timeBar = controller.findViewById<CustomTimeBar>(androidx.media3.ui.R.id.exo_progress)
        timeBar.addListener(timeBar)
        timeBar.addListener(object : CustomOnHorizontalScrubListener(
            playerView, controller, controlViewLayoutManager
        ) {
            override fun onScrubStart(timeBar: TimeBar, position: Long) {
                (playerView.player as? ExoPlayer)?.setSeekParameters(SeekParameters.CLOSEST_SYNC)
                super.onScrubStart(timeBar, position)
            }

            override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
                (playerView.player as? ExoPlayer)?.setSeekParameters(null)
                super.onScrubStop(timeBar, position, canceled)
            }
        })
        topBar = controller.findViewById(R.id.top_bar)
        topBar.setNavigationOnClickListener { findNavController().navigateUp() }
        topBar.setNavigationIcon(R.drawable.ic_outline_arrow_back_24)
        if (resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT) {
            topBar.fitsSystemWindowInsets()
        }

        val horizontalScrubListeners = arrayOf(timeBar, object : CustomOnHorizontalScrubListener(
            playerView, controller, controlViewLayoutManager
        ) {
            // TODO: Maybe we can implement a scheme to seek fast and exact. Please refer to
            //  https://github.com/google/ExoPlayer/issues/7025

        })
        val verticalScrubListener = CustomOnVerticalScrubListener(
            requireActivity().window, playerView, controller, controlViewLayoutManager
        )
        val detector = VideoGestureDetector(requireContext(), object :
            VideoGestureDetector.OnVideoGestureListener {
            private val density: Float = resources.displayMetrics.density

            override fun onHorizontalScrubStart(
                initialMotionX: Float, initialMotionY: Float
            ) {
                val player = player ?: return
                for (listener in horizontalScrubListeners) {
                    listener.onScrubStart(timeBar, player.currentPosition)
                }
            }

            override fun onHorizontalScrubMove(dx: Float): Boolean {
                val player = player ?: return false
                val newPositionMs =
                    player.currentPosition + (SCRUB_FACTOR * dx / density).toLong()
                for (listener in horizontalScrubListeners) {
                    listener.onScrubMove(timeBar, newPositionMs)
                }
                return true
            }

            override fun onHorizontalScrubEnd() {
                val player = player ?: return
                for (listener in horizontalScrubListeners) {
                    listener.onScrubStop(timeBar, player.currentPosition, false)
                }
            }

            override fun onVerticalScrubStart(initialMotionX: Float, initialMotionY: Float) {
                verticalScrubListener.onScrubStart(initialMotionX, initialMotionY)
            }

            override fun onVerticalScrubMove(dy: Float): Boolean {
                verticalScrubListener.onScrubMove(dy)
                return true
            }

            override fun onVerticalScrubEnd() {
                verticalScrubListener.onScrubStop()
            }

            override fun onSingleTapConfirmed(ev: MotionEvent): Boolean {
                if (controller.isFullyVisible) {
                    controlViewLayoutManager.hide()
                } else {
                    controlViewLayoutManager.show()
                }
                return true
            }

            override fun onDoubleTap(ev: MotionEvent): Boolean {
                val player = player ?: return false
                player.playWhenReady = !player.playWhenReady
                if (player.playWhenReady) {
                    controlViewLayoutManager.hide()
                }
                return true
            }
        }
        )
        //noinspection ClickableViewAccessibility
        gestureView.setOnTouchListener { _, event ->
            detector.onTouchEvent(event)
            true
        }
    }

    inner class PlayerEventListener : Player.Listener {

        override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {
            super.onMediaItemTransition(mediaItem, reason)
            lifecycleScope.launch {
                val result = viewModel
                    .queryVideoTitleAsync(mediaItem!!.localConfiguration!!.uri)
                    .await()
                topBar.title = result.getOrNull()
            }
        }

        override fun onVideoSizeChanged(videoSize: VideoSize) {
            super.onVideoSizeChanged(videoSize)
            if (videoSize != VideoSize.UNKNOWN) {
                viewModel.screenOrientation = if (videoSize.width > videoSize.height) {
                    ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                } else {
                    ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                }
            }
        }
    }

    private fun initializePlayer() {
        if (player != null) {
            return
        }
        val context = requireContext().applicationContext
        val renderersFactory = DefaultRenderersFactory(context)
            .setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
        trackSelector = DefaultTrackSelector(context)

        player = ExoPlayer.Builder(context)
            .setRenderersFactory(renderersFactory)
            .setTrackSelector(trackSelector)
            .setDeviceVolumeControlEnabled(true)
            .build().also { player ->
                player.addListener(PlayerEventListener())
                player.seekTo(startItemIndex, startPosition)
                player.setAudioAttributes(AudioAttributes.DEFAULT, true)
                player.setPlaybackSpeed(playbackSpeed)
                player.playWhenReady = isPlaying
                player.trackSelectionParameters = trackSelectionParameters
                val mediaItems = args.uris.map { MediaItem.fromUri(it) }
                player.setMediaItems(mediaItems, false)
                player.prepare()
            }
        playerView?.player = player
    }

    private fun updatePlayerState() {
        player?.let { player ->
            trackSelectionParameters =
                player.trackSelectionParameters as DefaultTrackSelector.Parameters
            startItemIndex = player.currentMediaItemIndex
            startPosition = max(0, player.contentPosition)
            isPlaying = player.playWhenReady
            playbackSpeed = player.playbackParameters.speed
        }
    }

    private fun releasePlayer() {
        updatePlayerState()
        player?.release()
        player = null
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        toggleAppBar(false)
        requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
            .setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)
    }

    override fun onResume() {
        super.onResume()
        initializePlayer()
        playerView?.onResume()
    }

    override fun onStart() {
        super.onStart()
        initializePlayer()
        playerView?.onResume()
    }

    override fun onPause() {
        super.onPause()
        playerView?.onPause()
        releasePlayer()
    }

    override fun onStop() {
        super.onStop()
        playerView?.onPause()
        releasePlayer()
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        updatePlayerState()
        outState.putBundle(KEY_TRACK_SELECTION_PARAMETERS, trackSelectionParameters.toBundle())
        outState.putInt(KEY_ITEM_INDEX, startItemIndex)
        outState.putLong(KEY_POSITION, startPosition)
        outState.putBoolean(KEY_IS_PLAYING, isPlaying)
        RootPreferences.playbackSpeedFlowable.value = playbackSpeed
    }

    companion object {
        private const val SCRUB_FACTOR: Int = 125

        // Saved instance state keys.
        private const val KEY_TRACK_SELECTION_PARAMETERS: String = "track_selection_parameters"
        private const val KEY_ITEM_INDEX: String = "item_index"
        private const val KEY_POSITION: String = "position"
        private const val KEY_IS_PLAYING: String = "is_playing"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoPlayerViewModel.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video

import android.app.Application
import android.content.pm.ActivityInfo
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.withContext
import java.io.FileNotFoundException

class VideoPlayerViewModel(application: Application) : AndroidViewModel(application) {
    private val _screenOrientationFlow: MutableStateFlow<Int> =
        MutableStateFlow(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
    val screenOrientationLiveData: LiveData<Int>
        get() = _screenOrientationFlow.asLiveData()
    var screenOrientation: Int
        get() = _screenOrientationFlow.value
        set(value) {
            _screenOrientationFlow.tryEmit(value)
        }

    fun queryVideoTitleAsync(uri: Uri) = viewModelScope.async {
        queryVideoTitle(uri)
    }

    private suspend fun queryVideoTitle(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(MediaStore.Video.Media.DISPLAY_NAME)

        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->

            val displayNameColumn =
                cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)

            if (cursor.moveToNext()) {
                val displayName = cursor.getString(displayNameColumn)

                return@withContext Result.success(displayName)
            }
        }
        Result.failure(FileNotFoundException())
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoViewModel.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video

import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel

class VideoViewModel(application: Application) : FilesViewModel(application) {
    private val uri: Uri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI

    init {
        viewModelScope.launch {
            combine(
                _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
            ) { isSearching, queryText, sortMediaBy ->
                queryMedias(uri, sortMediaBy)
            }.collect {
                _mediasFlow.value = it
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomOnHorizontalScrubListener.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video.customexo

import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.widget.Toolbar
import androidx.core.view.isVisible
import androidx.media3.common.util.UnstableApi
import androidx.media3.common.util.Util
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import androidx.media3.ui.TimeBar
import me.gm.cleaner.plugin.R
import java.lang.reflect.Field
import java.util.Formatter
import java.util.Locale

@UnstableApi
open class CustomOnHorizontalScrubListener(
    private val playerView: PlayerView,
    private val controller: PlayerControlView,
    private val controlViewLayoutManager: PlayerControlViewLayoutManagerAccessor
) : TimeBar.OnScrubListener {
    private val scrubbingField: Field = PlayerControlView::class.java
        .getDeclaredField("scrubbing")
        .apply { isAccessible = true }
    private lateinit var controlsBackground: View
    private lateinit var centerControls: LinearLayout
    private lateinit var centerText: TextView
    private lateinit var topBar: Toolbar
    private lateinit var bottomBar: ViewGroup
    private lateinit var timeBar: View

    private var playingOnScrubStart: Boolean = true
    private var controllerVisibleOnScrubStart: Boolean = false
    private var startingPosition: Long = 0L
    private val formatBuilder: StringBuilder = StringBuilder()
    private val formatter: Formatter = Formatter(formatBuilder, Locale.getDefault())

    private fun prepareViews() {
        if (::controlsBackground.isInitialized) {
            return
        }
        controlsBackground =
            controller.findViewById(androidx.media3.ui.R.id.exo_controls_background)
        centerControls = controller.findViewById(androidx.media3.ui.R.id.exo_center_controls)
        centerText = controller.findViewById(R.id.center_text)
        topBar = controller.findViewById(R.id.top_bar)
        bottomBar = controller.findViewById(androidx.media3.ui.R.id.exo_bottom_bar)
        timeBar = controller.findViewById(androidx.media3.ui.R.id.exo_progress)
    }

    private fun getDeltaString(timeMs: Long): String {
        val prefix = if (timeMs > 0) "+" else ""
        return prefix + Util.getStringForTime(formatBuilder, formatter, timeMs)
    }

    override fun onScrubStart(timeBar: TimeBar, position: Long) {
        prepareViews()
        scrubbingField[controller] = true
        playingOnScrubStart = playerView.player?.playWhenReady == true
        controllerVisibleOnScrubStart = controller.isFullyVisible
        controlsBackground.isVisible = false
        centerControls.isVisible = false
        centerText.isVisible = true
        topBar.isVisible = false
        bottomBar.translationY = 0F
        this.timeBar.translationY = 0F
        controlViewLayoutManager.showImmediately()
        controlViewLayoutManager.removeHideCallbacks()

        playerView.player?.pause()
        startingPosition = playerView.player?.currentPosition ?: 0L
        playerView.player?.seekTo(position)
        centerText.text = getDeltaString(position - startingPosition)
    }

    override fun onScrubMove(timeBar: TimeBar, position: Long) {
        playerView.player?.seekTo(position)
        centerText.text = getDeltaString(position - startingPosition)
    }

    override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
        scrubbingField[controller] = false
        controlsBackground.isVisible = true
        centerControls.isVisible = true
        centerText.isVisible = false
        topBar.isVisible = true
        if (controllerVisibleOnScrubStart) {
            controlViewLayoutManager.resetHideCallbacks()
        } else {
            controlViewLayoutManager.hideImmediately()
        }

        playerView.player?.seekTo(position)
        if (playingOnScrubStart) {
            playerView.player?.play()
        }
    }

    val isScrubbing: Boolean
        get() = scrubbingField[controller] as Boolean
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomOnVerticalScrubListener.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video.customexo

import android.provider.Settings
import android.view.Window
import android.view.WindowManager
import android.widget.TextView
import androidx.core.math.MathUtils.clamp
import androidx.core.view.children
import androidx.core.view.isVisible
import androidx.media3.common.DeviceInfo
import androidx.media3.common.util.UnstableApi
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.isRtl
import kotlin.math.roundToInt

@UnstableApi
open class CustomOnVerticalScrubListener(
    private val window: Window,
    private val playerView: PlayerView,
    private val controller: PlayerControlView,
    private val controlViewLayoutManager: PlayerControlViewLayoutManagerAccessor
) {
    private lateinit var centerText: TextView
    private lateinit var deviceInfo: DeviceInfo

    private val density: Float = playerView.resources.displayMetrics.density * 2
    private val isRtl: Boolean = playerView.resources.configuration.isRtl
    private var atLeftHalfScreen: Boolean = true
    private var screenBrightness: Float = window.attributes.screenBrightness
    private var currentVolume: Float = 0F

    private fun prepare() {
        if (::centerText.isInitialized) {
            return
        }
        centerText = playerView.findViewById(R.id.center_text)
        deviceInfo = playerView.player!!.deviceInfo
    }

    private fun getBrightnessString(brightness: Float): String = "${(100 * brightness).toInt()} %"

    private fun getVolumeString(deviceVolume: Int): String {
        val fraction =
            100 * (deviceVolume - deviceInfo.minVolume) / (deviceInfo.maxVolume - deviceInfo.minVolume)
        return "$fraction %"
    }

    fun onScrubStart(initialMotionX: Float, initialMotionY: Float) {
        val player = playerView.player ?: return
        prepare()
        controller.children.forEach { child ->
            child.isVisible = child === centerText
        }
        controlViewLayoutManager.showImmediately()
        controlViewLayoutManager.removeHideCallbacks()

        atLeftHalfScreen = initialMotionX < playerView.width / 2
        if (screenBrightness == WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE) {
            val SCREEN_BRIGHTNESS_FLOAT = "screen_brightness_float"
            screenBrightness = Settings.System.getFloat(
                playerView.context.contentResolver, SCREEN_BRIGHTNESS_FLOAT
            )
        }
        currentVolume = player.deviceVolume.toFloat()
    }

    fun onScrubMove(dy: Float) {
        val player = playerView.player ?: return
        if (!isRtl && atLeftHalfScreen || isRtl && !atLeftHalfScreen) {
            screenBrightness = clamp(
                screenBrightness - dy / density / (deviceInfo.maxVolume - deviceInfo.minVolume),
                0F,
                1F
            )
            centerText.text = getBrightnessString(screenBrightness)
            val attributes = window.attributes
            attributes.screenBrightness = screenBrightness
            window.attributes = attributes
        } else {
            currentVolume = clamp(
                currentVolume - dy / density,
                deviceInfo.minVolume.toFloat(),
                deviceInfo.maxVolume.toFloat()
            )
            val currentVolumeInt = currentVolume.roundToInt()
            centerText.text = getVolumeString(currentVolumeInt)
            player.setDeviceVolume(currentVolumeInt, 0)
        }
    }

    fun onScrubStop() {
        controller.children.forEach { child ->
            child.isVisible = child !== centerText
        }
        controlViewLayoutManager.hideImmediately()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomTimeBar.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video.customexo

import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import androidx.core.math.MathUtils.clamp
import androidx.core.view.ViewCompat
import androidx.media3.common.util.UnstableApi
import androidx.media3.common.util.Util
import androidx.media3.ui.TimeBar
import com.google.android.material.R
import com.google.android.material.animation.AnimationUtils
import com.google.android.material.internal.DescendantOffsetUtils
import com.google.android.material.internal.ViewUtils
import com.google.android.material.tooltip.TooltipDrawable
import me.gm.cleaner.plugin.ktx.isRtl
import me.gm.cleaner.plugin.ktx.shortAnimTime
import kotlin.math.max

@UnstableApi
@SuppressLint("RestrictedApi")
class CustomTimeBar @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0,
    timebarAttrs: AttributeSet? = null, defStyleRes: Int = 0
) : DefaultTimeBar(context, attrs, defStyleAttr, timebarAttrs, defStyleRes),
    TimeBar.OnScrubListener {
    private val label = context.obtainStyledAttributes(
        attrs, R.styleable.Slider, defStyleAttr, R.style.Widget_Material3_Slider
    ).use {
        TooltipDrawable.createFromAttributes(
            context, null, 0, it.getResourceId(
                R.styleable.Slider_labelStyle, R.style.Widget_Material3_Tooltip
            )
        )
    }

    private var labelAreAnimatedIn = false
    private var labelInAnimator: ValueAnimator? = null
    private var labelOutAnimator: ValueAnimator? = null

    private val widgetHeight = resources.getDimensionPixelOffset(R.dimen.mtrl_slider_widget_height)
    private val thumbRadius = dpToPx(density, DEFAULT_BAR_HEIGHT_DP) / 2
    private val labelPadding = resources.getDimensionPixelSize(R.dimen.mtrl_slider_label_padding)
    private var trackWidth = 0

    override fun onScrubStart(timeBar: TimeBar, position: Long) {
        label.text = Util.getStringForTime(formatBuilder, formatter, position)
        ensureLabelAdded()
    }

    override fun onScrubMove(timeBar: TimeBar, position: Long) {
        scrubPosition = position
        label.text = Util.getStringForTime(formatBuilder, formatter, position)
        ensureLabelAdded()
    }

    override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
        ensureLabelRemoved()
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        updateTrackWidth(w)
    }

    private fun updateTrackWidth(width: Int) {
        // Update the visible track width.
        trackWidth = max(width, 0)
    }

    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        attachLabelToContentView(label)
    }

    private fun attachLabelToContentView(label: TooltipDrawable) {
        label.setRelativeToView(ViewUtils.getContentView(this))
    }

    override fun onDetachedFromWindow() {
        labelAreAnimatedIn = false
        detachLabelFromContentView(label)
        super.onDetachedFromWindow()
    }

    private fun detachLabelFromContentView(label: TooltipDrawable) {
        overlay.remove(label)
        label.detachView(ViewUtils.getContentView(this))
    }

    private fun getAnimatorCurrentValueOrDefault(
        animator: ValueAnimator?, defaultValue: Float
    ): Float {
        // If the in animation is interrupting the out animation, attempt to smoothly interrupt by
        // getting the current value of the out animator.
        if (animator != null && animator.isRunning) {
            val value = animator.animatedValue as Float
            animator.cancel()
            return value
        }
        return defaultValue
    }

    private fun createLabelAnimator(enter: Boolean): ValueAnimator? {
        var startFraction = if (enter) 0f else 1f
        // Update the start fraction to the current animated value of the label, if any.
        startFraction = getAnimatorCurrentValueOrDefault(
            if (enter) labelOutAnimator else labelInAnimator, startFraction
        )
        val endFraction = if (enter) 1f else 0f
        val animator = ValueAnimator.ofFloat(startFraction, endFraction)
        animator.duration = context.shortAnimTime
        animator.interpolator =
            if (enter) AnimationUtils.DECELERATE_INTERPOLATOR else AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR
        animator.addUpdateListener { animation ->
            val fraction = animation.animatedValue as Float
            label.setRevealFraction(fraction)
            // Ensure the labels are redrawn even if the slider has stopped moving
            ViewCompat.postInvalidateOnAnimation(this)
        }
        return animator
    }

    private fun ensureLabelAdded() {
        // If the labels are not animating in, start an animator to show them. ensureLabelsAdded will
        // be called multiple times by BaseSlider's draw method, making this check necessary to avoid
        // creating and starting an animator for each draw call.
        if (!labelAreAnimatedIn) {
            labelAreAnimatedIn = true
            labelInAnimator = createLabelAnimator(true)
            labelOutAnimator = null
            labelInAnimator?.start()
        }

        // Now set the label for the focused thumb so it's on top.
        val value = scrubPosition.toFloat() / duration.toFloat()
        setValueForLabel(label, value)
    }

    private fun ensureLabelRemoved() {
        // If the labels are animated in or in the process of animating in, create and start a new
        // animator to animate out the labels and remove them once the animation ends.
        if (labelAreAnimatedIn) {
            labelAreAnimatedIn = false
            labelOutAnimator = createLabelAnimator(false)
            labelInAnimator = null
            labelOutAnimator?.addListener(
                object : AnimatorListenerAdapter() {
                    override fun onAnimationEnd(animation: Animator) {
                        super.onAnimationEnd(animation)
                        overlay.remove(label)
                    }
                })
            labelOutAnimator?.start()
        }
    }

    /**
     * Returns a number between 0 and 1 indicating where on the track this value should sit with 0
     * being on the far left, and 1 on the far right.
     */
    private fun normalizeValue(value: Float): Float {
        val normalized = (value - valueFrom) / (valueTo - valueFrom)
        return if (context.resources.configuration.isRtl) 1 - normalized else normalized
    }

    private fun setValueForLabel(label: TooltipDrawable, value: Float) {
        var left =
            (scrubberPadding + normalizeValue(value) * (trackWidth - 2 * scrubberPadding)).toInt() - label.intrinsicWidth / 2
        left = clamp(
            left,
            2 * scrubberPadding - label.intrinsicWidth / 2,
            trackWidth - 2 * scrubberPadding - label.intrinsicWidth / 2
        )
        val top = widgetHeight / 2 - (labelPadding + thumbRadius)
        label.setBounds(left, top - label.intrinsicHeight, left + label.intrinsicWidth, top)

        // Calculate the difference between the bounds of this view and the bounds of the root view to
        // correctly position this view in the overlay layer.
        val rect = Rect(label.bounds)
        DescendantOffsetUtils.offsetDescendantRect(ViewUtils.getContentView(this)!!, this, rect)
        label.bounds = rect
        ViewUtils.getContentViewOverlay(this)?.add(label)
    }

    companion object {
        const val valueFrom = 0F
        const val valueTo = 1F
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/DefaultTimeBar.java
================================================
```
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package me.gm.cleaner.plugin.ui.mediastore.video.customexo;

import android.animation.ValueAnimator;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;

import androidx.annotation.ColorInt;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.media3.common.C;
import androidx.media3.common.util.Assertions;
import androidx.media3.common.util.UnstableApi;
import androidx.media3.common.util.Util;
import androidx.media3.ui.R;
import androidx.media3.ui.TimeBar;

import java.util.Collections;
import java.util.Formatter;
import java.util.Locale;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Change all modifiers of private methods to protected.
 */
@UnstableApi
public class DefaultTimeBar extends View implements TimeBar {

  /**
   * Default height for the time bar, in dp.
   */
  public static final int DEFAULT_BAR_HEIGHT_DP = 4;
  /**
   * Default height for the touch target, in dp.
   */
  public static final int DEFAULT_TOUCH_TARGET_HEIGHT_DP = 26;
  /**
   * Default width for ad markers, in dp.
   */
  public static final int DEFAULT_AD_MARKER_WIDTH_DP = 4;
  /**
   * Default diameter for the scrubber when enabled, in dp.
   */
  public static final int DEFAULT_SCRUBBER_ENABLED_SIZE_DP = 12;
  /**
   * Default diameter for the scrubber when disabled, in dp.
   */
  public static final int DEFAULT_SCRUBBER_DISABLED_SIZE_DP = 0;
  /**
   * Default diameter for the scrubber when dragged, in dp.
   */
  public static final int DEFAULT_SCRUBBER_DRAGGED_SIZE_DP = 16;
  /**
   * Default color for the played portion of the time bar.
   */
  public static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
  /**
   * Default color for the unplayed portion of the time bar.
   */
  public static final int DEFAULT_UNPLAYED_COLOR = 0x33FFFFFF;
  /**
   * Default color for the buffered portion of the time bar.
   */
  public static final int DEFAULT_BUFFERED_COLOR = 0xCCFFFFFF;
  /**
   * Default color for the scrubber handle.
   */
  public static final int DEFAULT_SCRUBBER_COLOR = 0xFFFFFFFF;
  /**
   * Default color for ad markers.
   */
  public static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
  /**
   * Default color for played ad markers.
   */
  public static final int DEFAULT_PLAYED_AD_MARKER_COLOR = 0x33FFFF00;

  /**
   * Vertical gravity for progress bar to be located at the center in the view.
   */
  public static final int BAR_GRAVITY_CENTER = 0;
  /**
   * Vertical gravity for progress bar to be located at the bottom in the view.
   */
  public static final int BAR_GRAVITY_BOTTOM = 1;

  /**
   * The threshold in dps above the bar at which touch events trigger fine scrub mode.
   */
  protected static final int FINE_SCRUB_Y_THRESHOLD_DP = -50;
  /**
   * The ratio by which times are reduced in fine scrub mode.
   */
  protected static final int FINE_SCRUB_RATIO = 3;
  /**
   * The time after which the scrubbing listener is notified that scrubbing has stopped after
   * performing an incremental scrub using key input.
   */
  protected static final long STOP_SCRUBBING_TIMEOUT_MS = 1000;

  protected static final int DEFAULT_INCREMENT_COUNT = 20;

  protected static final float SHOWN_SCRUBBER_SCALE = 1.0f;
  protected static final float HIDDEN_SCRUBBER_SCALE = 0.0f;

  /**
   * The name of the Android SDK view that most closely resembles this custom view. Used as the
   * class name for accessibility.
   */
  protected static final String ACCESSIBILITY_CLASS_NAME = "android.widget.SeekBar";

  protected final Rect seekBounds;
  protected final Rect progressBar;
  protected final Rect bufferedBar;
  protected final Rect scrubberBar;
  protected final Paint playedPaint;
  protected final Paint bufferedPaint;
  protected final Paint unplayedPaint;
  protected final Paint adMarkerPaint;
  protected final Paint playedAdMarkerPaint;
  protected final Paint scrubberPaint;
  @Nullable
  protected final Drawable scrubberDrawable;
  protected final int barHeight;
  protected final int touchTargetHeight;
  protected final int barGravity;
  protected final int adMarkerWidth;
  protected final int scrubberEnabledSize;
  protected final int scrubberDisabledSize;
  protected final int scrubberDraggedSize;
  protected final int scrubberPadding;
  protected final int fineScrubYThreshold;
  protected final StringBuilder formatBuilder;
  protected final Formatter formatter;
  protected final Runnable stopScrubbingRunnable;
  protected final CopyOnWriteArraySet<OnScrubListener> listeners;
  protected final Point touchPosition;
  protected final float density;

  protected int keyCountIncrement;
  protected long keyTimeIncrement;
  protected int lastCoarseScrubXPosition;
  protected Rect lastExclusionRectangle;

  protected ValueAnimator scrubberScalingAnimator;
  protected float scrubberScale;
  protected boolean scrubberPaddingDisabled;
  protected boolean scrubbing;
  protected long scrubPosition;
  protected long duration;
  protected long position;
  protected long bufferedPosition;
  protected int adGroupCount;
  @Nullable
  protected long[] adGroupTimesMs;
  @Nullable
  protected boolean[] playedAdGroups;

  public DefaultTimeBar(Context context) {
    this(context, null);
  }

  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs) {
    this(context, attrs, 0);
  }

  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    this(context, attrs, defStyleAttr, attrs);
  }

  public DefaultTimeBar(
          Context context,
          @Nullable AttributeSet attrs,
          int defStyleAttr,
          @Nullable AttributeSet timebarAttrs) {
    this(context, attrs, defStyleAttr, timebarAttrs, 0);
  }

  // Suppress warnings due to usage of View methods in the constructor.
  @SuppressWarnings("nullness:method.invocation")
  public DefaultTimeBar(
          Context context,
          @Nullable AttributeSet attrs,
          int defStyleAttr,
          @Nullable AttributeSet timebarAttrs,
          int defStyleRes) {
    super(context, attrs, defStyleAttr);
    seekBounds = new Rect();
    progressBar = new Rect();
    bufferedBar = new Rect();
    scrubberBar = new Rect();
    playedPaint = new Paint();
    bufferedPaint = new Paint();
    unplayedPaint = new Paint();
    adMarkerPaint = new Paint();
    playedAdMarkerPaint = new Paint();
    scrubberPaint = new Paint();
    scrubberPaint.setAntiAlias(true);
    listeners = new CopyOnWriteArraySet<>();
    touchPosition = new Point();

    // Calculate the dimensions and paints for drawn elements.
    Resources res = context.getResources();
    DisplayMetrics displayMetrics = res.getDisplayMetrics();
    density = displayMetrics.density;
    fineScrubYThreshold = dpToPx(density, FINE_SCRUB_Y_THRESHOLD_DP);
    int defaultBarHeight = dpToPx(density, DEFAULT_BAR_HEIGHT_DP);
    int defaultTouchTargetHeight = dpToPx(density, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
    int defaultAdMarkerWidth = dpToPx(density, DEFAULT_AD_MARKER_WIDTH_DP);
    int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
    int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
    int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
    if (timebarAttrs != null) {
      TypedArray a =
              context
                      .getTheme()
                      .obtainStyledAttributes(
                              timebarAttrs, R.styleable.DefaultTimeBar, defStyleAttr, defStyleRes);
      try {
        scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
        if (scrubberDrawable != null) {
          setDrawableLayoutDirection(scrubberDrawable);
          defaultTouchTargetHeight =
                  Math.max(scrubberDrawable.getMinimumHeight(), defaultTouchTargetHeight);
        }
        barHeight =
                a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height, defaultBarHeight);
        touchTargetHeight =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_touch_target_height, defaultTouchTargetHeight);
        barGravity = a.getInt(R.styleable.DefaultTimeBar_bar_gravity, BAR_GRAVITY_CENTER);
        adMarkerWidth =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_ad_marker_width, defaultAdMarkerWidth);
        scrubberEnabledSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_enabled_size, defaultScrubberEnabledSize);
        scrubberDisabledSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_disabled_size, defaultScrubberDisabledSize);
        scrubberDraggedSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_dragged_size, defaultScrubberDraggedSize);
        int playedColor = a.getInt(R.styleable.DefaultTimeBar_played_color, DEFAULT_PLAYED_COLOR);
        int scrubberColor =
                a.getInt(R.styleable.DefaultTimeBar_scrubber_color, DEFAULT_SCRUBBER_COLOR);
        int bufferedColor =
                a.getInt(R.styleable.DefaultTimeBar_buffered_color, DEFAULT_BUFFERED_COLOR);
        int unplayedColor =
                a.getInt(R.styleable.DefaultTimeBar_unplayed_color, DEFAULT_UNPLAYED_COLOR);
        int adMarkerColor =
                a.getInt(R.styleable.DefaultTimeBar_ad_marker_color, DEFAULT_AD_MARKER_COLOR);
        int playedAdMarkerColor =
                a.getInt(
                        R.styleable.DefaultTimeBar_played_ad_marker_color, DEFAULT_PLAYED_AD_MARKER_COLOR);
        playedPaint.setColor(playedColor);
        scrubberPaint.setColor(scrubberColor);
        bufferedPaint.setColor(bufferedColor);
        unplayedPaint.setColor(unplayedColor);
        adMarkerPaint.setColor(adMarkerColor);
        playedAdMarkerPaint.setColor(playedAdMarkerColor);
      } finally {
        a.recycle();
      }
    } else {
      barHeight = defaultBarHeight;
      touchTargetHeight = defaultTouchTargetHeight;
      barGravity = BAR_GRAVITY_CENTER;
      adMarkerWidth = defaultAdMarkerWidth;
      scrubberEnabledSize = defaultScrubberEnabledSize;
      scrubberDisabledSize = defaultScrubberDisabledSize;
      scrubberDraggedSize = defaultScrubberDraggedSize;
      playedPaint.setColor(DEFAULT_PLAYED_COLOR);
      scrubberPaint.setColor(DEFAULT_SCRUBBER_COLOR);
      bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
      unplayedPaint.setColor(DEFAULT_UNPLAYED_COLOR);
      adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
      playedAdMarkerPaint.setColor(DEFAULT_PLAYED_AD_MARKER_COLOR);
      scrubberDrawable = null;
    }
    formatBuilder = new StringBuilder();
    formatter = new Formatter(formatBuilder, Locale.getDefault());
    stopScrubbingRunnable = () -> stopScrubbing(/* canceled= */ false);
    if (scrubberDrawable != null) {
      scrubberPadding = (scrubberDrawable.getMinimumWidth() + 1) / 2;
    } else {
      scrubberPadding =
              (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)
                      / 2;
    }
    scrubberScale = 1.0f;
    scrubberScalingAnimator = new ValueAnimator();
    scrubberScalingAnimator.addUpdateListener(
            animation -> {
              scrubberScale = (float) animation.getAnimatedValue();
              invalidate(seekBounds);
            });
    duration = C.TIME_UNSET;
    keyTimeIncrement = C.TIME_UNSET;
    keyCountIncrement = DEFAULT_INCREMENT_COUNT;
    setFocusable(true);
    if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
      setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
  }

  /**
   * Shows the scrubber handle.
   */
  public void showScrubber() {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = false;
    scrubberScale = 1;
    invalidate(seekBounds);
  }

  /**
   * Shows the scrubber handle with animation.
   *
   * @param showAnimationDurationMs The duration for scrubber showing animation.
   */
  public void showScrubber(long showAnimationDurationMs) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = false;
    scrubberScalingAnimator.setFloatValues(scrubberScale, SHOWN_SCRUBBER_SCALE);
    scrubberScalingAnimator.setDuration(showAnimationDurationMs);
    scrubberScalingAnimator.start();
  }

  /**
   * Hides the scrubber handle.
   */
  public void hideScrubber(boolean disableScrubberPadding) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = disableScrubberPadding;
    scrubberScale = 0;
    invalidate(seekBounds);
  }

  /**
   * Hides the scrubber handle with animation.
   *
   * @param hideAnimationDurationMs The duration for scrubber hiding animation.
   */
  public void hideScrubber(long hideAnimationDurationMs) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberScalingAnimator.setFloatValues(scrubberScale, HIDDEN_SCRUBBER_SCALE);
    scrubberScalingAnimator.setDuration(hideAnimationDurationMs);
    scrubberScalingAnimator.start();
  }

  /**
   * Sets the color for the portion of the time bar representing media before the playback position.
   *
   * @param playedColor The color for the portion of the time bar representing media before the
   *                    playback position.
   */
  public void setPlayedColor(@ColorInt int playedColor) {
    playedPaint.setColor(playedColor);
    invalidate(seekBounds);
  }

  /**
   * Sets the color for the scrubber handle.
   *
   * @param scrubberColor The color for the scrubber handle.
   */
  public void setScrubberColor(@ColorInt int scrubberColor) {
    scrubberPaint.setColor(scrubberColor);
    invalidate(seekBounds);
  }

  /**
   * Sets the color for the portion of the time bar after the current played position up to the
   * current buffered position.
   *
   * @param bufferedColor The color for the portion of the time bar after the current played
   *                      position up to the current buffered position.
   */
  public void setBufferedColor(@ColorInt int bufferedColor) {
    bufferedPaint.setColor(bufferedColor);
    invalidate(seekBounds);
  }

  /**
   * Sets the color for the portion of the time bar after the current played position.
   *
   * @param unplayedColor The color for the portion of the time bar after the current played
   *                      position.
   */
  public void setUnplayedColor(@ColorInt int unplayedColor) {
    unplayedPaint.setColor(unplayedColor);
    invalidate(seekBounds);
  }

  /**
   * Sets the color for unplayed ad markers.
   *
   * @param adMarkerColor The color for unplayed ad markers.
   */
  public void setAdMarkerColor(@ColorInt int adMarkerColor) {
    adMarkerPaint.setColor(adMarkerColor);
    invalidate(seekBounds);
  }

  /**
   * Sets the color for played ad markers.
   *
   * @param playedAdMarkerColor The color for played ad markers.
   */
  public void setPlayedAdMarkerColor(@ColorInt int playedAdMarkerColor) {
    playedAdMarkerPaint.setColor(playedAdMarkerColor);
    invalidate(seekBounds);
  }

  // TimeBar implementation.

  @Override
  public void addListener(OnScrubListener listener) {
    Assertions.checkNotNull(listener);
    listeners.add(listener);
  }

  @Override
  public void removeListener(OnScrubListener listener) {
    listeners.remove(listener);
  }

  @Override
  public void setKeyTimeIncrement(long time) {
    Assertions.checkArgument(time > 0);
    keyCountIncrement = C.INDEX_UNSET;
    keyTimeIncrement = time;
  }

  @Override
  public void setKeyCountIncrement(int count) {
    Assertions.checkArgument(count > 0);
    keyCountIncrement = count;
    keyTimeIncrement = C.TIME_UNSET;
  }

  @Override
  public void setPosition(long position) {
    if (this.position == position) {
      return;
    }
    this.position = position;
    setContentDescription(getProgressText());
    update();
  }

  @Override
  public void setBufferedPosition(long bufferedPosition) {
    if (this.bufferedPosition == bufferedPosition) {
      return;
    }
    this.bufferedPosition = bufferedPosition;
    update();
  }

  @Override
  public void setDuration(long duration) {
    if (this.duration == duration) {
      return;
    }
    this.duration = duration;
    if (scrubbing && duration == C.TIME_UNSET) {
      stopScrubbing(/* canceled= */ true);
    }
    update();
  }

  @Override
  public long getPreferredUpdateDelay() {
    int timeBarWidthDp = pxToDp(density, progressBar.width());
    return timeBarWidthDp == 0 || duration == 0 || duration == C.TIME_UNSET
            ? Long.MAX_VALUE
            : duration / timeBarWidthDp;
  }

  @Override
  public void setAdGroupTimesMs(
          @Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups, int adGroupCount) {
    Assertions.checkArgument(
            adGroupCount == 0 || (adGroupTimesMs != null && playedAdGroups != null));
    this.adGroupCount = adGroupCount;
    this.adGroupTimesMs = adGroupTimesMs;
    this.playedAdGroups = playedAdGroups;
    update();
  }

  // View methods.

  @Override
  public void setEnabled(boolean enabled) {
    super.setEnabled(enabled);
    if (scrubbing && !enabled) {
      stopScrubbing(/* canceled= */ true);
    }
  }

  @Override
  public void onDraw(Canvas canvas) {
    canvas.save();
    drawTimeBar(canvas);
    drawPlayhead(canvas);
    canvas.restore();
  }

  @Override
  public boolean onTouchEvent(MotionEvent event) {
    if (!isEnabled() || duration <= 0) {
      return false;
    }
    Point touchPosition = resolveRelativeTouchPosition(event);
    int x = touchPosition.x;
    int y = touchPosition.y;
    switch (event.getAction()) {
      case MotionEvent.ACTION_DOWN:
        if (isInSeekBar(x, y)) {
          positionScrubber(x);
          startScrubbing(getScrubberPosition());
          update();
          invalidate();
          return true;
        }
        break;
      case MotionEvent.ACTION_MOVE:
        if (scrubbing) {
          if (y < fineScrubYThreshold) {
            int relativeX = x - lastCoarseScrubXPosition;
            positionScrubber(lastCoarseScrubXPosition + relativeX / FINE_SCRUB_RATIO);
          } else {
            lastCoarseScrubXPosition = x;
            positionScrubber(x);
          }
          updateScrubbing(getScrubberPosition());
          update();
          invalidate();
          return true;
        }
        break;
      case MotionEvent.ACTION_UP:
      case MotionEvent.ACTION_CANCEL:
        if (scrubbing) {
          stopScrubbing(/* canceled= */ event.getAction() == MotionEvent.ACTION_CANCEL);
          return true;
        }
        break;
      default:
        // Do nothing.
    }
    return false;
  }

  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (isEnabled()) {
      long positionIncrement = getPositionIncrement();
      switch (keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
          positionIncrement = -positionIncrement;
          // Fall through.
        case KeyEvent.KEYCODE_DPAD_RIGHT:
          if (scrubIncrementally(positionIncrement)) {
            removeCallbacks(stopScrubbingRunnable);
            postDelayed(stopScrubbingRunnable, STOP_SCRUBBING_TIMEOUT_MS);
            return true;
          }
          break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
          if (scrubbing) {
            stopScrubbing(/* canceled= */ false);
            return true;
          }
          break;
        default:
          // Do nothing.
      }
    }
    return super.onKeyDown(keyCode, event);
  }

  @Override
  protected void onFocusChanged(
          boolean gainFocus, int direction, @Nullable Rect previouslyFocusedRect) {
    super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
    if (scrubbing && !gainFocus) {
      stopScrubbing(/* canceled= */ false);
    }
  }

  @Override
  protected void drawableStateChanged() {
    super.drawableStateChanged();
    updateDrawableState();
  }

  @Override
  public void jumpDrawablesToCurrentState() {
    super.jumpDrawablesToCurrentState();
    if (scrubberDrawable != null) {
      scrubberDrawable.jumpToCurrentState();
    }
  }

  @Override
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int height =
            heightMode == MeasureSpec.UNSPECIFIED
                    ? touchTargetHeight
                    : heightMode == MeasureSpec.EXACTLY
                    ? heightSize
                    : Math.min(touchTargetHeight, heightSize);
    setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
    updateDrawableState();
  }

  @Override
  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int width = right - left;
    int height = bottom - top;
    int seekLeft = getPaddingLeft();
    int seekRight = width - getPaddingRight();
    int seekBoundsY;
    int progressBarY;
    int scrubberPadding = scrubberPaddingDisabled ? 0 : this.scrubberPadding;
    if (barGravity == BAR_GRAVITY_BOTTOM) {
      seekBoundsY = height - getPaddingBottom() - touchTargetHeight;
      progressBarY =
              height - getPaddingBottom() - barHeight - Math.max(scrubberPadding - (barHeight / 2), 0);
    } else {
      seekBoundsY = (height - touchTargetHeight) / 2;
      progressBarY = (height - barHeight) / 2;
    }
    seekBounds.set(seekLeft, seekBoundsY, seekRight, seekBoundsY + touchTargetHeight);
    progressBar.set(
            seekBounds.left + scrubberPadding,
            progressBarY,
            seekBounds.right - scrubberPadding,
            progressBarY + barHeight);
    if (Util.SDK_INT >= 29) {
      setSystemGestureExclusionRectsV29(width, height);
    }
    update();
  }

  @Override
  public void onRtlPropertiesChanged(int layoutDirection) {
    if (scrubberDrawable != null && setDrawableLayoutDirection(scrubberDrawable, layoutDirection)) {
      invalidate();
    }
  }

  @Override
  public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
    super.onInitializeAccessibilityEvent(event);
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) {
      event.getText().add(getProgressText());
    }
    event.setClassName(ACCESSIBILITY_CLASS_NAME);
  }

  @Override
  public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
    super.onInitializeAccessibilityNodeInfo(info);
    info.setClassName(ACCESSIBILITY_CLASS_NAME);
    info.setContentDescription(getProgressText());
    if (duration <= 0) {
      return;
    }
    if (Util.SDK_INT >= 21) {
      info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
    } else {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
  }

  @Override
  public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
    if (super.performAccessibilityAction(action, args)) {
      return true;
    }
    if (duration <= 0) {
      return false;
    }
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
      if (scrubIncrementally(-getPositionIncrement())) {
        stopScrubbing(/* canceled= */ false);
      }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
      if (scrubIncrementally(getPositionIncrement())) {
        stopScrubbing(/* canceled= */ false);
      }
    } else {
      return false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    return true;
  }

  // Internal methods.

  protected void startScrubbing(long scrubPosition) {
    this.scrubPosition = scrubPosition;
    scrubbing = true;
    setPressed(true);
    ViewParent parent = getParent();
    if (parent != null) {
      parent.requestDisallowInterceptTouchEvent(true);
    }
    for (OnScrubListener listener : listeners) {
      listener.onScrubStart(this, scrubPosition);
    }
  }

  protected void updateScrubbing(long scrubPosition) {
    if (this.scrubPosition == scrubPosition) {
      return;
    }
    this.scrubPosition = scrubPosition;
    for (OnScrubListener listener : listeners) {
      listener.onScrubMove(this, scrubPosition);
    }
  }

  protected void stopScrubbing(boolean canceled) {
    removeCallbacks(stopScrubbingRunnable);
    scrubbing = false;
    setPressed(false);
    ViewParent parent = getParent();
    if (parent != null) {
      parent.requestDisallowInterceptTouchEvent(false);
    }
    invalidate();
    for (OnScrubListener listener : listeners) {
      listener.onScrubStop(this, scrubPosition, canceled);
    }
  }

  /**
   * Incrementally scrubs the position by {@code positionChange}.
   *
   * @param positionChange The change in the scrubber position, in milliseconds. May be negative.
   * @return Returns whether the scrubber position changed.
   */
  protected boolean scrubIncrementally(long positionChange) {
    if (duration <= 0) {
      return false;
    }
    long previousPosition = scrubbing ? scrubPosition : position;
    long scrubPosition = Util.constrainValue(previousPosition + positionChange, 0, duration);
    if (scrubPosition == previousPosition) {
      return false;
    }
    if (!scrubbing) {
      startScrubbing(scrubPosition);
    } else {
      updateScrubbing(scrubPosition);
    }
    update();
    return true;
  }

  protected void update() {
    bufferedBar.set(progressBar);
    scrubberBar.set(progressBar);
    long newScrubberTime = scrubbing ? scrubPosition : position;
    if (duration > 0) {
      int bufferedPixelWidth = (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right);
      int scrubberPixelPosition = (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right);
    } else {
      bufferedBar.right = progressBar.left;
      scrubberBar.right = progressBar.left;
    }
    invalidate(seekBounds);
  }

  protected void positionScrubber(float xPosition) {
    scrubberBar.right = Util.constrainValue((int) xPosition, progressBar.left, progressBar.right);
  }

  protected Point resolveRelativeTouchPosition(MotionEvent motionEvent) {
    touchPosition.set((int) motionEvent.getX(), (int) motionEvent.getY());
    return touchPosition;
  }

  protected long getScrubberPosition() {
    if (progressBar.width() <= 0 || duration == C.TIME_UNSET) {
      return 0;
    }
    return (scrubberBar.width() * duration) / progressBar.width();
  }

  protected boolean isInSeekBar(float x, float y) {
    return seekBounds.contains((int) x, (int) y);
  }

  protected void drawTimeBar(Canvas canvas) {
    int progressBarHeight = progressBar.height();
    int barTop = progressBar.centerY() - progressBarHeight / 2;
    int barBottom = barTop + progressBarHeight;
    if (duration <= 0) {
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, unplayedPaint);
      return;
    }
    int bufferedLeft = bufferedBar.left;
    int bufferedRight = bufferedBar.right;
    int progressLeft = Math.max(Math.max(progressBar.left, bufferedRight), scrubberBar.right);
    if (progressLeft < progressBar.right) {
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, unplayedPaint);
    }
    bufferedLeft = Math.max(bufferedLeft, scrubberBar.right);
    if (bufferedRight > bufferedLeft) {
      canvas.drawRect(bufferedLeft, barTop, bufferedRight, barBottom, bufferedPaint);
    }
    if (scrubberBar.width() > 0) {
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
    }
    if (adGroupCount == 0) {
      return;
    }
    long[] adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs);
    boolean[] playedAdGroups = Assertions.checkNotNull(this.playedAdGroups);
    int adMarkerOffset = adMarkerWidth / 2;
    for (int i = 0; i < adGroupCount; i++) {
      long adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, duration);
      int markerPositionOffset =
              (int) (progressBar.width() * adGroupTimeMs / duration) - adMarkerOffset;
      int markerLeft =
              progressBar.left
                      + Math.min(progressBar.width() - adMarkerWidth, Math.max(0, markerPositionOffset));
      Paint paint = playedAdGroups[i] ? playedAdMarkerPaint : adMarkerPaint;
      canvas.drawRect(markerLeft, barTop, markerLeft + adMarkerWidth, barBottom, paint);
    }
  }

  protected void drawPlayhead(Canvas canvas) {
    if (duration <= 0) {
      return;
    }
    int playheadX = Util.constrainValue(scrubberBar.right, scrubberBar.left, progressBar.right);
    int playheadY = scrubberBar.centerY();
    if (scrubberDrawable == null) {
      int scrubberSize =
              (scrubbing || isFocused())
                      ? scrubberDraggedSize
                      : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
      int playheadRadius = (int) ((scrubberSize * scrubberScale) / 2);
      canvas.drawCircle(playheadX, playheadY, playheadRadius, scrubberPaint);
    } else {
      int scrubberDrawableWidth = (int) (scrubberDrawable.getIntrinsicWidth() * scrubberScale);
      int scrubberDrawableHeight = (int) (scrubberDrawable.getIntrinsicHeight() * scrubberScale);
      scrubberDrawable.setBounds(
              playheadX - scrubberDrawableWidth / 2,
              playheadY - scrubberDrawableHeight / 2,
              playheadX + scrubberDrawableWidth / 2,
              playheadY + scrubberDrawableHeight / 2);
      scrubberDrawable.draw(canvas);
    }
  }

  protected void updateDrawableState() {
    if (scrubberDrawable != null
            && scrubberDrawable.isStateful()
            && scrubberDrawable.setState(getDrawableState())) {
      invalidate();
    }
  }

  @RequiresApi(29)
  protected void setSystemGestureExclusionRectsV29(int width, int height) {
    if (lastExclusionRectangle != null
            && lastExclusionRectangle.width() == width
            && lastExclusionRectangle.height() == height) {
      // Allocating inside onLayout is considered a DrawAllocation lint error, so avoid if possible.
      return;
    }
    lastExclusionRectangle = new Rect(/* left= */ 0, /* top= */ 0, width, height);
    setSystemGestureExclusionRects(Collections.singletonList(lastExclusionRectangle));
  }

  protected String getProgressText() {
    return Util.getStringForTime(formatBuilder, formatter, position);
  }

  protected long getPositionIncrement() {
    return keyTimeIncrement == C.TIME_UNSET
            ? (duration == C.TIME_UNSET ? 0 : (duration / keyCountIncrement))
            : keyTimeIncrement;
  }

  protected boolean setDrawableLayoutDirection(Drawable drawable) {
    return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, getLayoutDirection());
  }

  protected static boolean setDrawableLayoutDirection(Drawable drawable, int layoutDirection) {
    return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection);
  }

  protected static int dpToPx(float density, int dps) {
    return (int) (dps * density + 0.5f);
  }

  protected static int pxToDp(float density, int px) {
    return (int) (px / density);
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/VideoGestureDetector.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.mediastore.video.customexo;

import android.content.Context;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ViewConfiguration;

import androidx.annotation.NonNull;

public class VideoGestureDetector {
    private final OnVideoGestureListener mListener;
    private final GestureDetector mDetector;

    private boolean mIsHorizontallyScrubbing;
    private boolean mIsVerticallyScrubbing;
    private final float mTouchSlop;
    /**
     * Position of the last motion event.
     */
    private float mLastMotionX;
    private float mLastMotionY;
    private float mInitialMotionX;
    private float mInitialMotionY;
    /**
     * ID of the active pointer. This is used to retain consistency during
     * drags/flings if multiple pointers are used.
     */
    private int mActivePointerId = INVALID_POINTER;
    /**
     * Sentinel value for no current active pointer.
     * Used by {@link #mActivePointerId}.
     */
    private static final int INVALID_POINTER = -1;

    public VideoGestureDetector(@NonNull Context context,
                                @NonNull OnVideoGestureListener listener) {
        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = configuration.getScaledTouchSlop();
        mListener = listener;
        final GestureDetector.SimpleOnGestureListener onDoubleTapListener
                = new GestureDetector.SimpleOnGestureListener() {
            @Override
            public boolean onSingleTapConfirmed(@NonNull MotionEvent e) {
                return mListener.onSingleTapConfirmed(e);
            }

            @Override
            public boolean onDoubleTap(@NonNull MotionEvent ev) {
                return mListener.onDoubleTap(ev);
            }
        };
        mDetector = new GestureDetector(context, onDoubleTapListener);
    }

    private void resetTouch() {
        mActivePointerId = INVALID_POINTER;
        mIsHorizontallyScrubbing = false;
        mIsVerticallyScrubbing = false;
    }

    private boolean onTouchEventInternal(@NonNull MotionEvent ev) {
        boolean handled = false;
        switch (ev.getActionMasked()) {
            case MotionEvent.ACTION_DOWN: {
                // Remember where the motion event started
                mLastMotionX = mInitialMotionX = ev.getX();
                mLastMotionY = mInitialMotionY = ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                if (!mIsHorizontallyScrubbing && !mIsVerticallyScrubbing) {
                    final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                    if (pointerIndex == -1) {
                        // A child has consumed some touch events and put us into an inconsistent
                        // state.
                        resetTouch();
                        break;
                    }
                    final float x = ev.getX(pointerIndex);
                    final float xDiff = Math.abs(x - mLastMotionX);
                    final float y = ev.getY(pointerIndex);
                    final float yDiff = Math.abs(y - mLastMotionY);
                    if (xDiff > mTouchSlop && xDiff > yDiff) {
                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :
                                mInitialMotionX - mTouchSlop;
                        mIsHorizontallyScrubbing = true;
                        mListener.onHorizontalScrubStart(mInitialMotionX, mInitialMotionY);
                    } else if (yDiff > mTouchSlop && yDiff > xDiff) {
                        mLastMotionY = y - mInitialMotionY > 0 ? mInitialMotionY + mTouchSlop :
                                mInitialMotionY - mTouchSlop;
                        mIsVerticallyScrubbing = true;
                        mListener.onVerticalScrubStart(mInitialMotionX, mInitialMotionY);
                    }
                }
                // Not else! Note that mIsBeingDragged can be set above.
                if (mIsHorizontallyScrubbing) {
                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                    final float x = ev.getX(activePointerIndex);
                    final float y = ev.getY(activePointerIndex);
                    handled |= mListener.onHorizontalScrubMove(x - mLastMotionX);
                    mLastMotionX = x;
                    mLastMotionY = y;
                }
                if (mIsVerticallyScrubbing) {
                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                    final float x = ev.getX(activePointerIndex);
                    final float y = ev.getY(activePointerIndex);
                    handled |= mListener.onVerticalScrubMove(y - mLastMotionY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                }
                break;
            }
            case MotionEvent.ACTION_POINTER_DOWN: {
                final int index = ev.getActionIndex();
                final float x = ev.getX(index);
                mLastMotionX = x;
                final float y = ev.getY(index);
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(index);
                break;
            }
            case MotionEvent.ACTION_POINTER_UP: {
                final int pointerIndex = ev.getActionIndex();
                final int pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == mActivePointerId) {
                    // This was our active pointer going up. Choose a new
                    // active pointer and adjust accordingly.
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mLastMotionX = ev.getX(newPointerIndex);
                    mLastMotionY = ev.getY(newPointerIndex);
                    mActivePointerId = ev.getPointerId(newPointerIndex);
                }
                break;
            }
            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP: {
                if (mIsHorizontallyScrubbing) {
                    handled = true;
                    mListener.onHorizontalScrubEnd();
                }
                if (mIsVerticallyScrubbing) {
                    handled = true;
                    mListener.onVerticalScrubEnd();
                }
                resetTouch();
                break;
            }
        }
        return handled;
    }

    public boolean onTouchEvent(@NonNull MotionEvent ev) {
        mDetector.onTouchEvent(ev);
        return onTouchEventInternal(ev);
    }

    public interface OnVideoGestureListener {

        void onHorizontalScrubStart(float initialMotionX, float initialMotionY);

        boolean onHorizontalScrubMove(float dx);

        void onHorizontalScrubEnd();

        void onVerticalScrubStart(float initialMotionX, float initialMotionY);

        boolean onVerticalScrubMove(float dy);

        void onVerticalScrubEnd();

        boolean onSingleTapConfirmed(@NonNull MotionEvent ev);

        boolean onDoubleTap(@NonNull MotionEvent ev);
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/BinderViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module

import android.content.pm.PackageInfo
import android.os.IBinder
import android.os.Process
import android.util.SparseArray
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import me.gm.cleaner.plugin.IManagerService
import me.gm.cleaner.plugin.IMediaChangeObserver
import javax.inject.Inject

@HiltViewModel
class BinderViewModel @Inject constructor(private val binder: IBinder?) : ViewModel() {
    private var service: IManagerService? = IManagerService.Stub.asInterface(binder)
    private val _remoteSpCacheLiveData = MutableLiveData(SparseArray<String>())
    val remoteSpCacheLiveData: LiveData<SparseArray<String>>
        get() = _remoteSpCacheLiveData
    val remoteSpCache: SparseArray<String>
        get() = _remoteSpCacheLiveData.value!!

    fun notifyRemoteSpChanged() {
        _remoteSpCacheLiveData.postValue(remoteSpCache)
    }

    fun pingBinder() = binder?.pingBinder() == true

    val moduleVersion: Int
        get() = service!!.moduleVersion

    fun getInstalledPackages(flags: Int): List<PackageInfo> =
        service!!.getInstalledPackages(Process.myUid() / AID_USER_OFFSET, flags).list

    fun getPackageInfo(packageName: String): PackageInfo? =
        service!!.getPackageInfo(packageName, 0, Process.myUid() / AID_USER_OFFSET)

    fun readSp(who: Int): String? =
        remoteSpCache[who, service!!.readSp(who).also { remoteSpCache.put(who, it) }]

    fun writeSp(who: Int, what: String) {
        if (remoteSpCache[who] != what) {
            service!!.writeSp(who, what)
            remoteSpCache.put(who, what)
            notifyRemoteSpChanged()
        }
    }

    fun clearAllTables() {
        service!!.clearAllTables()
    }

    fun packageUsageTimes(operation: Int, packageNames: List<String>): Int =
        service!!.packageUsageTimes(operation, packageNames)

    fun registerMediaChangeObserver(observer: IMediaChangeObserver) {
        service!!.registerMediaChangeObserver(observer)
    }

    fun unregisterMediaChangeObserver(observer: IMediaChangeObserver) {
        service!!.unregisterMediaChangeObserver(observer)
    }

    companion object {
        const val AID_USER_OFFSET = 100000
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/ModuleFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ModuleFragmentBinding

abstract class ModuleFragment : BaseFragment() {
    val binderViewModel: BinderViewModel by activityViewModels()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        check(!binderViewModel.pingBinder())
        val binding = ModuleFragmentBinding.inflate(layoutInflater)
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppAdapters.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.annotation.SuppressLint
import android.content.Intent
import android.net.Uri
import android.provider.Settings
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.forEach
import androidx.core.view.isVisible
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.transition.platform.Hold
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.databinding.AppHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesItemBinding
import me.gm.cleaner.plugin.ktx.DividerViewHolder
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.settings.CreateTemplateFragment

class AppHeaderAdapter(private val fragment: AppFragment) :
    RecyclerView.Adapter<AppHeaderAdapter.ViewHolder>() {
    private val args: AppFragmentArgs by fragment.navArgs()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(AppHeaderBinding.inflate(LayoutInflater.from(parent.context)))

    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        Glide.with(fragment)
            .load(args.packageInfo)
            .into(binding.icon)
        binding.labelVersion.text = "${args.label} ${args.packageInfo.versionName}"
        binding.packageName.text = args.packageInfo.packageName
        binding.sdk.text = "SDK ${args.packageInfo.applicationInfo.targetSdkVersion}"
        binding.sdk.setOnClickListener {
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = Uri.fromParts("package", args.packageInfo.packageName, null)
            }
            fragment.startActivity(intent)
        }
        val usageTimes = arrayOf(
            OP_QUERY to R.string.query_times,
            OP_INSERT to R.string.insert_times,
            OP_DELETE to R.string.delete_times,
        ).mapNotNull { (op, resId) ->
            val packageUsageTimes = fragment.binderViewModel.packageUsageTimes(
                op, listOf(args.packageInfo.packageName)
            )
            if (packageUsageTimes == 0) {
                null
            } else {
                fragment.getString(resId, packageUsageTimes)
            }
        }
        if (usageTimes.isNotEmpty()) {
            binding.usageTimes.isVisible = true
            binding.usageTimes.text = usageTimes.joinToString(
                fragment.getString(R.string.delimiter)
            )
        }
    }

    override fun getItemCount(): Int = 1

    class ViewHolder(val binding: AppHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedBelow = true
        }
    }
}

class TemplatesAdapter(private val fragment: AppFragment) :
    ListAdapter<Template, TemplatesAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesItemBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = templateName
        binding.summary.text = fragment.getString(
            R.string.applied_app_count, item.applyToApp?.size ?: 0
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.app_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = templateName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)

            val direction = AppFragmentDirections.actionAppToCreateTemplate(templateName)
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            activity.menuInflater.inflate(R.menu.app_item, menu)
            menu.setHeaderTitle(templateName)
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    when (item.itemId) {
                        R.id.menu_remove_from_template -> {
                            val modified =
                                Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                    .values.toMutableList()
                            val oldTemplateIndex =
                                modified.indexOfFirst { it.templateName == templateName }
                            val oldTemplate = modified[oldTemplateIndex]
                            modified[oldTemplateIndex] = oldTemplate.copy(
                                applyToApp = (oldTemplate.applyToApp ?: emptyList()) -
                                        fragment.args.packageInfo.packageName
                            )
                            fragment.binderViewModel.writeSp(
                                R.xml.template_preferences, Gson().toJson(modified)
                            )
                            true
                        }

                        R.id.menu_delete -> {
                            val modified =
                                Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                    .values.filterNot { it.templateName == templateName }
                            fragment.binderViewModel.writeSp(
                                R.xml.template_preferences, Gson().toJson(modified)
                            )
                            true
                        }

                        else -> {
                            false
                        }
                    }
                }
            }
        }
        holder.isDividerAllowedBelow = position == itemCount - 1

        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }

    class ViewHolder(val binding: TemplatesItemBinding) : DividerViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName

            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}

class CreateTemplateAdapter(private val fragment: AppFragment) :
    RecyclerView.Adapter<CreateTemplateAdapter.ViewHolder>() {
    private val args: AppFragmentArgs by fragment.navArgs()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        binding.root.transitionName = args.label
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.app_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = args.label
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)

            val direction = AppFragmentDirections.actionAppToCreateTemplate(
                templateName = args.label,
                packageNames = arrayOf(args.packageInfo.packageName),
            )
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }

        if (fragment.lastTemplateName == CreateTemplateFragment.NULL_TEMPLATE_NAME) {
            fragment.startPostponedEnterTransition()
        }
    }

    override fun getItemCount(): Int = 1

    class ViewHolder(val binding: TemplatesHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedAbove = true
        }
    }
}

class AddToExistingTemplateAdapter(private val fragment: AppFragment) :
    ListAdapter<Template, AddToExistingTemplateAdapter.ViewHolder>(CALLBACK) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = fragment.getString(
            R.string.add_to_existing_template_title, templateName
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val modified = Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                .values.toMutableList()
            val oldTemplateIndex = modified.indexOfFirst { it.templateName == templateName }
            val oldTemplate = modified[oldTemplateIndex]
            modified[oldTemplateIndex] = oldTemplate.copy(
                applyToApp = mutableListOf(fragment.args.packageInfo.packageName) +
                        (oldTemplate.applyToApp ?: emptyList())
            )
            fragment.binderViewModel.writeSp(
                R.xml.template_preferences, Gson().toJson(modified)
            )
        }

        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }

    class ViewHolder(val binding: TemplatesHeaderBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName

            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.app.SharedElementCallback
import androidx.core.os.bundleOf
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.setFragmentResultListener
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.ConcatAdapter
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.MaterialContainerTransform
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.AppFragmentBinding
import me.gm.cleaner.plugin.ktx.DividerDecoration
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.isItemCompletelyInvisible
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.ui.module.settings.CreateTemplateFragment
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference

class AppFragment : ModuleFragment() {
    val args: AppFragmentArgs by navArgs()
    var lastTemplateName: String? = null

    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = AppFragmentBinding.inflate(layoutInflater)

        val templatesAdapter = TemplatesAdapter(this)
        val createTemplateAdapter = CreateTemplateAdapter(this)
        val addToExistingTemplateAdapter = AddToExistingTemplateAdapter(this)
        val adapters = ConcatAdapter(
            AppHeaderAdapter(this),
            templatesAdapter,
            createTemplateAdapter,
            addToExistingTemplateAdapter
        )
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapters
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                super.onScrolled(recyclerView, dx, dy)
                supportActionBar?.title = if (recyclerView.isItemCompletelyInvisible(0)) {
                    args.label
                } else {
                    findNavController().currentDestination?.label
                }
            }
        })
        binding.root.fitsSystemWindowInsets()
        // Don't add systemWindowInsetTop to RecyclerView for a better SharedElementTransition.
        list.setOnApplyWindowInsetsListener { view, insets ->
            view.setPadding(
                view.paddingLeft, view.paddingTop,
                view.paddingRight, view.paddingBottom + insets.systemWindowInsetBottom
            )
            insets
        }
        list.addItemDecoration(DividerDecoration(list).apply {
            setDivider(resources.getDrawable(R.drawable.list_divider_material, null))
            setAllowDividerAfterLastItem(false)
        })

        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            val currentList = prepareCurrentList()
            templatesAdapter.submitList(currentList.first)
            addToExistingTemplateAdapter.submitList(currentList.second)
            if (currentList.first.any { it.templateName == args.label }) {
                adapters.removeAdapter(createTemplateAdapter)
            } else {
                adapters.addAdapter(
                    adapters.adapters.indexOfFirst { it is TemplatesAdapter } + 1,
                    createTemplateAdapter
                )
            }
        }

        prepareSharedElementTransition(list)
        setFragmentResultListener(CreateTemplateFragment::class.java.name) { _, bundle ->
            lastTemplateName = bundle.getString(CreateTemplateFragment.KEY_TEMPLATE_NAME)
            val currentList = prepareCurrentList()
            var position = 1 +
                    currentList.first.indexOfFirst { it.templateName == lastTemplateName }
            if (position == 0) {
                position = 1 + currentList.first.size + 1 +
                        currentList.second.indexOfFirst { it.templateName == lastTemplateName }
            }
            prepareTransitions(list, position)
            postponeEnterTransition()
            scrollToPosition(list, position)
        }
        return binding.root
    }

    private fun prepareCurrentList(): Pair<List<Template>, List<Template>> =
        Templates(binderViewModel.readSp(R.xml.template_preferences)).values
            .sortedWith(collatorComparator { it.templateName })
            .partition { it.applyToApp?.contains(args.packageInfo.packageName) == true }

    private fun prepareTransitions(list: RecyclerView, position: Int) {
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val selectedViewHolder = list.findViewHolderForAdapterPosition(position) ?: return
                sharedElements[names[0]] = selectedViewHolder.itemView
            }
        })
    }

    private fun prepareSharedElementTransition(list: RecyclerView) {
        setFragmentResult(
            AppFragment::class.java.name, bundleOf(KEY_PACKAGENAME to args.packageInfo.packageName)
        )
        list.transitionName = args.packageInfo.packageName

        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }

        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    sharedElements[names[0]] = list
                }
            }
        })
    }

    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            // Scroll to position if the view for the current position is null (not currently part of
            // layout manager children), or it's not completely visible.
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }

    companion object {
        const val KEY_PACKAGENAME = "me.gm.cleaner.plugin.key.packageName"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.ApplistItemBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.mediumAnimTime

class AppListAdapter(private val fragment: AppListFragment) :
    ListAdapter<AppListModel, AppListAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(ApplistItemBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val model = getItem(position)
        Glide.with(fragment)
            .load(model.packageInfo)
            .into(binding.icon)
        binding.title.text = model.label
        binding.summary.text = if (model.ruleCount > 0) {
            activity.buildSpannableString(
                fragment.getString(R.string.enabled_rule_count, model.ruleCount)
            )
        } else {
            model.packageInfo.packageName
        }
        binding.root.transitionName = model.packageInfo.packageName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.applist_fragment) {
                return@setOnClickListener
            }
            fragment.enterPackageName = model.packageInfo.packageName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }

            val direction = AppListFragmentDirections.actionApplistToApp(
                packageInfo = model.packageInfo,
                label = model.label,
            )
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }

        if (fragment.enterPackageName == model.packageInfo.packageName) {
            fragment.startPostponedEnterTransition()
        }
    }

    class ViewHolder(val binding: ApplistItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<AppListModel>() {
            override fun areItemsTheSame(oldItem: AppListModel, newItem: AppListModel): Boolean =
                oldItem.packageInfo.packageName == newItem.packageInfo.packageName

            override fun areContentsTheSame(oldItem: AppListModel, newItem: AppListModel): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.app.Application
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.setFragmentResultListener
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_APP_NAME
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_UPDATE_TIME
import me.gm.cleaner.plugin.databinding.ApplistFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.submitListKeepPosition
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.widget.FixQueryChangeSearchView
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference

class AppListFragment : ModuleFragment() {
    private val viewModel: AppListViewModel by viewModels(
        factoryProducer = {
            AppListViewModel.provideFactory(
                requireContext().applicationContext as Application,
                binderViewModel
            )
        }
    )
    var enterPackageName: String? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        if (!binderViewModel.pingBinder()) {
            return super.onCreateView(inflater, container, savedInstanceState)
        }
        val binding = ApplistFragmentBinding.inflate(layoutInflater)

        val adapter = AppListAdapter(this)
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .build()
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets(fastScroller)
        binding.listContainer.setOnRefreshListener {
            viewModel.load(null)
        }

        // Start a coroutine in the lifecycle scope
        lifecycleScope.launch {
            // repeatOnLifecycle launches the block in a new coroutine every time the
            // lifecycle is in the STARTED state (or above) and cancels it when it's STOPPED.
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                // Trigger the flow and start listening for values.
                // Note that this happens when lifecycle is STARTED and stops
                // collecting when the lifecycle is STOPPED
                viewModel.appsFlow.collect { apps ->
                    // New value received
                    when (apps) {
                        is AppListState.Loading -> binding.progress.progress = apps.progress
                        is AppListState.Done -> adapter.submitListKeepPosition(apps.list, list) {
                            binding.progress.hide()
                            binding.listContainer.isRefreshing = false
                        }
                    }
                }
            }
        }
        setFragmentResultListener(AppFragment::class.java.name) { _, bundle ->
            enterPackageName = bundle.getString(AppFragment.KEY_PACKAGENAME)
            postponeEnterTransition()
        }

        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            viewModel.update()
        }
        return binding.root
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (!binderViewModel.pingBinder()) {
            return
        }
        inflater.inflate(R.menu.applist_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                viewModel.queryText = ""
                return true
            }

            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as FixQueryChangeSearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }

            override fun onQueryTextChange(newText: String): Boolean {
                if (!searchView.shouldIgnoreQueryChange) {
                    viewModel.queryText = newText
                }
                return false
            }
        })

        when (RootPreferences.sortByFlowable.value) {
            SORT_BY_APP_NAME ->
                menu.findItem(R.id.menu_sort_by_app_name).isChecked = true

            SORT_BY_UPDATE_TIME ->
                menu.findItem(R.id.menu_sort_by_update_time).isChecked = true
        }
        menu.findItem(R.id.menu_rule_count).isChecked = RootPreferences.ruleCountFlowable.value
        menu.findItem(R.id.menu_hide_system_app).isChecked =
            RootPreferences.isHideSystemAppFlowable.value
        arrayOf(
            menu.findItem(R.id.menu_header_sort), menu.findItem(R.id.menu_header_hide)
        ).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_app_name -> {
                item.isChecked = true
                RootPreferences.sortByFlowable.value = SORT_BY_APP_NAME
            }

            R.id.menu_sort_by_update_time -> {
                item.isChecked = true
                RootPreferences.sortByFlowable.value = SORT_BY_UPDATE_TIME
            }

            R.id.menu_rule_count -> {
                val ruleCount = !item.isChecked
                item.isChecked = ruleCount
                RootPreferences.ruleCountFlowable.value = ruleCount
            }

            R.id.menu_hide_system_app -> {
                val isHideSystemApp = !item.isChecked
                item.isChecked = isHideSystemApp
                RootPreferences.isHideSystemAppFlowable.value = isHideSystemApp
            }

            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListLoader.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.content.pm.PackageManager
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ensureActive
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import java.util.concurrent.atomic.AtomicInteger

class AppListLoader(private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default) {

    private fun fetchRuleCount(templates: Templates): Map<String, Int> {
        val map = mutableMapOf<String, Int>()
        templates.values.forEach { templateName ->
            templateName.applyToApp?.forEach { packageName ->
                map[packageName] = map.getOrDefault(packageName, 0) + 1
            }
        }
        return map
    }

    suspend fun load(
        binderViewModel: BinderViewModel, pm: PackageManager, l: ProgressListener?
    ) = withContext(defaultDispatcher) {
        val packageNameToRuleCount =
            fetchRuleCount(Templates(binderViewModel.readSp(R.xml.template_preferences)))
        val installedPackages = binderViewModel.getInstalledPackages(PackageManager.GET_PERMISSIONS)
        val size = installedPackages.size
        val count = AtomicInteger(0)
        installedPackages.map { pi ->
            ensureActive()
            l?.onProgress(100 * count.incrementAndGet() / size)
            AppListModel(
                pi,
                pm.getApplicationLabel(pi.applicationInfo).toString(),
                packageNameToRuleCount.getOrDefault(pi.packageName, 0),
            )
        }
    }

    suspend fun update(old: List<AppListModel>, binderViewModel: BinderViewModel) =
        withContext(defaultDispatcher) {
            val packageNameToRuleCount =
                fetchRuleCount(Templates(binderViewModel.readSp(R.xml.template_preferences)))
            old.map {
                it.copy(
                    ruleCount = packageNameToRuleCount.getOrDefault(it.packageInfo.packageName, 0)
                )
            }
        }

    interface ProgressListener {
        fun onProgress(progress: Int)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListModel.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.content.pm.PackageInfo

data class AppListModel(
    val packageInfo: PackageInfo,
    val label: String,
    val ruleCount: Int,
) {

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AppListModel

        if (label != other.label) return false
        if (ruleCount != other.ruleCount) return false

        return true
    }

    override fun hashCode(): Int {
        var result = label.hashCode()
        result = 31 * result + ruleCount
        return result
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.appmanagement

import android.app.Application
import android.content.pm.ApplicationInfo
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_APP_NAME
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_UPDATE_TIME
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import me.gm.cleaner.plugin.util.collatorComparator

class AppListViewModel(
    application: Application,
    private val binderViewModel: BinderViewModel
) : AndroidViewModel(application) {
    private val _isSearchingFlow = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    private val _queryTextFlow = MutableStateFlow("")
    var queryText: String by _queryTextFlow
    val isLoading: Boolean
        get() = _appsFlow.value is AppListState.Loading
    private val _appsFlow = MutableStateFlow<AppListState>(AppListState.Loading(0))
    val appsFlow =
        combine(
            _appsFlow,
            _isSearchingFlow,
            _queryTextFlow,
            RootPreferences.isHideSystemAppFlowable.asFlow(),
            RootPreferences.sortByFlowable.asFlow(),
            RootPreferences.ruleCountFlowable.asFlow(),
        ) { apps, isSearching, queryText, isHideSystemApp, sortBy, ruleCount ->
            when (apps) {
                is AppListState.Loading -> AppListState.Loading(apps.progress)
                is AppListState.Done -> {
                    var sequence = apps.list.asSequence()
                    if (isHideSystemApp) {
                        sequence = sequence.filter {
                            it.packageInfo.applicationInfo.flags and ApplicationInfo.FLAG_SYSTEM == 0
                        }
                    }
                    if (isSearching) {
                        sequence = sequence.filter {
                            it.label.contains(queryText, true) ||
                                    it.packageInfo.packageName.contains(queryText, true)
                        }
                    }
                    sequence = when (sortBy) {
                        SORT_BY_APP_NAME -> {
                            sequence.sortedWith(collatorComparator { it.label })
                        }

                        SORT_BY_UPDATE_TIME -> sequence.sortedBy {
                            -it.packageInfo.lastUpdateTime
                        }

                        else -> throw IllegalArgumentException()
                    }
                    if (ruleCount) {
                        sequence = sequence.sortedBy { -it.ruleCount }
                    }
                    AppListState.Done(sequence.toList())
                }
            }
        }

    fun load(
        l: AppListLoader.ProgressListener? = object : AppListLoader.ProgressListener {
            override fun onProgress(progress: Int) {
                _appsFlow.value = AppListState.Loading(progress)
            }
        }
    ) {
        viewModelScope.launch {
            _appsFlow.value = AppListState.Loading(0)
            val list = AppListLoader().load(
                binderViewModel, getApplication<Application>().packageManager, l
            )
            _appsFlow.value = AppListState.Done(list)
        }
    }

    fun update() {
        viewModelScope.launch {
            if (!isLoading) {
                val list = AppListLoader().update(
                    (_appsFlow.value as AppListState.Done).list, binderViewModel
                )
                _appsFlow.value = AppListState.Loading(0)
                _appsFlow.value = AppListState.Done(list)
            }
        }
    }

    init {
        load()
    }

    companion object {
        fun provideFactory(
            application: Application, binderViewModel: BinderViewModel
        ): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            @Suppress("UNCHECKED_CAST")
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                return AppListViewModel(application, binderViewModel) as T
            }
        }
    }
}

sealed class AppListState {
    data class Loading(val progress: Int) : AppListState()
    data class Done(val list: List<AppListModel>) : AppListState()
}

fun <T1, T2, T3, T4, T5, T6, R> combine(
    flow: Flow<T1>, flow2: Flow<T2>, flow3: Flow<T3>, flow4: Flow<T4>, flow5: Flow<T5>,
    flow6: Flow<T6>, transform: suspend (T1, T2, T3, T4, T5, T6) -> R
): Flow<R> = combine(flow, flow2, flow3, flow4, flow5, flow6) { args: Array<*> ->
    transform(
        args[0] as T1, args[1] as T2, args[2] as T3, args[3] as T4, args[4] as T5, args[5] as T6
    )
}

fun <T1, T2, T3, T4, T5, T6, T7, R> combine(
    flow: Flow<T1>, flow2: Flow<T2>, flow3: Flow<T3>, flow4: Flow<T4>, flow5: Flow<T5>,
    flow6: Flow<T6>, flow7: Flow<T7>, transform: suspend (T1, T2, T3, T4, T5, T6, T7) -> R
): Flow<R> = combine(flow, flow2, flow3, flow4, flow5, flow6, flow7) { args: Array<*> ->
    transform(
        args[0] as T1, args[1] as T2, args[2] as T3, args[3] as T4, args[4] as T5, args[5] as T6,
        args[6] as T7
    )
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/AbsSettingsFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import androidx.preference.Preference
import androidx.preference.PreferenceFragmentCompat
import androidx.preference.PreferenceGroupAdapter
import androidx.preference.PreferenceManager
import androidx.preference.PreferenceScreen
import androidx.preference.PreferenceViewHolder
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.setObjectField
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import rikka.recyclerview.fixEdgeEffect

@SuppressLint("RestrictedApi")
abstract class AbsSettingsFragment : PreferenceFragmentCompat() {
    protected val binderViewModel: BinderViewModel by activityViewModels()
    abstract val who: Int
    protected val remoteSp by lazy { BinderSpImpl(binderViewModel, who) }

    open fun onCreatePreferenceManager(savedInstanceState: Bundle?) =
        object : PreferenceManager(requireContext()) {
            override fun getSharedPreferences() = remoteSp
        }

    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setObjectField(
            onCreatePreferenceManager(savedInstanceState), PreferenceFragmentCompat::class.java
        )
    }

    override fun onCreateRecyclerView(
        inflater: LayoutInflater, parent: ViewGroup, savedInstanceState: Bundle?
    ): RecyclerView {
        val list = super.onCreateRecyclerView(inflater, parent, savedInstanceState)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        return list
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        requireActivity()
            .findViewById<AppBarLayout>(R.id.toolbar_container)
            .setLiftOnScrollTargetView(listView)
    }

    override fun onCreateAdapter(preferenceScreen: PreferenceScreen): RecyclerView.Adapter<*> {
        return object : PreferenceGroupAdapter(preferenceScreen) {
            override fun onBindViewHolder(holder: PreferenceViewHolder, position: Int) {
                val preference = getItem(position)!!
                preference.onBindViewHolder(holder)
                onBindPreferencesViewHolder(holder, preference)
            }
        }
    }

    open fun onBindPreferencesViewHolder(holder: PreferenceViewHolder, preference: Preference) {}
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/BinderSpImpl.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings;

import org.json.JSONException;

import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl;
import me.gm.cleaner.plugin.ui.module.BinderViewModel;

public final class BinderSpImpl extends JsonSharedPreferencesImpl {
    public final int who;
    private final BinderViewModel mBinderViewModel;

    public BinderSpImpl(BinderViewModel binderViewModel, int who) throws JSONException {
        super(binderViewModel.readSp(who));
        mBinderViewModel = binderViewModel;
        this.who = who;
    }

    @Override
    public JsonEditorImpl edit() {
        return new JsonEditorImpl(jsonObject -> {
            mBinderViewModel.writeSp(who, jsonObject.toString());
            return true;
        });
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/CreateTemplateFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.SharedElementCallback
import androidx.core.content.edit
import androidx.core.os.bundleOf
import androidx.fragment.app.setFragmentResult
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.navigation.fragment.navArgs
import androidx.preference.EditTextPreference
import androidx.preference.MultiSelectListPreference
import androidx.preference.Preference
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.transition.platform.MaterialContainerTransform
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.settings.preference.AppListMultiSelectListPreference
import me.gm.cleaner.plugin.ui.module.settings.preference.MaterialEditTextPreferenceDialogFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.MaterialMultiSelectListPreferenceDialogFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreference
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreferenceFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.RefinedMultiSelectListPreference
import kotlin.collections.set

class CreateTemplateFragment : AbsSettingsFragment() {
    override val who: Int
        get() = R.xml.template_preferences

    private val args: CreateTemplateFragmentArgs by navArgs()
    private val lastTemplateName by lazy { bundleOf(KEY_TEMPLATE_NAME to currentTemplateName) }
    private lateinit var tempSp: JsonSharedPreferencesImpl
    private val currentTemplateName: String
        get() = tempSp.getString(getString(R.string.template_name_key), NULL_TEMPLATE_NAME)!!

    @SuppressLint("RestrictedApi")
    override fun onCreatePreferenceManager(savedInstanceState: Bundle?) =
        object : PreferenceManager(requireContext()) {
            override fun getSharedPreferences(): SharedPreferences {
                if (!::tempSp.isInitialized) {
                    tempSp = try {
                        JsonSharedPreferencesImpl(
                            Gson().toJson(
                                Templates(binderViewModel.readSp(R.xml.template_preferences)).values.first {
                                    it.templateName == if (savedInstanceState == null) args.templateName
                                    else savedInstanceState.getString(KEY_TEMPLATE_NAME)
                                }
                            )
                        )
                    } catch (e: NoSuchElementException) {
                        JsonSharedPreferencesImpl()
                    }.apply {
                        if (savedInstanceState == null) {
                            edit {
                                putString(getString(R.string.template_name_key), args.templateName)
                            }
                        }
                    }
                }
                return tempSp
            }
        }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString(KEY_TEMPLATE_NAME, currentTemplateName)
    }

    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        super.onCreatePreferences(savedInstanceState, rootKey)
        setPreferencesFromResource(R.xml.template_preferences, rootKey)

        val templateName = getString(R.string.template_name_key)
        findPreference<EditTextPreference>(templateName)?.onPreferenceChangeListener =
            Preference.OnPreferenceChangeListener { _, newValue ->
                when {
                    args.templateName == newValue as String -> false
                    Templates(binderViewModel.readSp(R.xml.template_preferences)).values
                        .any { it.templateName == newValue } -> {
                        Snackbar.make(
                            requireView(), R.string.template_name_not_unique, Snackbar.LENGTH_SHORT
                        ).show()
                        false
                    }

                    else -> {
                        lastTemplateName.putString(KEY_TEMPLATE_NAME, newValue)
                        true
                    }
                }
            }

        args.hookOperation?.let {
            val hookOperation = getString(R.string.hook_operation_key)
            findPreference<RefinedMultiSelectListPreference>(hookOperation)
                ?.values = it.toSet()
        }

        val applyToApp = getString(R.string.apply_to_app_key)
        findPreference<AppListMultiSelectListPreference>(applyToApp)
            ?.loadApps { binderViewModel.getInstalledPackages(0) }
            ?.setOnAppsLoadedListener { preference ->
                args.packageNames?.let {
                    preference.values = preference.values + it
                }
            }

        args.permittedMediaTypes?.let {
            val permittedMediaTypes = getString(R.string.permitted_media_types_key)
            findPreference<RefinedMultiSelectListPreference>(permittedMediaTypes)
                ?.values = it.toSet()
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ) = super.onCreateView(inflater, container, savedInstanceState)
        .apply { prepareSharedElementTransition(listView) }

    private fun prepareSharedElementTransition(list: RecyclerView) {
        setFragmentResult(CreateTemplateFragment::class.java.name, lastTemplateName)

        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }

        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    list.transitionName = currentTemplateName
                    sharedElements[names[0]] = list
                }
            }
        })
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (args.templateName != null && args.packageNames == null) {
            (requireActivity() as AppCompatActivity).supportActionBar?.setTitle(R.string.edit_template_title)
        }
    }

    override fun onDisplayPreferenceDialog(preference: Preference) {
        val f = when (preference) {
            is EditTextPreference -> MaterialEditTextPreferenceDialogFragmentCompat
                .newInstance(preference.key)

            is MultiSelectListPreference -> MaterialMultiSelectListPreferenceDialogFragmentCompat
                .newInstance(preference.key)

            is PathListPreference -> PathListPreferenceFragmentCompat.newInstance(preference.key)
            else -> {
                super.onDisplayPreferenceDialog(preference)
                return
            }
        }
        f.setTargetFragment(this, 0)
        f.show(parentFragmentManager, DIALOG_FRAGMENT_TAG)
    }

    override fun onStop() {
        super.onStop()
        save()
    }

    private fun save(): Boolean {
        val templateName = tempSp.getString(getString(R.string.template_name_key), null)
        val hookOperationValues =
            findPreference<MultiSelectListPreference>(getString(R.string.hook_operation_key))?.values
        if (!templateName.isNullOrEmpty() && hookOperationValues?.isNotEmpty() == true) {
            val template = Gson().fromJson(tempSp.delegate.toString(), Template::class.java)
            val json = Gson().toJson(
                Templates(binderViewModel.readSp(R.xml.template_preferences)).values.filterNot {
                    it.templateName == templateName || it.templateName == args.templateName
                } + template
            )
            binderViewModel.writeSp(who, json)
        }
        return true
    }

    companion object {
        const val KEY_TEMPLATE_NAME = "me.gm.cleaner.plugin.key.templateName"
        const val NULL_TEMPLATE_NAME = "@null"
        private const val DIALOG_FRAGMENT_TAG = "androidx.preference.PreferenceFragment.DIALOG"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/SettingsFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.setFragmentResultListener
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder
import androidx.preference.SwitchPreferenceCompat
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.mediumAnimTime

class SettingsFragment : AbsSettingsFragment() {
    override val who: Int
        get() = R.xml.root_preferences

    var enterKey: String? = null

    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        super.onCreatePreferences(savedInstanceState, rootKey)
        setPreferencesFromResource(R.xml.root_preferences, rootKey)

        val usageRecord = getString(R.string.usage_record_key)
        findPreference<SwitchPreferenceCompat>(usageRecord)?.isChecked =
            remoteSp.getBoolean(usageRecord, true)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View = super.onCreateView(inflater, container, savedInstanceState).also {
        parentFragment?.setFragmentResultListener(TemplatesFragment::class.java.name) { _, bundle ->
            enterKey = bundle.getString(TemplatesFragment.KEY)
            parentFragment?.postponeEnterTransition()
        }
    }

    override fun onBindPreferencesViewHolder(holder: PreferenceViewHolder, preference: Preference) {
        val itemView = holder.itemView
        when (preference.key) {
            getString(R.string.template_management_key) -> {
                itemView.transitionName = preference.key
                itemView.setOnClickListener {
                    val navController = findNavController()
                    if (navController.currentDestination?.id != R.id.settings_fragment) {
                        return@setOnClickListener
                    }
                    enterKey = preference.key
                    parentFragment?.exitTransition = Hold().apply {
                        duration = requireContext().mediumAnimTime
                    }

                    val direction = SettingsFragmentStubDirections.actionSettingsToTemplates()
                    val extras = FragmentNavigatorExtras(it to it.transitionName)
                    navController.navigate(direction, extras)
                }
                parentFragment?.startPostponedEnterTransition()
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/SettingsFragmentStub.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.fragment.app.commit
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.SettingsFragmentStubBinding
import me.gm.cleaner.plugin.ui.module.ModuleFragment

class SettingsFragmentStub : ModuleFragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ) = if (!binderViewModel.pingBinder()) {
        super.onCreateView(inflater, container, savedInstanceState)
    } else {
        SettingsFragmentStubBinding.inflate(layoutInflater).root.also {
            savedInstanceState ?: childFragmentManager.commit {
                replace(R.id.settings, SettingsFragment())
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/TemplatesAdapters.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.forEach
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.Hold
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.TemplatesHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesItemBinding
import me.gm.cleaner.plugin.ktx.DividerViewHolder
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates

class TemplatesHeaderAdapter(private val fragment: TemplatesFragment) :
    RecyclerView.Adapter<TemplatesHeaderAdapter.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        binding.root.transitionName = CreateTemplateFragment.NULL_TEMPLATE_NAME
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.templates_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = CreateTemplateFragment.NULL_TEMPLATE_NAME
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)

            val direction = TemplatesFragmentDirections.actionTemplatesToCreateTemplate()
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }

        if (fragment.lastTemplateName == CreateTemplateFragment.NULL_TEMPLATE_NAME) {
            fragment.startPostponedEnterTransition()
        }
    }

    override fun getItemCount() = 1

    class ViewHolder(val binding: TemplatesHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedBelow = true
        }
    }
}

class TemplatesAdapter(private val fragment: TemplatesFragment) :
    ListAdapter<Template, TemplatesAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesItemBinding.inflate(LayoutInflater.from(parent.context)))

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = templateName
        binding.summary.text = fragment.getString(
            R.string.applied_app_count, item.applyToApp?.size ?: 0
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.templates_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = templateName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)

            val direction =
                TemplatesFragmentDirections.actionTemplatesToCreateTemplate(templateName)
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            activity.menuInflater.inflate(R.menu.item_delete, menu)
            menu.setHeaderTitle(templateName)
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    if (item.itemId == R.id.menu_delete) {
                        val modified =
                            Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                .values.filterNot { it.templateName == templateName }
                        fragment.binderViewModel.writeSp(
                            R.xml.template_preferences, Gson().toJson(modified)
                        )
                        true
                    } else {
                        false
                    }
                }
            }
        }

        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }

    class ViewHolder(val binding: TemplatesItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName

            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/TemplatesFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.app.SharedElementCallback
import androidx.core.os.bundleOf
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.setFragmentResultListener
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.recyclerview.widget.ConcatAdapter
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.MaterialContainerTransform
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.TemplatesFragmentBinding
import me.gm.cleaner.plugin.ktx.DividerDecoration
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import kotlin.collections.set

class TemplatesFragment : ModuleFragment() {
    var lastTemplateName: String? = null

    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = TemplatesFragmentBinding.inflate(layoutInflater)

        val templatesAdapter = TemplatesAdapter(this)
        val adapters = ConcatAdapter(TemplatesHeaderAdapter(this), templatesAdapter)
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapters
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        list.addItemDecoration(DividerDecoration(list).apply {
            setDivider(resources.getDrawable(R.drawable.list_divider_material, null))
            setAllowDividerAfterLastItem(false)
        })

        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            templatesAdapter.submitList(prepareCurrentList())
        }

        prepareSharedElementTransition(list)
        setFragmentResultListener(CreateTemplateFragment::class.java.name) { _, bundle ->
            lastTemplateName = bundle.getString(CreateTemplateFragment.KEY_TEMPLATE_NAME)
            var position = prepareCurrentList().indexOfFirst { it.templateName == lastTemplateName }
            if (position != -1) {
                position++
            } else {
                position = 0
                lastTemplateName = CreateTemplateFragment.NULL_TEMPLATE_NAME
            }
            prepareTransitions(list, position)
            postponeEnterTransition()
            scrollToPosition(list, position)
        }
        return binding.root
    }

    private fun prepareCurrentList(): List<Template> =
        Templates(binderViewModel.readSp(R.xml.template_preferences)).values
            .sortedWith(collatorComparator { it.templateName })

    private fun prepareTransitions(list: RecyclerView, position: Int) {
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val selectedViewHolder = list.findViewHolderForAdapterPosition(position) ?: return
                sharedElements[names[0]] = selectedViewHolder.itemView
            }
        })
    }

    private fun prepareSharedElementTransition(list: RecyclerView) {
        val key = getString(R.string.template_management_key) /* hardcoded */
        setFragmentResult(TemplatesFragment::class.java.name, bundleOf(KEY to key))
        list.transitionName = key

        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }

        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    sharedElements[names[0]] = list
                }
            }
        })
    }

    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            // Scroll to position if the view for the current position is null (not currently part of
            // layout manager children), or it's not completely visible.
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }

    companion object {
        const val KEY = "me.gm.cleaner.plugin.key"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/AppListMultiSelectListPreference.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageInfo
import android.icu.text.ListFormatter
import android.util.AttributeSet
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.res.TypedArrayUtils
import androidx.lifecycle.lifecycleScope
import androidx.preference.MultiSelectListPreference
import androidx.preference.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.util.collatorComparator
import java.util.Arrays
import java.util.function.Consumer
import java.util.function.Supplier

@SuppressLint("RestrictedApi", "PrivateResource")
class AppListMultiSelectListPreference @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = TypedArrayUtils.getAttr(
        context, R.attr.dialogPreferenceStyle, android.R.attr.dialogPreferenceStyle
    ), defStyleRes: Int = 0
) : MultiSelectListPreference(context, attrs, defStyleAttr, defStyleRes) {
    private val lifecycleScope = (context as AppCompatActivity).lifecycleScope
    private lateinit var packageNameToLabel: List<Pair<String, CharSequence>>
    private var onAppsLoadedListener: Consumer<AppListMultiSelectListPreference>? = null

    /** Delay showDialog if applist is not loaded when clicked. */
    private val mutex = Mutex()

    fun loadApps(applistSupplier: Supplier<List<PackageInfo>>): AppListMultiSelectListPreference {
        lifecycleScope.launch {
            mutex.withLock {
                val pm = context.packageManager
                packageNameToLabel = withContext(Dispatchers.Default) {
                    applistSupplier.get()
                        .map { it.packageName to pm.getApplicationLabel(it.applicationInfo) }
                        .sortedWith(collatorComparator { it.second.toString() })
                }
                liftSelected()
            }
            summaryProvider = instance
        }
        return this
    }

    fun setOnAppsLoadedListener(l: Consumer<AppListMultiSelectListPreference>): AppListMultiSelectListPreference {
        onAppsLoadedListener = l
        return this
    }

    override fun setValues(values: Set<String>) {
        super.setValues(values)
        liftSelected()
    }

    private fun liftSelected() {
        if (!::packageNameToLabel.isInitialized) {
            return
        }
        val list = packageNameToLabel
            .sortedWith(Comparator.comparing { it.first !in values })
            .unzip()
        entries = list.second.toTypedArray()
        entryValues = list.first.toTypedArray()

        val l = onAppsLoadedListener
        // Avoid infinite recursions if liftSelected() is called from a listener
        onAppsLoadedListener = null
        l?.accept(this)
    }

    override fun onClick() {
        lifecycleScope.launch {
            mutex.withLock {
                super.onClick()
            }
        }
    }

    class SimpleSummaryProvider : SummaryProvider<AppListMultiSelectListPreference> {
        override fun provideSummary(preference: AppListMultiSelectListPreference): CharSequence =
            if (preference.values.isEmpty()) {
                preference.context.getString(R.string.not_set)
            } else {
                val values = Arrays.stream(preference.entryValues)
                    .filter { preference.values.contains(it) }
                    .map { preference.entries[preference.entryValues.indexOf(it)] }
                    .toArray()
                ListFormatter.getInstance().format(*values)
            }
    }

    companion object {
        val instance by lazy { SimpleSummaryProvider() }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/DocumentsContract.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.content.Context
import android.net.Uri
import android.os.storage.StorageManager
import android.provider.DocumentsContract
import androidx.core.provider.DocumentsContractCompat
import java.io.File

private const val EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID = "primary"

// @see com.android.externalstorage.ExternalStorageProvider
fun treeUriToFile(result: Uri, context: Context): File? {
    require(DocumentsContractCompat.isTreeUri(result))
    val docId = DocumentsContract.getTreeDocumentId(result)
    val splitIndex = docId.indexOf(':', 1)

    val sm = context.getSystemService(Context.STORAGE_SERVICE) as StorageManager
    val roots = sm.storageVolumes.associateBy { volume ->
        val rootId = if (volume.isPrimary) EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID
        else volume.uuid
        rootId
    }
    val tag = docId.substring(0, splitIndex)
    val root = roots[tag] ?: return null
    val path = docId.substring(splitIndex + 1)
    val target = File(root.javaClass.getMethod("getPathFile").invoke(root) as File, path)
    return target
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/MaterialEditTextPreferenceDialogFragmentCompat.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.app.Dialog
import android.os.Bundle
import androidx.core.view.ViewCompat
import androidx.preference.EditTextPreferenceDialogFragmentCompat
import com.google.android.material.dialog.InsetDialogOnTouchListener
import com.google.android.material.dialog.MaterialDialogs
import me.gm.cleaner.plugin.ktx.createMaterialAlertDialogThemedContext
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundDrawable
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundInsets

class MaterialEditTextPreferenceDialogFragmentCompat : EditTextPreferenceDialogFragmentCompat() {

    @SuppressLint("RestrictedApi")
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val alertDialog = super.onCreateDialog(savedInstanceState)
        val window = alertDialog.window!!
        /* {@link Window#getDecorView()} should be called before any changes are made to the Window
         * as it locks in attributes and affects layout. */
        val decorView = window.decorView
        val context = requireContext().createMaterialAlertDialogThemedContext()
        val background = context.materialDialogBackgroundDrawable()
        background.elevation = ViewCompat.getElevation(decorView)
        val backgroundInsets = context.materialDialogBackgroundInsets()

        val insetDrawable = MaterialDialogs.insetDrawable(background, backgroundInsets)
        window.setBackgroundDrawable(insetDrawable)
        decorView.setOnTouchListener(InsetDialogOnTouchListener(alertDialog, backgroundInsets))
        return alertDialog
    }

    companion object {
        fun newInstance(key: String?): MaterialEditTextPreferenceDialogFragmentCompat {
            val fragment = MaterialEditTextPreferenceDialogFragmentCompat()
            val b = Bundle(1)
            b.putString(ARG_KEY, key)
            fragment.arguments = b
            return fragment
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/MaterialMultiSelectListPreferenceDialogFragmentCompat.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.app.Dialog
import android.os.Bundle
import androidx.core.view.ViewCompat
import androidx.preference.MultiSelectListPreferenceDialogFragmentCompat
import com.google.android.material.dialog.InsetDialogOnTouchListener
import com.google.android.material.dialog.MaterialDialogs
import me.gm.cleaner.plugin.ktx.createMaterialAlertDialogThemedContext
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundDrawable
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundInsets

class MaterialMultiSelectListPreferenceDialogFragmentCompat :
    MultiSelectListPreferenceDialogFragmentCompat() {

    @SuppressLint("RestrictedApi")
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val alertDialog = super.onCreateDialog(savedInstanceState)
        val window = alertDialog.window!!
        /* {@link Window#getDecorView()} should be called before any changes are made to the Window
         * as it locks in attributes and affects layout. */
        val decorView = window.decorView
        val context = requireContext().createMaterialAlertDialogThemedContext()
        val background = context.materialDialogBackgroundDrawable()
        background.elevation = ViewCompat.getElevation(decorView)
        val backgroundInsets = context.materialDialogBackgroundInsets()

        val insetDrawable = MaterialDialogs.insetDrawable(background, backgroundInsets)
        window.setBackgroundDrawable(insetDrawable)
        decorView.setOnTouchListener(InsetDialogOnTouchListener(alertDialog, backgroundInsets))
        return alertDialog
    }

    companion object {
        fun newInstance(key: String?): MaterialMultiSelectListPreferenceDialogFragmentCompat {
            val fragment = MaterialMultiSelectListPreferenceDialogFragmentCompat()
            val b = Bundle(1)
            b.putString(ARG_KEY, key)
            fragment.arguments = b
            return fragment
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreference.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.TypedArray
import android.icu.text.ListFormatter
import android.os.Parcel
import android.os.Parcelable
import android.util.AttributeSet
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes
import androidx.core.content.res.TypedArrayUtils
import androidx.preference.DialogPreference
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.util.collatorComparator

class PathListPreference @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null,
    @SuppressLint("RestrictedApi") @AttrRes defStyleAttr: Int = TypedArrayUtils.getAttr(
        context, androidx.preference.R.attr.dialogPreferenceStyle,
        android.R.attr.dialogPreferenceStyle
    ), @StyleRes defStyleRes: Int = 0
) : DialogPreference(context, attrs, defStyleAttr, defStyleRes) {
    private val _values = mutableSetOf<String>()
    var values: Set<String>
        get() = _values
        set(value) {
            _values.clear()
            _values.addAll(value)
            persistStringSet(value)
            notifyChanged()
        }

    init {
        summaryProvider = instance
    }

    override fun getDialogLayoutResource(): Int = R.layout.path_list_dialog

    override fun onGetDefaultValue(a: TypedArray, index: Int): Any {
        val defaultValues = a.getTextArray(index)
        val result = mutableSetOf<String>()

        for (defaultValue in defaultValues) {
            result.add(defaultValue.toString())
        }
        return result
    }

    override fun onSetInitialValue(defaultValue: Any?) {
        values = getPersistedStringSet(defaultValue as Set<String>?)
    }

    override fun onSaveInstanceState(): Parcelable? {
        val superState = super.onSaveInstanceState()
        if (isPersistent) {
            // No need to save instance state
            return superState
        }
        val myState = SavedState(superState)
        myState.mValues = values
        return myState
    }

    override fun onRestoreInstanceState(state: Parcelable?) {
        if (state == null || state.javaClass != SavedState::class.java) {
            // Didn't save state for us in onSaveInstanceState
            super.onRestoreInstanceState(state)
            return
        }
        val myState = state as SavedState
        super.onRestoreInstanceState(myState.superState)
        values = myState.mValues
    }

    private class SavedState : BaseSavedState {
        var mValues = emptySet<String>()

        constructor(source: Parcel) : super(source) {
            val size = source.readInt()
            val strings = arrayOfNulls<String>(size)
            source.readStringArray(strings)
            mValues = strings.mapNotNullTo(mutableSetOf()) { it!! }
        }

        constructor(superState: Parcelable?) : super(superState)

        override fun writeToParcel(dest: Parcel, flags: Int) {
            super.writeToParcel(dest, flags)
            dest.writeInt(mValues.size)
            dest.writeStringArray(mValues.toTypedArray())
        }

        companion object CREATOR : Parcelable.Creator<SavedState> {
            override fun createFromParcel(`in`: Parcel) = SavedState(`in`)
            override fun newArray(size: Int): Array<SavedState?> = arrayOfNulls(size)
        }
    }

    class SimpleSummaryProvider : SummaryProvider<PathListPreference> {
        override fun provideSummary(preference: PathListPreference): String =
            if (preference.values.isEmpty()) {
                preference.context.getString(androidx.preference.R.string.not_set)
            } else {
                ListFormatter.getInstance().format(
                    preference.values.sortedWith(collatorComparator { it })
                )
            }
    }

    companion object {
        val instance by lazy { SimpleSummaryProvider() }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreferenceAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.view.forEach
import androidx.preference.EditTextPreference
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.PathListItemBinding
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreferenceFragmentCompat.Companion.TEXT_EDITOR
import java.io.File

class PathListPreferenceAdapter(
    private val fragment: PathListPreferenceFragmentCompat
) : ListAdapter<String, PathListPreferenceAdapter.ViewHolder>(CALLBACK) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(PathListItemBinding.inflate(LayoutInflater.from(parent.context)))

    @SuppressLint("RestrictedApi")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val path = getItem(position)!!
        binding.title.text = path
        binding.root.setOnClickListener {
            val preference = fragment.findPreference<EditTextPreference>(TEXT_EDITOR)
            preference?.text = path
            preference?.setOnPreferenceChangeListener { _, newValue ->
                fragment.newValues = fragment.newValues - path + newValue as String
                false
            }
            preference?.performClick()
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            fragment.requireActivity().menuInflater.inflate(R.menu.item_delete, menu)
            menu.setHeaderTitle(path.substring(path.lastIndexOf(File.separator) + 1))
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    if (item.itemId == R.id.menu_delete) {
                        fragment.newValues -= path
                        true
                    } else {
                        false
                    }
                }
            }
        }
    }

    class ViewHolder(val binding: PathListItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<String>() {
            override fun areItemsTheSame(oldItem: String, newItem: String): Boolean =
                oldItem == newItem

            override fun areContentsTheSame(oldItem: String, newItem: String): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreferenceFragmentCompat.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference

import android.annotation.SuppressLint
import android.app.Dialog
import android.content.DialogInterface
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.view.SupportMenuInflater
import androidx.appcompat.widget.Toolbar
import androidx.core.os.bundleOf
import androidx.preference.DialogPreference
import androidx.preference.EditTextPreference
import androidx.preference.ListPreference
import androidx.preference.ListPreferenceDialogFragmentCompat
import androidx.preference.MultiSelectListPreference
import androidx.preference.Preference
import androidx.preference.PreferenceDialogFragmentCompat
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.appbar.AppBarLayout
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.floatingactionbutton.FloatingActionButton
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect

class PathListPreferenceFragmentCompat : PreferenceDialogFragmentCompat(),
    PreferenceManager.OnDisplayPreferenceDialogListener, DialogPreference.TargetFragment {
    private val pathListPreference by lazy { preference as PathListPreference }
    private lateinit var adapter: PathListPreferenceAdapter
    var newValues = emptyList<String>()
        set(value) {
            field = value.distinct().sortedWith(collatorComparator { it })
            adapter.submitList(field)
        }
    private val preferenceChanged
        get() = pathListPreference.values != newValues.toSet()
    var ignorePreferenceChanged = false
    private val dialog by lazy {
        MaterialAlertDialogBuilder(requireContext())
            .setMessage(R.string.quit_without_save)
            .setPositiveButton(android.R.string.ok) { _, _ ->
                ignorePreferenceChanged = true
                onDismiss(requireDialog())
            }
            .setNegativeButton(android.R.string.cancel, null)
            .create()
    }
    val openDocumentTreeLauncher = registerForActivityResult(
        ActivityResultContracts.OpenDocumentTree(), this::onFragmentResult
    )

    // "preferences" should be retained to survive configuration change, but I'm too lazy to do this :)
    private val preferences = mutableListOf<Preference>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.AppTheme_FullScreenDialog)
        adapter = PathListPreferenceAdapter(this)
        newValues = if (savedInstanceState == null) {
            pathListPreference.values.toList()
        } else {
            if (savedInstanceState.getBoolean(SAVED_SHOWS_ALERT_DIALOG, false)) {
                dialog.show()
            }
            savedInstanceState.getStringArrayList(SAVE_STATE_VALUES)!!
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(SAVED_SHOWS_ALERT_DIALOG, dialog.isShowing)
        outState.putStringArrayList(SAVE_STATE_VALUES, ArrayList(newValues))
    }

    override fun onCreateDialog(savedInstanceState: Bundle?) =
        object : Dialog(requireContext(), theme) {
            override fun onBackPressed() {
                onDismiss(requireDialog())
            }
        }.apply {
            val contentView = onCreateDialogView(context)
            if (contentView != null) {
                onBindDialogView(contentView)
                setContentView(contentView)
            }
            window?.setLayout(
                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
            )
        }

    @SuppressLint("RestrictedApi")
    override fun onBindDialogView(view: View) {
        super.onBindDialogView(view)
        val appBarLayout = view.findViewById<AppBarLayout>(R.id.toolbar_container)
        view.findViewById<Toolbar>(R.id.toolbar).apply {
            setNavigationOnClickListener { onDismiss(requireDialog()) }
            setNavigationIcon(R.drawable.ic_outline_close_24)
            SupportMenuInflater(context).inflate(R.menu.toolbar_save, menu)
            setOnMenuItemClickListener { item ->
                when (item.itemId) {
                    R.id.menu_save -> {
                        val dialog = requireDialog()
                        onClick(dialog, DialogInterface.BUTTON_POSITIVE)
                        ignorePreferenceChanged = true
                        onDismiss(requireDialog())
                    }
                    else -> return@setOnMenuItemClickListener false
                }
                true
            }
            title = pathListPreference.dialogTitle
        }

        val list = view.findViewById<RecyclerView>(R.id.list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        val preference = object : EditTextPreference(requireContext()) {
            override fun getPreferenceManager() = object : PreferenceManager(requireContext()) {
                init {
                    onDisplayPreferenceDialogListener = this@PathListPreferenceFragmentCompat
                }
            }
        }.apply {
            key = TEXT_EDITOR
            dialogTitle = pathListPreference.dialogTitle
        }
        preferences.add(preference)

        view.findViewById<FloatingActionButton>(R.id.fab).setOnClickListener {
            openDocumentTreeLauncher.launch(null)
        }
    }

    override fun onDisplayPreferenceDialog(preference: Preference) {
        val f = when (preference) {
            is EditTextPreference ->
                MaterialEditTextPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            is ListPreference ->
                ListPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            is MultiSelectListPreference ->
                MaterialMultiSelectListPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            else -> throw IllegalArgumentException(
                "Cannot display dialog for an unknown Preference type: "
                        + preference.javaClass.simpleName
                        + ". Make sure to implement onPreferenceDisplayDialog() to handle "
                        + "displaying a custom dialog for this Preference."
            )
        }
        f.setTargetFragment(this, 0)
        f.show(parentFragmentManager, null)
    }

    @Suppress("UNCHECKED_CAST")
    override fun <T : Preference?> findPreference(key: CharSequence): T? {
        for (preference in preferences) {
            val curKey = preference.key
            if (curKey == key) {
                return preference as T
            }
        }
        return null
    }

    fun onFragmentResult(result: Uri?) {
        result ?: return
        val target = treeUriToFile(result, requireContext()) ?: return
        newValues += target.path
    }

    override fun onDestroyView() {
        super.onDestroyView()
        if (dialog.isShowing) {
            dialog.dismiss()
        }
    }

    override fun onDismiss(dialog: DialogInterface) {
        if (preferenceChanged && !ignorePreferenceChanged) {
            this.dialog.show()
        } else {
            super.onDismiss(dialog)
        }
    }

    override fun onDialogClosed(positiveResult: Boolean) {
        if (positiveResult && preferenceChanged) {
            val newValues = newValues.toSet()
            if (pathListPreference.callChangeListener(newValues)) {
                pathListPreference.values = newValues
            }
        }
    }

    companion object {
        private const val SAVE_STATE_VALUES = "PathListPreferenceFragmentCompat.values"
        private const val SAVED_SHOWS_ALERT_DIALOG = "android:showsAlertDialog"
        const val TEXT_EDITOR = "android:textEditor"
        fun newInstance(key: String?) =
            PathListPreferenceFragmentCompat().apply { arguments = bundleOf(ARG_KEY to key) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/RefinedMultiSelectListPreference.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.settings.preference;

import android.annotation.SuppressLint;
import android.content.Context;
import android.icu.text.ListFormatter;
import android.util.AttributeSet;

import androidx.core.content.res.TypedArrayUtils;
import androidx.preference.MultiSelectListPreference;
import androidx.preference.R;

import java.util.Arrays;
import java.util.Set;

@SuppressLint({"RestrictedApi", "PrivateResource"})
public class RefinedMultiSelectListPreference extends MultiSelectListPreference {
    public RefinedMultiSelectListPreference(
            Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);

        setSummaryProvider(SimpleSummaryProvider.getInstance());
    }

    public RefinedMultiSelectListPreference(Context context, AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, 0);
    }

    public RefinedMultiSelectListPreference(Context context, AttributeSet attrs) {
        this(context, attrs, TypedArrayUtils.getAttr(context, R.attr.dialogPreferenceStyle,
                android.R.attr.dialogPreferenceStyle));
    }

    public RefinedMultiSelectListPreference(Context context) {
        this(context, null);
    }

    @Override
    public void setValues(Set<String> values) {
        super.setValues(values);
        notifyDependencyChange(shouldDisableDependents());
    }

    @Override
    public boolean shouldDisableDependents() {
        return getValues().isEmpty() || super.shouldDisableDependents();
    }

    /**
     * A simple {@link androidx.preference.Preference.SummaryProvider} implementation for a
     * {@link MultiSelectListPreference}. If no value has been set, the summary displayed will be 'Not set',
     * otherwise the summary displayed will be the entry set for this preference.
     */
    public static final class SimpleSummaryProvider
            implements SummaryProvider<RefinedMultiSelectListPreference> {

        private static SimpleSummaryProvider sSimpleSummaryProvider;

        private SimpleSummaryProvider() {
        }

        /**
         * Retrieve a singleton instance of this simple
         * {@link androidx.preference.Preference.SummaryProvider} implementation.
         *
         * @return a singleton instance of this simple
         * {@link androidx.preference.Preference.SummaryProvider} implementation
         */
        public static SimpleSummaryProvider getInstance() {
            if (sSimpleSummaryProvider == null) {
                sSimpleSummaryProvider = new SimpleSummaryProvider();
            }
            return sSimpleSummaryProvider;
        }

        @Override
        public CharSequence provideSummary(RefinedMultiSelectListPreference preference) {
            if (preference.getValues().isEmpty()) {
                return preference.getContext().getString(R.string.not_set);
            } else {
                var entryValues = Arrays.asList(preference.getEntryValues());
                var values = Arrays.stream(preference.getEntryValues())
                        .filter(it -> preference.getValues().contains(it))
                        .map(it -> preference.getEntries()[entryValues.indexOf(it)])
                        .toArray();
                return ListFormatter.getInstance().format(values);
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordAdapter.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.usagerecord

import android.annotation.SuppressLint
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.text.format.DateUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.widget.ListPopupWindow
import androidx.core.text.buildSpannedString
import androidx.core.text.strikeThrough
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.snackbar.Snackbar
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.databinding.UsagerecordItemBinding

class UsageRecordAdapter(private val fragment: UsageRecordFragment) :
    ListAdapter<MediaProviderRecord, UsageRecordAdapter.ViewHolder>(CALLBACK) {
    private val context = fragment.requireContext()
    private val clipboardManager by lazy { context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(UsagerecordItemBinding.inflate(LayoutInflater.from(parent.context)))

    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val record = getItem(position)
        Glide.with(fragment)
            .load(record.packageInfo)
            .into(binding.icon)
        binding.title.text = record.label ?: record.packageName
        val operation = when (record.operation) {
            OP_QUERY -> fragment.getString(R.string.queried_at)
            OP_INSERT -> fragment.getString(R.string.inserted_at)
            OP_DELETE -> fragment.getString(R.string.deleted_at)
            else -> throw IllegalArgumentException()
        } + formatDateTime(record.timeMillis)
        binding.operation.text = if (record.intercepted.any { it })
            buildSpannedString { strikeThrough { append(operation) } } else operation
        val more = record.data.size - 1
        val hasMore = more > 0
        binding.text.text = record.data.first()
        binding.suffix.text = if (hasMore) fragment.getString(R.string.and_more, more) else null
        binding.root.setOnClickListener {
            val adapter = ArrayAdapter(
                context, R.layout.usagerecord_popup_item,
                record.data.zip(record.intercepted).map { (data, intercepted) ->
                    if (intercepted) buildSpannedString { strikeThrough { append(data) } } else data
                }
            )
            val listPopupWindow = ListPopupWindow(context)
            listPopupWindow.setAdapter(adapter)
            listPopupWindow.anchorView = binding.root
            listPopupWindow.setOnItemClickListener { _, _, position, _ ->
                val data = adapter.getItem(position).toString()
                clipboardManager.setPrimaryClip(ClipData.newPlainText(null, data))
                Snackbar.make(
                    fragment.requireView(), fragment.getString(R.string.copied, data),
                    Snackbar.LENGTH_SHORT
                ).show()
                listPopupWindow.dismiss()
            }
            listPopupWindow.show()
        }
    }

    private fun formatDateTime(timeMillis: Long): String {
        val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_TIME
        return DateUtils.formatDateTime(context, timeMillis, flags)
    }

    class ViewHolder(val binding: UsagerecordItemBinding) : RecyclerView.ViewHolder(binding.root)

    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<MediaProviderRecord>() {
            override fun areItemsTheSame(
                oldItem: MediaProviderRecord, newItem: MediaProviderRecord
            ): Boolean = oldItem.timeMillis == newItem.timeMillis

            override fun areContentsTheSame(
                oldItem: MediaProviderRecord, newItem: MediaProviderRecord
            ): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordFragment.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.usagerecord

import android.app.Application
import android.icu.text.DateFormat
import android.icu.util.TimeZone
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.viewModels
import androidx.lifecycle.asLiveData
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.datepicker.CalendarConstraints
import com.google.android.material.datepicker.DateValidatorPointBackward
import com.google.android.material.datepicker.MaterialDatePicker
import me.gm.cleaner.plugin.IMediaChangeObserver
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.UsagerecordFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.widget.FixQueryChangeSearchView
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import java.util.Date
import java.util.Locale

class UsageRecordFragment : ModuleFragment() {
    private val viewModel: UsageRecordViewModel by viewModels(
        factoryProducer = {
            UsageRecordViewModel.provideFactory(
                requireContext().applicationContext as Application,
                binderViewModel
            )
        }
    )
    private val mediaChangeObserver = object : IMediaChangeObserver.Stub() {
        override fun onChange() {
            viewModel.reload()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        if (!binderViewModel.pingBinder()) {
            return super.onCreateView(inflater, container, savedInstanceState)
        }
        val binding = UsagerecordFragmentBinding.inflate(layoutInflater)

        val adapter = UsageRecordAdapter(this).apply {
            stateRestorationPolicy = RecyclerView.Adapter.StateRestorationPolicy.PREVENT_WHEN_EMPTY
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .build()
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets(fastScroller)

        viewModel.recordsFlow.asLiveData().observe(viewLifecycleOwner) { records ->
            when (records) {
                is UsageRecordState.Loading -> binding.progress.show()
                is UsageRecordState.Done -> adapter.submitList(records.list) {
                    binding.progress.hide()
                    supportActionBar?.subtitle = DateFormat.getInstanceForSkeleton(
                        DateFormat.YEAR_ABBR_MONTH_DAY, Locale.getDefault()
                    ).apply {
                        timeZone = TimeZone.getTimeZone("UTC")
                    }.format(Date(viewModel.calendar.timeInMillis))
                }
            }
        }

        binderViewModel.registerMediaChangeObserver(mediaChangeObserver)
        findNavController().addOnExitListener { _, _, _ ->
            binderViewModel.unregisterMediaChangeObserver(mediaChangeObserver)
            supportActionBar?.subtitle = null
        }
        return binding.root
    }

    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (!binderViewModel.pingBinder()) {
            return
        }
        inflater.inflate(R.menu.usagerecord_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                viewModel.queryText = ""
                return true
            }

            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as FixQueryChangeSearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }

            override fun onQueryTextChange(newText: String): Boolean {
                if (!searchView.shouldIgnoreQueryChange) {
                    viewModel.queryText = newText
                }
                return false
            }
        })

        menu.findItem(R.id.menu_hide_query).isChecked = RootPreferences.isHideQueryFlowable.value
        menu.findItem(R.id.menu_hide_insert).isChecked = RootPreferences.isHideInsertFlowable.value
        menu.findItem(R.id.menu_hide_delete).isChecked = RootPreferences.isHideDeleteFlowable.value
        arrayOf(menu.findItem(R.id.menu_header_hide)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_pick_date -> {
                val calendarConstraints = CalendarConstraints.Builder()
                    .setValidator(DateValidatorPointBackward.now())
                    .build()
                val datePicker = MaterialDatePicker.Builder.datePicker()
                    .setCalendarConstraints(calendarConstraints)
                    .setSelection(viewModel.calendar.timeInMillis)
                    .build()
                datePicker.addOnPositiveButtonClickListener { selection ->
                    viewModel.selectedTime = selection
                }
                datePicker.show(childFragmentManager, null)
            }

            R.id.menu_hide_query -> {
                val isHideQuery = !item.isChecked
                item.isChecked = isHideQuery
                RootPreferences.isHideQueryFlowable.value = isHideQuery
            }

            R.id.menu_hide_insert -> {
                val isHideInsert = !item.isChecked
                item.isChecked = isHideInsert
                RootPreferences.isHideInsertFlowable.value = isHideInsert
            }

            R.id.menu_hide_delete -> {
                val isHideDelete = !item.isChecked
                item.isChecked = isHideDelete
                RootPreferences.isHideDeleteFlowable.value = isHideDelete
            }

            R.id.menu_clear -> {
                binderViewModel.clearAllTables()
                viewModel.reload()
            }

            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordViewModel.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.ui.module.usagerecord

import android.app.Application
import android.provider.MediaStore
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import java.util.Calendar

class UsageRecordViewModel(
    application: Application,
    private val binderViewModel: BinderViewModel,
) : AndroidViewModel(application) {
    private val _isSearchingFlow: MutableStateFlow<Boolean> = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    private val _queryTextFlow: MutableStateFlow<String> = MutableStateFlow("")
    var queryText: String by _queryTextFlow
    private val _selectedTimeFlow: MutableStateFlow<Long> =
        MutableStateFlow(System.currentTimeMillis())
    var selectedTime: Long by _selectedTimeFlow
    val calendar: Calendar = Calendar.getInstance()

    private val _recordsFlow = MutableStateFlow<UsageRecordState>(UsageRecordState.Loading)
    val recordsFlow =
        combine(_recordsFlow, _isSearchingFlow, _queryTextFlow) { source, isSearching, queryText ->
            when (source) {
                is UsageRecordState.Loading -> UsageRecordState.Loading
                is UsageRecordState.Done -> withContext(Dispatchers.Default) {
                    var sequence = source.list.asSequence()
                    if (isSearching) {
                        sequence = sequence.filter {
                            it.data.any { data -> data.contains(queryText, true) } ||
                                    it.label?.contains(queryText, true) == true ||
                                    it.packageName.contains(queryText, true)
                        }
                    }
                    UsageRecordState.Done(sequence.toList())
                }
            }
        }

    /**
     * Find the start and the end time millis of a day.
     * @param timeMillis any time millis in that day
     */
    private fun calculateSelectedTime(timeMillis: Long): Pair<Long, Long> =
        with(calendar) {
            timeInMillis = timeMillis
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
            val start = timeInMillis
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
            set(Calendar.MILLISECOND, 999)
            val end = timeInMillis
            return start to end
        }

    private suspend inline fun queryRecord(
        start: Long, end: Long, operations: List<Int>
    ): List<MediaProviderRecord> = withContext(Dispatchers.IO) {
        val projection = operations.map { it.toString() }.toTypedArray()
        val selection = start.toString()
        val sortOrder = end.toString()

        getApplication<Application>().contentResolver.query(
            MediaStore.Images.Media.INTERNAL_CONTENT_URI,
            projection,
            selection,
            null,
            sortOrder
        )?.use { cursor ->
            return@withContext MediaProviderRecord.convert(cursor)
        }
        return@withContext emptyList()
    }

    private suspend fun load(
        start: Long, end: Long,
        isHideQuery: Boolean, isHideInsert: Boolean, isHideDelete: Boolean
    ): UsageRecordState {
        val packageManager = getApplication<Application>().packageManager
        val operations = mutableListOf<Int>()
        if (!isHideQuery) {
            operations += OP_QUERY
        }
        if (!isHideInsert) {
            operations += OP_INSERT
        }
        if (!isHideDelete) {
            operations += OP_DELETE
        }
        val records = mutableListOf<MediaProviderRecord>().also {
            it += queryRecord(start, end, operations)
        }.onEach {
            val pi = binderViewModel.getPackageInfo(it.packageName) ?: return@onEach
            it.packageInfo = pi
            it.label = packageManager.getApplicationLabel(pi.applicationInfo).toString()
        }.takeWhile {
            it.packageInfo != null
        }
        return UsageRecordState.Done(records)
    }

    private val isHideQueryFlow: StateFlow<Boolean> = RootPreferences.isHideQueryFlowable.asFlow()
    private val isHideInsertFlow: StateFlow<Boolean> = RootPreferences.isHideInsertFlowable.asFlow()
    private val isHideDeleteFlow: StateFlow<Boolean> = RootPreferences.isHideDeleteFlowable.asFlow()

    fun reload() {
        _recordsFlow.value = UsageRecordState.Loading
        viewModelScope.launch {
            val (start, end) = calculateSelectedTime(selectedTime)
            _recordsFlow.value = load(
                start, end,
                isHideQueryFlow.value,
                isHideInsertFlow.value,
                isHideDeleteFlow.value
            )
        }
    }

    init {
        viewModelScope.launch {
            combine(
                _selectedTimeFlow,
                isHideQueryFlow,
                isHideInsertFlow,
                isHideDeleteFlow,
            ) { selectedTime, isHideQuery, isHideInsert, isHideDelete ->
                _recordsFlow.value = UsageRecordState.Loading
                val (start, end) = calculateSelectedTime(selectedTime)
                load(start, end, isHideQuery, isHideInsert, isHideDelete)
            }.collect {
                _recordsFlow.value = it
            }
        }
    }

    companion object {
        fun provideFactory(
            application: Application, binderViewModel: BinderViewModel
        ): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            @Suppress("UNCHECKED_CAST")
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                return UsageRecordViewModel(application, binderViewModel) as T
            }
        }
    }
}

sealed class UsageRecordState {
    data object Loading : UsageRecordState()
    data class Done(val list: List<MediaProviderRecord>) : UsageRecordState()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/Comparators.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.util

import java.text.Collator

private val collator: Collator by lazy { Collator.getInstance() }
private val naturalSorter: NaturalSorter by lazy { NaturalSorter() }

fun <T> collatorComparator(convert: (T) -> String): Comparator<T> {
    return Comparator { o1, o2 ->
        collator.compare(convert(o1), convert(o2))
    }
}

fun <T> fileNameComparator(convert: (T) -> String): Comparator<T> {
    return Comparator { o1, o2 ->
        naturalSorter.compare(convert(o1), convert(o2))
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/FlowableSharedPreferences.kt
================================================
```
/*
 * Copyright 2024 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.util

import android.content.SharedPreferences
import androidx.core.content.edit
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

class FlowableSharedPreferences<T>(
    private val preferences: SharedPreferences,
    private val key: String,
    private val defaultValue: T,
) {
    @Suppress("UNCHECKED_CAST")
    private fun load(): T = when (defaultValue) {
        is String -> preferences.getString(key, defaultValue) as T
        is Set<*> -> preferences.getStringSet(key, defaultValue as Set<String>) as T
        is Int -> preferences.getInt(key, defaultValue) as T
        is Long -> preferences.getLong(key, defaultValue) as T
        is Float -> preferences.getFloat(key, defaultValue) as T
        is Boolean -> preferences.getBoolean(key, defaultValue) as T
        else -> throw IllegalArgumentException("Unsupported type")
    }

    private val _preferenceFlow: MutableStateFlow<T> = MutableStateFlow(load())

    var value: T
        get() = _preferenceFlow.value
        set(value) {
            preferences.edit {
                when (value) {
                    is String -> putString(key, value as String)
                    is Set<*> -> putStringSet(key, value as Set<String>)
                    is Int -> putInt(key, value as Int)
                    is Long -> putLong(key, value as Long)
                    is Float -> putFloat(key, value as Float)
                    is Boolean -> putBoolean(key, value as Boolean)
                    else -> throw IllegalArgumentException("Unsupported type")
                }
            }
        }

    fun asFlow(): StateFlow<T> = _preferenceFlow

    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
        if (key == this.key) {
            _preferenceFlow.value = load()
        }
    }

    init {
        preferences.registerOnSharedPreferenceChangeListener(listener)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/MediaStoreCompat.kt
================================================
```
package me.gm.cleaner.plugin.util

import android.app.RecoverableSecurityException
import android.content.IntentSender
import android.net.Uri
import android.os.Build
import android.provider.MediaStore
import androidx.annotation.RequiresApi
import androidx.fragment.app.Fragment
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

object MediaStoreCompat {

    // @see https://developer.android.com/training/data-storage/shared/media#remove-item
    suspend fun delete(fragment: Fragment, uri: Uri): Boolean = withContext(Dispatchers.IO) {
        try {
            /**
             * In [Build.VERSION_CODES.Q] and above, it isn't possible to modify
             * or delete items in MediaStore directly, and explicit permission
             * must usually be obtained to do this.
             *
             * The way it works is the OS will throw a [RecoverableSecurityException],
             * which we can catch here. Inside there's an [IntentSender] which the
             * activity can use to prompt the user to grant permission to the item
             * so it can be either updated or deleted.
             */
            fragment.requireContext().contentResolver.delete(uri, null, null)
            return@withContext true
        } catch (securityException: SecurityException) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                val recoverableSecurityException =
                    securityException as? RecoverableSecurityException
                        ?: throw securityException
                fragment.startIntentSenderForResult(
                    recoverableSecurityException.userAction.actionIntent.intentSender,
                    DELETE_PERMISSION_REQUEST, null, 0, 0, 0, null
                )
                return@withContext false
            } else {
                throw securityException
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun delete(fragment: Fragment, uris: Collection<Uri>) {
        if (uris.isEmpty()) {
            // This check is important because media store iterates to the first element without check.
            // Pass an empty collection to createRequest results in NoSuchElementException.
            return
        }
        return withContext(Dispatchers.IO) {
            val pendingIntent = MediaStore.createDeleteRequest(
                fragment.requireContext().contentResolver, uris
            )
            fragment.startIntentSenderForResult(
                pendingIntent.intentSender, DELETE_PERMISSION_REQUEST, null, 0, 0, 0, null
            )
        }
    }

    /**
     * Code used with [IntentSender] to request user permission to delete an image with scoped storage.
     */
    const val DELETE_PERMISSION_REQUEST = 0x1033
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/NaturalSorter.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://gist.github.com/seven332/eadc44f1b35f756e46c410a8487fcc1d

package me.gm.cleaner.plugin.util;

import java.math.BigInteger;
import java.text.Collator;
import java.util.Comparator;

public class NaturalSorter implements Comparator<String> {
    private static final Collator collator = Collator.getInstance();

    @Override
    public int compare(String o1, String o2) {
        int index1 = 0;
        int index2 = 0;
        while (true) {
            String data1 = nextSlice(o1, index1);
            String data2 = nextSlice(o2, index2);

            if (data1 == null && data2 == null) {
                return 0;
            }
            if (data1 == null) {
                return -1;
            }
            if (data2 == null) {
                return 1;
            }

            index1 += data1.length();
            index2 += data2.length();

            int result;
            if (isDigit(data1) && isDigit(data2)) {
                result = new BigInteger(data1).compareTo(new BigInteger(data2));
                if (result == 0) {
                    result = Integer.compare(data1.length(), data2.length());
                }
            } else {
                result = collator.compare(data1, data2);
            }

            if (result != 0) {
                return result;
            }
        }
    }

    private static boolean isDigit(String str) {
        // Just check the first char
        char ch = str.charAt(0);
        return ch >= '0' && ch <= '9';
    }

    static String nextSlice(String str, int index) {
        int length = str.length();
        if (index == length) {
            return null;
        }

        char ch = str.charAt(index);
        if (ch == '.' || ch == ' ') {
            return str.substring(index, index + 1);
        } else if (ch >= '0' && ch <= '9') {
            return str.substring(index, nextNumberBound(str, index + 1));
        } else {
            return str.substring(index, nextOtherBound(str, index + 1));
        }
    }

    private static int nextNumberBound(String str, int index) {
        for (int length = str.length(); index < length; index++) {
            char ch = str.charAt(index);
            if (ch < '0' || ch > '9') {
                break;
            }
        }
        return index;
    }

    private static int nextOtherBound(String str, int index) {
        for (int length = str.length(); index < length; index++) {
            char ch = str.charAt(index);
            if (ch == '.' || ch == ' ' || (ch >= '0' && ch <= '9')) {
                break;
            }
        }
        return index;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/PermissionUtils.kt
================================================
```
package me.gm.cleaner.plugin.util

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.provider.Settings
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.CallSuper
import androidx.core.app.ActivityCompat
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.commitNow
import me.gm.cleaner.plugin.app.BaseFragment

object PermissionUtils {
    private const val TAG = "PermissionUtils"
    fun requestPermissions(
        fragmentManager: FragmentManager, requesterFragment: RequesterFragment
    ) {
        fragmentManager.commitNow {
            val existingFragment = fragmentManager.findFragmentByTag(TAG)
            if (existingFragment != null) {
                remove(existingFragment)
            }
            add(requesterFragment, TAG)
        }
        requesterFragment.dispatchRequestPermissions(requesterFragment.requiredPermissions)
    }

    fun startDetailsSettings(context: Context) {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.fromParts("package", context.packageName, null)
        }
        context.startActivity(intent)
    }
}

abstract class RequesterFragment : BaseFragment() {
    open val requiredPermissions: Array<String> = emptyArray<String>()
    private lateinit var requestMultiplePermissions: ActivityResultLauncher<Array<String>>
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestMultiplePermissions =
            registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { result ->
                // We should dispatch by ourselves rather than call dispatchRequestPermissions(),
                // or we'll stick in infinite recursion.
                val granted = result.filterValues { it }.keys
                if (granted.isNotEmpty()) {
                    onRequestPermissionsSuccess(granted)
                }
                val denied = result.keys - granted
                if (denied.isNotEmpty()) {
                    val shouldShowRationale = denied.filter {
                        ActivityCompat.shouldShowRequestPermissionRationale(requireActivity(), it)
                    }.toSet()
                    onRequestPermissionsFailure(
                        shouldShowRationale, denied - shouldShowRationale
                    )
                }
            }
    }

    @CallSuper
    internal fun dispatchRequestPermissions(permissions: Array<String>) {
        val granted = permissions.filter {
            ActivityCompat.checkSelfPermission(requireContext(), it) ==
                    PackageManager.PERMISSION_GRANTED
        }.toSet()
        if (permissions.size > granted.size) {
            val denied = permissions.toSet() - granted
            val shouldShowRationale = denied.filter {
                ActivityCompat.shouldShowRequestPermissionRationale(requireActivity(), it)
            }.toSet()
            if (shouldShowRationale.isNotEmpty()) {
                onRequestPermissionsFailure(shouldShowRationale, emptySet())
            } else {
                onRequestPermissions(denied.toTypedArray())
            }
        }
    }

    protected fun onRequestPermissions(permissions: Array<String>) {
        requestMultiplePermissions.launch(permissions)
    }

    protected open fun onRequestPermissionsSuccess(permissions: Set<String>) {
    }

    protected open fun onRequestPermissionsFailure(
        shouldShowRationale: Set<String>, denied: Set<String>
    ) {
    }

    override fun onDestroyView() {
        super.onDestroyView()
        requestMultiplePermissions.unregister()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/BottomActionBar.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.widget;

import static java.lang.Math.min;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.os.Build.VERSION;
import android.util.AttributeSet;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.view.SupportMenuInflater;
import androidx.appcompat.view.menu.MenuBuilder;
import androidx.appcompat.widget.TintTypedArray;
import androidx.core.content.ContextCompat;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.google.android.material.drawable.DrawableUtils;
import com.google.android.material.internal.ThemeEnforcement;
import com.google.android.material.internal.ViewUtils;
import com.google.android.material.internal.ViewUtils.RelativePadding;
import com.google.android.material.shape.MaterialShapeDrawable;
import com.google.android.material.shape.ShapeAppearanceModel;

import me.gm.cleaner.plugin.R;

@SuppressLint("RestrictedApi")
public class BottomActionBar extends FrameLayout {
    private MenuInflater menuInflater;
    private final MenuBuilder menu;
    @NonNull
    private final BottomActionBarMenuView menuView;

    public BottomActionBar(@NonNull Context context) {
        this(context, null);
    }

    public BottomActionBar(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, com.google.android.material.R.attr.bottomNavigationStyle);
    }

    public BottomActionBar(
            @NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, com.google.android.material.R.attr.bottomNavigationStyle);
    }

    public BottomActionBar(
            @NonNull Context context,
            @Nullable AttributeSet attrs,
            int defStyleAttr,
            int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);

        // Ensure we are using the correctly themed context rather than the context that was passed in.
        context = getContext();

        /* Custom attributes */
        TintTypedArray attributes =
                ThemeEnforcement.obtainTintedStyledAttributes(
                        context, attrs, R.styleable.BottomActionBar, defStyleAttr, defStyleRes);

        this.menu = new MenuBuilder(context);
        this.menuView = createNavigationBarMenuView(context);
        this.menuView.initialize(menu);
        if (attributes.hasValue(R.styleable.BottomActionBar_menu)) {
            inflateMenu(attributes.getResourceId(R.styleable.BottomActionBar_menu, 0));
        }

        // Add a MaterialShapeDrawable as background that supports tinting in every API level.
        Drawable background = getBackground();
        ColorStateList backgroundColorStateList = DrawableUtils.getColorStateListOrNull(background);

        if (background == null || backgroundColorStateList != null) {
            ShapeAppearanceModel shapeAppearanceModel =
                    ShapeAppearanceModel.builder(context, attrs, defStyleAttr, defStyleRes).build();
            MaterialShapeDrawable materialShapeDrawable = new MaterialShapeDrawable(shapeAppearanceModel);
            if (backgroundColorStateList != null) {
                // Setting fill color with a transparent CSL will disable the tint list.
                materialShapeDrawable.setFillColor(backgroundColorStateList);
            }
            materialShapeDrawable.initializeElevationOverlay(context);
            ViewCompat.setBackground(this, materialShapeDrawable);
        }

        if (shouldDrawCompatibilityTopDivider()) {
            addCompatibilityTopDivider(context);
        }

        attributes.recycle();

        addView(menuView);

        applyWindowInsets();
    }

    @NonNull
    protected BottomActionBarMenuView createNavigationBarMenuView(@NonNull Context context) {
        return new BottomActionBarMenuView(context);
    }

    /**
     * Inflate a menu resource into this navigation view.
     *
     * <p>Existing items in the menu will not be modified or removed.
     *
     * @param resId ID of a menu resource to inflate
     */
    public void inflateMenu(int resId) {
        if (menuInflater == null) {
            menuInflater = new SupportMenuInflater(getContext());
        }
        menuInflater.inflate(resId, menu);
        menuView.buildMenuView();
    }

    public void show() {
        setVisibility(View.VISIBLE);
    }

    public void hide() {
        setVisibility(View.GONE);
    }

    private void applyWindowInsets() {
        ViewUtils.doOnApplyWindowInsets(
                this,
                new ViewUtils.OnApplyWindowInsetsListener() {
                    @NonNull
                    @Override
                    public WindowInsetsCompat onApplyWindowInsets(
                            View view,
                            @NonNull WindowInsetsCompat insets,
                            @NonNull RelativePadding initialPadding) {
                        // Apply the bottom, start, and end padding for a BottomActionBar
                        // to dodge the system navigation bar
                        initialPadding.bottom += insets.getSystemWindowInsetBottom();

                        boolean isRtl = ViewCompat.getLayoutDirection(view) == ViewCompat.LAYOUT_DIRECTION_RTL;
                        int systemWindowInsetLeft = insets.getSystemWindowInsetLeft();
                        int systemWindowInsetRight = insets.getSystemWindowInsetRight();
                        initialPadding.start += isRtl ? systemWindowInsetRight : systemWindowInsetLeft;
                        initialPadding.end += isRtl ? systemWindowInsetLeft : systemWindowInsetRight;
                        initialPadding.applyToView(view);
                        return insets;
                    }
                });
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int minHeightSpec = makeMinHeightSpec(heightMeasureSpec);
        super.onMeasure(widthMeasureSpec, minHeightSpec);
    }

    private int makeMinHeightSpec(int measureSpec) {
        int minHeight = getSuggestedMinimumHeight();
        if (MeasureSpec.getMode(measureSpec) != MeasureSpec.EXACTLY && minHeight > 0) {
            minHeight += getPaddingTop() + getPaddingBottom();

            return MeasureSpec.makeMeasureSpec(
                    min(MeasureSpec.getSize(measureSpec), minHeight), MeasureSpec.EXACTLY);
        }

        return measureSpec;
    }

    /**
     * Returns true a divider must be added in place of shadows to maintain compatibility in pre-21
     * legacy backgrounds.
     */
    private boolean shouldDrawCompatibilityTopDivider() {
        return VERSION.SDK_INT < 21 && !(getBackground() instanceof MaterialShapeDrawable);
    }

    /**
     * Adds a divider in place of shadows to maintain compatibility in pre-21 legacy backgrounds. If a
     * pre-21 background has been updated to a MaterialShapeDrawable, MaterialShapeDrawable will draw
     * shadows instead.
     */
    private void addCompatibilityTopDivider(@NonNull Context context) {
        View divider = new View(context);
        divider.setBackgroundColor(
                ContextCompat.getColor(
                        context,
                        com.google.android.material.R.color.design_bottom_navigation_shadow_color));
        LayoutParams dividerParams =
                new LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        getResources().getDimensionPixelSize(
                                com.google.android.material.
                                        R.dimen.design_bottom_navigation_shadow_height));
        divider.setLayoutParams(dividerParams);
        addView(divider);
    }

    public void setOnMenuItemClickListener(@Nullable MenuItem.OnMenuItemClickListener listener) {
        if (listener == null) {
            menu.setCallback(null);
        } else {
            menu.setCallback(new MenuBuilder.Callback() {
                @Override
                public boolean onMenuItemSelected(@NonNull MenuBuilder menu, @NonNull MenuItem item) {
                    return listener.onMenuItemClick(item);
                }

                @Override
                public void onMenuModeChange(@NonNull MenuBuilder menu) {
                }
            });
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/BottomActionBarMenuView.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.widget;

import android.annotation.SuppressLint;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.LinearLayout;

import androidx.annotation.NonNull;
import androidx.appcompat.view.menu.MenuBuilder;
import androidx.appcompat.view.menu.MenuItemImpl;
import androidx.appcompat.view.menu.MenuView;
import androidx.appcompat.widget.TooltipCompat;
import androidx.core.view.ViewCompat;

import me.gm.cleaner.plugin.databinding.DesignBottomBarItemBinding;

@SuppressLint("RestrictedApi")
public class BottomActionBarMenuView extends LinearLayout implements MenuView {
    @NonNull
    private final OnClickListener onClickListener =
            new OnClickListener() {
                @Override
                public void onClick(View v) {
                    MenuItem item = (MenuItem) v.getTag();
                    menu.performItemAction(item, null, 0);
                }
            };

    private MenuBuilder menu;

    public BottomActionBarMenuView(@NonNull Context context) {
        super(context);

        setOrientation(LinearLayout.HORIZONTAL);

        ViewCompat.setImportantForAccessibility(this, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
    }

    @Override
    public void initialize(MenuBuilder menu) {
        this.menu = menu;
    }

    @Override
    public int getWindowAnimations() {
        return 0;
    }

    private DesignBottomBarItemBinding getNewItem() {
        return DesignBottomBarItemBinding.inflate(LayoutInflater.from(getContext()), this, false);
    }

    public void buildMenuView() {
        removeAllViews();

        for (int i = 0; i < menu.size(); i++) {
            DesignBottomBarItemBinding itemBinding = getNewItem();
            MenuItemImpl item = (MenuItemImpl) menu.getItem(i);
            itemBinding.navigationBarItemIconView.setImageDrawable(item.getIcon());
            itemBinding.navigationBarItemSmallLabelView.setText(item.getTitle());
            View child = itemBinding.getRoot();
            child.setOnClickListener(onClickListener);
            child.setTag(item);
            TooltipCompat.setTooltipText(child, item.getTitle());
            addView(child);
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/DrawerHeader.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.widget

import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.WindowInsets
import android.widget.LinearLayout
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes

class DrawerHeader @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, @AttrRes defStyleAttr: Int = 0,
    @StyleRes defStyleRes: Int = 0
) : LinearLayout(context, attrs, defStyleAttr, defStyleRes) {

    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets {
        val localInsets = Rect()
        val result = computeSystemWindowInsets(insets, localInsets)
        val displayCutout = insets.displayCutout
        if (displayCutout != null) {
            localInsets.top = displayCutout.safeInsetTop
        }
        applyInsets(localInsets)
        return result
    }

    private fun applyInsets(insets: Rect) {
        setPaddingRelative(0, insets.top, 0, 0)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FitsHorizontalInsetsCoordinatorLayout.kt
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.widget

import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.WindowInsets
import androidx.annotation.AttrRes
import androidx.coordinatorlayout.widget.CoordinatorLayout

class FitsHorizontalInsetsCoordinatorLayout @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, @AttrRes defStyleAttr: Int = 0
) : CoordinatorLayout(context, attrs, defStyleAttr) {
    private val mPaddingLeft = paddingLeft
    private val mPaddingTop = paddingTop
    private val mPaddingRight = paddingRight
    private val mPaddingBottom = paddingBottom

    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets {
        val localInsets = Rect()
        val result = computeSystemWindowInsets(insets, localInsets)
        applyInsets(localInsets)
        // Return "result" will consume the insets.
        return insets
    }

    private fun applyInsets(insets: Rect) {
        setPadding(
            mPaddingLeft + insets.left, mPaddingTop,
            mPaddingRight + insets.right, mPaddingBottom
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FixLayoutSearchView.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.widget

import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.annotation.AttrRes
import androidx.appcompat.R
import androidx.appcompat.widget.SearchView
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePaddingRelative
import me.gm.cleaner.plugin.ktx.dpToPx
import me.gm.cleaner.plugin.ktx.getDrawableByAttr

open class FixLayoutSearchView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null,
    @AttrRes defStyleAttr: Int = R.attr.searchViewStyle
) : SearchView(context, attrs, defStyleAttr) {

    // abc_search_view.xml
    init {
        // A negative value won't work here because SearchView will use its preferred width as max
        // width instead.
        maxWidth = Int.MAX_VALUE
        val searchEditFrame = findViewById<View>(R.id.search_edit_frame)
        // 72 - 60 + 0 = 12
        searchEditFrame.updateLayoutParams<MarginLayoutParams> {
            leftMargin = 12
            rightMargin = 12
        }
        val searchSrcText = findViewById<View>(R.id.search_src_text)
        searchSrcText.setPaddingRelative(0, searchSrcText.top, 0, searchSrcText.paddingBottom)
        val searchCloseBtn = findViewById<View>(R.id.search_close_btn)
        val searchCloseBtnPaddingHorizontal = searchCloseBtn.context.dpToPx(12)
        searchCloseBtn.updatePaddingRelative(
            start = searchCloseBtnPaddingHorizontal, end = searchCloseBtnPaddingHorizontal
        )
        searchCloseBtn.background =
            searchCloseBtn.context.getDrawableByAttr(R.attr.actionBarItemBackground)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FixQueryChangeSearchView.kt
================================================
```
package me.gm.cleaner.plugin.widget

import android.content.Context
import android.util.AttributeSet
import androidx.annotation.AttrRes

class FixQueryChangeSearchView : FixLayoutSearchView {
    var shouldIgnoreQueryChange = false
        private set

    constructor(context: Context) : super(context)

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)

    constructor(context: Context, attrs: AttributeSet?, @AttrRes defStyleAttr: Int) : super(
        context, attrs, defStyleAttr
    )

    override fun setIconified(iconify: Boolean) {
        shouldIgnoreQueryChange = true
        super.setIconified(iconify)
        shouldIgnoreQueryChange = false
    }

    override fun onActionViewCollapsed() {
        shouldIgnoreQueryChange = true
        super.onActionViewCollapsed()
        shouldIgnoreQueryChange = false
    }

    override fun onActionViewExpanded() {
        shouldIgnoreQueryChange = true
        super.onActionViewExpanded()
        shouldIgnoreQueryChange = false
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/ThemedSwipeRefreshLayout.kt
================================================
```
package me.gm.cleaner.plugin.widget

import android.content.Context
import android.util.AttributeSet
import androidx.swiperefreshlayout.widget.ThemedSwipeRefreshLayout
import me.gm.cleaner.plugin.ktx.getDimenByAttr

class ThemedSwipeRefreshLayout(context: Context, attrs: AttributeSet?) :
    ThemedSwipeRefreshLayout(context, attrs) {

    private fun init() {
        val actionBarSizeAddTabHeight = context.getDimenByAttr(android.R.attr.actionBarSize).toInt()
        setProgressViewOffset(
            false, actionBarSizeAddTabHeight, progressViewEndOffset + actionBarSizeAddTabHeight
        )
    }

    init {
        init()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/JsonFileSpImpl.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed;

import android.text.TextUtils;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;

import de.robv.android.xposed.XposedBridge;
import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl;
import me.gm.cleaner.plugin.dao.SharedPreferencesWrapper;

public class JsonFileSpImpl extends SharedPreferencesWrapper {
    public final File file;
    protected String contentCache;

    public JsonFileSpImpl(File src) {
        file = src;

        JSONObject json;
        try {
            var str = read();
            if (TextUtils.isEmpty(str)) {
                // don't throw an exception in this case.
                json = new JSONObject();
            } else {
                json = new JSONObject(str);
            }
        } catch (JSONException e) {
            json = new JSONObject();
        }
        delegate = new JsonSharedPreferencesImpl(json);
    }

    private void ensureFile() {
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                XposedBridge.log(e);
                throw new RuntimeException(e);
            }
        }
    }

    public String read() {
        if (contentCache == null) {
            ensureFile();
            try (var it = new FileInputStream(file)) {
                var bb = ByteBuffer.allocate(it.available());
                it.getChannel().read(bb);
                contentCache = new String(bb.array());
            } catch (IOException e) {
                XposedBridge.log(e);
            }
        }
        return contentCache;
    }

    public void write(String what) {
        contentCache = what;
        try {
            delegate = new JsonSharedPreferencesImpl(new JSONObject(what));
        } catch (JSONException ignored) {
        }

        ensureFile();
        var bb = ByteBuffer.wrap(what.getBytes());
        try (var it = new FileOutputStream(file)) {
            it.getChannel().write(bb);
        } catch (IOException e) {
            XposedBridge.log(e);
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/ManagerService.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed

import android.content.Context
import android.content.pm.PackageInfo
import android.content.res.Resources
import android.os.*
import androidx.room.Room
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.IManagerService
import me.gm.cleaner.plugin.IMediaChangeObserver
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MIGRATION_1_2
import me.gm.cleaner.plugin.dao.MediaProviderRecordDao
import me.gm.cleaner.plugin.dao.MediaProviderRecordDatabase
import me.gm.cleaner.plugin.model.ParceledListSlice
import java.io.File

abstract class ManagerService : IManagerService.Stub() {
    lateinit var classLoader: ClassLoader
        protected set
    lateinit var resources: Resources
        protected set
    lateinit var context: Context
        private set
    private lateinit var database: MediaProviderRecordDatabase
    lateinit var dao: MediaProviderRecordDao
        private set
    private val observers = RemoteCallbackList<IMediaChangeObserver>()
    val rootSp by lazy { JsonFileSpImpl(File(context.filesDir, "root")) }
    val ruleSp by lazy { TemplatesJsonFileSpImpl(File(context.filesDir, "rule")) }

    protected fun onCreate(context: Context) {
        this.context = context
        database = Room
            .databaseBuilder(
                context,
                MediaProviderRecordDatabase::class.java,
                MEDIA_PROVIDER_USAGE_RECORD_DATABASE_NAME
            )
            .addMigrations(MIGRATION_1_2)
            .build()
        dao = database.mediaProviderRecordDao()
    }

    private val packageManagerService: IInterface by lazy {
        val binder = XposedHelpers.callStaticMethod(
            XposedHelpers.findClass("android.os.ServiceManager", classLoader),
            "getService", "package"
        ) as IBinder
        XposedHelpers.callStaticMethod(
            XposedHelpers.findClass(
                "android.content.pm.IPackageManager\$Stub", classLoader
            ), "asInterface", binder
        ) as IInterface
    }

    override fun getModuleVersion() = BuildConfig.VERSION_CODE

    override fun getInstalledPackages(userId: Int, flags: Int): ParceledListSlice<PackageInfo> {
        val parceledListSlice = XposedHelpers.callMethod(
            packageManagerService,
            "getInstalledPackages",
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) flags.toLong() else flags,
            userId
        )
        val list = XposedHelpers.callMethod(parceledListSlice, "getList") as List<PackageInfo>
        return ParceledListSlice(list)
    }

    override fun getPackageInfo(packageName: String, flags: Int, userId: Int) =
        XposedHelpers.callMethod(
            packageManagerService,
            "getPackageInfo",
            packageName,
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) flags.toLong() else flags,
            userId
        ) as? PackageInfo

    override fun readSp(who: Int): String? = when (who) {
        R.xml.root_preferences -> rootSp.read()
        R.xml.template_preferences -> ruleSp.read()
        else -> throw IllegalArgumentException()
    }

    override fun writeSp(who: Int, what: String) {
        when (who) {
            R.xml.root_preferences -> rootSp.write(what)
            R.xml.template_preferences -> ruleSp.write(what)
        }
    }

    override fun clearAllTables() {
        database.clearAllTables()
    }

    override fun packageUsageTimes(operation: Int, packageNames: List<String>) =
        dao.packageUsageTimes(operation, *packageNames.toTypedArray())

    override fun registerMediaChangeObserver(observer: IMediaChangeObserver) {
        observers.register(observer)
    }

    override fun unregisterMediaChangeObserver(observer: IMediaChangeObserver) {
        observers.unregister(observer)
    }

    @Synchronized
    fun dispatchMediaChange() {
        var i = observers.beginBroadcast()
        while (i > 0) {
            i--
            val observer = observers.getBroadcastItem(i)
            if (observer != null) {
                try {
                    observer.onChange()
                } catch (ignored: RemoteException) {
                }
            }
        }
        observers.finishBroadcast()
    }

    companion object {
        const val MEDIA_PROVIDER_USAGE_RECORD_DATABASE_NAME = "media_provider.db"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/TemplatesJsonFileSpImpl.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed;

import java.io.File;

import me.gm.cleaner.plugin.model.Templates;

public final class TemplatesJsonFileSpImpl extends JsonFileSpImpl {
    private volatile Templates templatesCache;

    public TemplatesJsonFileSpImpl(File src) {
        super(src);
        templatesCache = new Templates(read());
    }

    @Override
    public void write(String what) {
        super.write(what);
        templatesCache = new Templates(what);
    }

    public Templates getTemplates() {
        return templatesCache;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/XposedInit.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed

import android.content.ContentProvider
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.ProviderInfo
import android.content.res.AssetManager
import android.content.res.Resources
import android.provider.MediaStore
import de.robv.android.xposed.*
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam
import me.gm.cleaner.plugin.xposed.hooker.DeleteHooker
import me.gm.cleaner.plugin.xposed.hooker.FileHooker
import me.gm.cleaner.plugin.xposed.hooker.InsertHooker
import me.gm.cleaner.plugin.xposed.hooker.QueryHooker
import java.io.File

class XposedInit : ManagerService(), IXposedHookLoadPackage, IXposedHookZygoteInit {

    @Throws(Throwable::class)
    private fun onMediaProviderLoaded(lpparam: LoadPackageParam, context: Context) {
        val mediaProvider = try {
            XposedHelpers.findClass(
                "com.android.providers.media.MediaProvider", lpparam.classLoader
            )
        } catch (e: XposedHelpers.ClassNotFoundError) {
            return
        }
        // only save MediaProvider's classLoader
        classLoader = lpparam.classLoader
        onCreate(context)
        XposedBridge.hookAllMethods(
            mediaProvider, "queryInternal", QueryHooker(this@XposedInit)
        )
        XposedBridge.hookAllMethods(
            mediaProvider, "insertFile", InsertHooker(this@XposedInit)
        )
        XposedBridge.hookAllMethods(
            mediaProvider, "deleteInternal", DeleteHooker(this@XposedInit)
        )
    }

    @Throws(Throwable::class)
    private fun onDownloadManagerLoaded(lpparam: LoadPackageParam, context: Context) {
        XposedHelpers.findAndHookMethod(File::class.java, "mkdir", FileHooker())
        XposedHelpers.findAndHookMethod(File::class.java, "mkdirs", FileHooker())
    }

    @Throws(Throwable::class)
    override fun handleLoadPackage(lpparam: LoadPackageParam) {
        if (lpparam.appInfo.flags and ApplicationInfo.FLAG_SYSTEM == 0) {
            return
        }
        XposedHelpers.findAndHookMethod(
            ContentProvider::class.java, "attachInfo",
            Context::class.java, ProviderInfo::class.java, Boolean::class.java,
            object : XC_MethodHook() {
                @Throws(Throwable::class)
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val context = param.args[0] as Context
                    val providerInfo = param.args[1] as ProviderInfo

                    when (providerInfo.authority) {
                        MediaStore.AUTHORITY -> onMediaProviderLoaded(lpparam, context)
                        Downloads_Impl_AUTHORITY -> onDownloadManagerLoaded(lpparam, context)
                    }
                }
            }
        )
    }

    @Throws(Throwable::class)
    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam) {
        val assetManager = AssetManager::class.java.newInstance()
        XposedHelpers.callMethod(assetManager, "addAssetPath", startupParam.modulePath)
        resources = Resources(assetManager, null, null)
    }

    companion object {
        const val Downloads_Impl_AUTHORITY = "downloads"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/DeleteHooker.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.hooker

import android.app.RecoverableSecurityException
import android.content.ContentResolver.QUERY_ARG_SQL_SELECTION
import android.content.ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS
import android.database.Cursor
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore.Files.FileColumns
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import java.io.File

class DeleteHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        /** ARGUMENTS */
        val uri = param.args[0] as Uri
        val extras = param.args[1] as? Bundle ?: Bundle.EMPTY
        val userWhere: String? = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> extras?.getString(
                QUERY_ARG_SQL_SELECTION
            )

            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> param.args[1] as? String
            else -> throw UnsupportedOperationException()
        }
        val userWhereArgs: Array<String>? = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> extras?.getStringArray(
                QUERY_ARG_SQL_SELECTION_ARGS
            )

            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> param.args[2] as? Array<String>
            else -> throw UnsupportedOperationException()
        }

        /** PARSE */
        val match = param.matchUri(uri, param.isCallingPackageAllowedHidden)
        val data = mutableListOf<String>()
        val mimeType = mutableListOf<String>()
        when (match) {
            AUDIO_MEDIA_ID, VIDEO_MEDIA_ID, IMAGES_MEDIA_ID -> {
                try {
                    when {
                        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                            param.thisObject, "enforceCallingPermission", uri, extras, true
                        )

                        Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                            param.thisObject, "enforceCallingPermission", uri, true
                        )
                    }
                } catch (e: XposedHelpers.InvocationTargetError) {
                    if (e.cause is RecoverableSecurityException) {
                        // Give callers interacting with a specific media item a chance to
                        // escalate access if they don't already have it
                        return
                    }
                }

                val qb = when {
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_DELETE, match, uri,
                        extras, null
                    )

                    Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_DELETE, uri, match, null
                    )

                    else -> throw UnsupportedOperationException()
                }
                val helper = XposedHelpers.callMethod(param.thisObject, "getDatabaseForUri", uri)
                val projection = arrayOf(
                    FileColumns.MEDIA_TYPE,
                    FileColumns.DATA,
                    FileColumns._ID,
                    FileColumns.IS_DOWNLOAD,
                    FileColumns.MIME_TYPE,
                )

                val c = when {
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                        qb, "query", helper, projection, userWhere, userWhereArgs,
                        null, null, null, null, null
                    )

                    Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                        qb, "query", XposedHelpers.callMethod(helper, "getWritableDatabase"),
                        projection, userWhere, userWhereArgs, null, null, null, null, null
                    )

                    else -> throw UnsupportedOperationException()
                } as Cursor
                if (c.count == 0) {
                    // deleting nothing.
                    c.close()
                    return
                }
                while (c.moveToNext()) {
                    data += c.getString(1)
                    mimeType += c.getString(4)
                }
                c.close()
            }

            FILES -> if (userWhereArgs != null) {
                data += userWhereArgs
                data.mapTo(mimeType) { MimeUtils.resolveMimeType(File(it)) }
            }

            else -> return // We don't care about these data, just ignore.
        }

        // There is a system confirm dialog before deletion, thus we don't intercept delete operation.

        /** RECORD */
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    param.callingPackage,
                    match,
                    OP_DELETE,
                    data,
                    mimeType,
                    MutableList(data.size) { false }
                )
            )
            service.dispatchMediaChange()
        }
    }

    private val TYPE_DELETE: Int = when {
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> 3
        Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> 2
        else -> throw UnsupportedOperationException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/FileHooker.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.hooker

import android.os.Environment
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import me.gm.cleaner.plugin.xposed.util.FileUtils
import java.io.File

class FileHooker : XC_MethodHook() {
    private val standardParents: List<File> =
        FileUtils.standardDirs.map { type -> Environment.getExternalStoragePublicDirectory(type) } +
                FileUtils.androidDir

    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        val file = param.thisObject as File
        if (FileUtils.contains(FileUtils.externalStorageDirPath, file) &&
            standardParents.none { FileUtils.contains(it, file) }
        ) {
            XposedBridge.log("rejected ${param.method.name}: $file")
            param.result = false
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/InsertHooker.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.hooker

import android.content.ClipDescription
import android.content.ContentValues
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.os.FileUtils
import android.provider.MediaStore
import android.text.TextUtils
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import java.io.File
import java.util.*

class InsertHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        /** ARGUMENTS */
        val match = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[2] else param.args[1]
                ) as Int
        val uri = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[3] else param.args[2]
                ) as Uri
        val extras = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[4] else Bundle.EMPTY
                ) as Bundle
        val values = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[5] else param.args[3]
                ) as ContentValues
        val mediaType = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[6] else param.args[4]
                ) as Int

        /** PARSE */
        var mimeType = values.getAsString(MediaStore.MediaColumns.MIME_TYPE)
        val wasPathEmpty = wasPathEmpty(values)
        if (wasPathEmpty) {
            // Generate path when undefined
            ensureUniqueFileColumns(param.thisObject, match, uri, values, mimeType)
        }
        val data = values.getAsString(MediaStore.MediaColumns.DATA)
        if (mimeType.isNullOrEmpty()) {
            mimeType = values.getAsString(MediaStore.MediaColumns.MIME_TYPE)
            // Restore to support apps not targeting sdk R or higher
            values.remove(MediaStore.MediaColumns.MIME_TYPE)
        }
        if (wasPathEmpty) {
            // Restore to allow mkdir
            values.remove(MediaStore.MediaColumns.DATA)
        }

        /** INTERCEPT */
        val shouldIntercept = service.ruleSp.templates
            .filterTemplate(javaClass, param.callingPackage)
            .applyTemplates(listOf(data), listOf(mimeType)).first()
        if (shouldIntercept) {
            param.result = null
        }

        /** RECORD */
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    param.callingPackage,
                    match,
                    OP_INSERT,
                    listOf(data),
                    listOf(mimeType),
                    listOf(shouldIntercept)
                )
            )
            service.dispatchMediaChange()
        }
    }

    private fun wasPathEmpty(values: ContentValues) =
        !values.containsKey(MediaStore.MediaColumns.DATA)
                || values.getAsString(MediaStore.MediaColumns.DATA).isEmpty()

    private fun ensureUniqueFileColumns(
        thisObject: Any, match: Int, uri: Uri, values: ContentValues, mimeType: String?
    ) {
        var defaultMimeType = ClipDescription.MIMETYPE_UNKNOWN
        var defaultPrimary = Environment.DIRECTORY_DOWNLOADS
        var defaultSecondary: String? = null
        when (match) {
            AUDIO_MEDIA, AUDIO_MEDIA_ID -> {
                defaultMimeType = "audio/mpeg"
                defaultPrimary = Environment.DIRECTORY_MUSIC
            }

            VIDEO_MEDIA, VIDEO_MEDIA_ID -> {
                defaultMimeType = "video/mp4"
                defaultPrimary = Environment.DIRECTORY_MOVIES
            }

            IMAGES_MEDIA, IMAGES_MEDIA_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_PICTURES
            }

            AUDIO_ALBUMART, AUDIO_ALBUMART_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_MUSIC
                defaultSecondary = DIRECTORY_THUMBNAILS
            }

            VIDEO_THUMBNAILS, VIDEO_THUMBNAILS_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_MOVIES
                defaultSecondary = DIRECTORY_THUMBNAILS
            }

            IMAGES_THUMBNAILS, IMAGES_THUMBNAILS_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_PICTURES
                defaultSecondary = DIRECTORY_THUMBNAILS
            }

            AUDIO_PLAYLISTS, AUDIO_PLAYLISTS_ID -> {
                defaultMimeType = "audio/mpegurl"
                defaultPrimary = Environment.DIRECTORY_MUSIC
            }

            DOWNLOADS, DOWNLOADS_ID -> {
                defaultPrimary = Environment.DIRECTORY_DOWNLOADS
            }
        }
        // Give ourselves reasonable defaults when missing
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME))) {
            values.put(MediaStore.MediaColumns.DISPLAY_NAME, System.currentTimeMillis().toString())
        }
        // Use default directories when missing
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.RELATIVE_PATH))) {
            if (defaultSecondary != null) {
                values.put(
                    MediaStore.MediaColumns.RELATIVE_PATH, "$defaultPrimary/$defaultSecondary/"
                )
            } else {
                values.put(MediaStore.MediaColumns.RELATIVE_PATH, "$defaultPrimary/")
            }
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val resolvedVolumeName = XposedHelpers.callMethod(
                thisObject, "resolveVolumeName", uri
            ) as String
            val volumePath = XposedHelpers.callMethod(
                thisObject, "getVolumePath", resolvedVolumeName
            ) as File

            val fileUtilsClass = XposedHelpers.findClass(
                "com.android.providers.media.util.FileUtils", service.classLoader
            )
            val isFuseThread = XposedHelpers.callMethod(thisObject, "isFuseThread")
                    as Boolean
            XposedHelpers.callStaticMethod(
                fileUtilsClass, "sanitizeValues", values, !isFuseThread
            )
            XposedHelpers.callStaticMethod(
                fileUtilsClass, "computeDataFromValues", values, volumePath, isFuseThread
            )

            var res = File(values.getAsString(MediaStore.MediaColumns.DATA))
            res = XposedHelpers.callStaticMethod(
                fileUtilsClass, "buildUniqueFile", res.parentFile, mimeType, res.name
            ) as File

            values.put(MediaStore.MediaColumns.DATA, res.absolutePath)
        } else {
            val resolvedVolumeName = XposedHelpers.callMethod(
                thisObject, "resolveVolumeName", uri
            ) as String

            val relativePath = XposedHelpers.callMethod(
                thisObject, "sanitizePath",
                values.getAsString(MediaStore.MediaColumns.RELATIVE_PATH)
            )
            val displayName = XposedHelpers.callMethod(
                thisObject, "sanitizeDisplayName",
                values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME)
            )

            var res = XposedHelpers.callMethod(
                thisObject, "getVolumePath", resolvedVolumeName
            ) as File
            res = XposedHelpers.callStaticMethod(
                Environment::class.java, "buildPath", res, relativePath
            ) as File
            res = XposedHelpers.callStaticMethod(
                FileUtils::class.java, "buildUniqueFile", res, mimeType, displayName
            ) as File

            values.put(MediaStore.MediaColumns.DATA, res.absolutePath)
        }

        val displayName = values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME)
        val mimeTypeFromExt = if (TextUtils.isEmpty(displayName)) null
        else MimeUtils.resolveMimeType(File(displayName))
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.MIME_TYPE))) {
            // Extract the MIME type from the display name if we couldn't resolve it from the
            // raw path
            if (mimeTypeFromExt != null) {
                values.put(MediaStore.MediaColumns.MIME_TYPE, mimeTypeFromExt)
            } else {
                // We couldn't resolve mimeType, it means that both display name and MIME type
                // were missing in values, so we use defaultMimeType.
                values.put(MediaStore.MediaColumns.MIME_TYPE, defaultMimeType)
            }
        }
    }

    companion object {
        private const val DIRECTORY_THUMBNAILS = ".thumbnails"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/MediaProviderHooker.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.hooker

import android.net.Uri
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers

interface MediaProviderHooker {
    fun XC_MethodHook.MethodHookParam.ensureMediaProvider() {
        require(method.declaringClass.name == "com.android.providers.media.MediaProvider")
    }

    val XC_MethodHook.MethodHookParam.isFuseThread: Boolean
        get() = try {
            val fuseDaemonCls = XposedHelpers.findClass(
                "com.android.providers.media.fuse.FuseDaemon", thisObject.javaClass.classLoader
            )
            XposedHelpers.callStaticMethod(fuseDaemonCls, "native_is_fuse_thread") as Boolean
        } catch (e: XposedHelpers.ClassNotFoundError) {
            false
        }

    val XC_MethodHook.MethodHookParam.callingPackage: String
        get() {
            ensureMediaProvider()
            val threadLocal =
                XposedHelpers.getObjectField(thisObject, "mCallingIdentity") as ThreadLocal<*>
            return XposedHelpers.callMethod(threadLocal.get(), "getPackageName") as String
        }

    val XC_MethodHook.MethodHookParam.isCallingPackageAllowedHidden: Boolean
        get() {
            ensureMediaProvider()
            return XposedHelpers.callMethod(thisObject, "isCallingPackageAllowedHidden") as Boolean
        }

    fun XC_MethodHook.MethodHookParam.matchUri(uri: Uri, allowHidden: Boolean): Int {
        ensureMediaProvider()
        return XposedHelpers.callMethod(thisObject, "matchUri", uri, allowHidden) as Int
    }

    val IMAGES_MEDIA: Int
        get() = 1
    val IMAGES_MEDIA_ID: Int
        get() = 2
    val IMAGES_MEDIA_ID_THUMBNAIL: Int
        get() = 3
    val IMAGES_THUMBNAILS: Int
        get() = 4
    val IMAGES_THUMBNAILS_ID: Int
        get() = 5

    val AUDIO_MEDIA: Int
        get() = 100
    val AUDIO_MEDIA_ID: Int
        get() = 101
    val AUDIO_MEDIA_ID_GENRES: Int
        get() = 102
    val AUDIO_MEDIA_ID_GENRES_ID: Int
        get() = 103
    val AUDIO_GENRES: Int
        get() = 106
    val AUDIO_GENRES_ID: Int
        get() = 107
    val AUDIO_GENRES_ID_MEMBERS: Int
        get() = 108
    val AUDIO_GENRES_ALL_MEMBERS: Int
        get() = 109
    val AUDIO_PLAYLISTS: Int
        get() = 110
    val AUDIO_PLAYLISTS_ID: Int
        get() = 111
    val AUDIO_PLAYLISTS_ID_MEMBERS: Int
        get() = 112
    val AUDIO_PLAYLISTS_ID_MEMBERS_ID: Int
        get() = 113
    val AUDIO_ARTISTS: Int
        get() = 114
    val AUDIO_ARTISTS_ID: Int
        get() = 115
    val AUDIO_ALBUMS: Int
        get() = 116
    val AUDIO_ALBUMS_ID: Int
        get() = 117
    val AUDIO_ARTISTS_ID_ALBUMS: Int
        get() = 118
    val AUDIO_ALBUMART: Int
        get() = 119
    val AUDIO_ALBUMART_ID: Int
        get() = 120
    val AUDIO_ALBUMART_FILE_ID: Int
        get() = 121

    val VIDEO_MEDIA: Int
        get() = 200
    val VIDEO_MEDIA_ID: Int
        get() = 201
    val VIDEO_MEDIA_ID_THUMBNAIL: Int
        get() = 202
    val VIDEO_THUMBNAILS: Int
        get() = 203
    val VIDEO_THUMBNAILS_ID: Int
        get() = 204

    val VOLUMES: Int
        get() = 300
    val VOLUMES_ID: Int
        get() = 301

    val MEDIA_SCANNER: Int
        get() = 500

    val FS_ID: Int
        get() = 600
    val VERSION: Int
        get() = 601

    val FILES: Int
        get() = 700
    val FILES_ID: Int
        get() = 701

    val DOWNLOADS: Int
        get() = 800
    val DOWNLOADS_ID: Int
        get() = 801
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/QueryHooker.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.hooker

import android.content.ContentResolver
import android.database.Cursor
import android.database.MatrixCursor
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.CancellationSignal
import android.provider.MediaStore
import android.provider.MediaStore.Files.FileColumns
import android.util.ArraySet
import androidx.core.os.bundleOf
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.FilteredCursor
import java.util.Optional
import java.util.function.Consumer
import java.util.function.Function

class QueryHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        /** ARGUMENTS */
        val uri = param.args[0] as Uri
        val projection = param.args[1] as? Array<String>?
        val queryArgs = param.args[2] as? Bundle ?: Bundle.EMPTY
        val signal = param.args[3] as? CancellationSignal

        if (param.callingPackage in
            setOf("com.android.providers.media", "com.android.providers.media.module")
        ) {
            // Scanning files and internal queries.
            return
        }

        /** PARSE */
        val query = Bundle(queryArgs)
        query.remove(INCLUDED_DEFAULT_DIRECTORIES)
        val honoredArgs = ArraySet<String>()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val databaseUtilsClass = XposedHelpers.findClass(
                "com.android.providers.media.util.DatabaseUtils", service.classLoader
            )
            XposedHelpers.callStaticMethod(
                databaseUtilsClass, "resolveQueryArgs", query, object : Consumer<String> {
                    override fun accept(t: String) {
                        honoredArgs.add(t)
                    }
                }, object : Function<String, String> {
                    override fun apply(t: String) = XposedHelpers.callMethod(
                        param.thisObject, "ensureCustomCollator", t
                    ) as String
                }
            )
        }
        if (isClientQuery(param.callingPackage, uri)) {
            param.result = handleClientQuery(projection, query)
            return
        }
        val table = param.matchUri(uri, param.isCallingPackageAllowedHidden)
        val dataProjection = when {
            projection == null -> null
            table in setOf(IMAGES_THUMBNAILS, VIDEO_THUMBNAILS) -> projection + FileColumns.DATA
            else -> projection + arrayOf(FileColumns.DATA, FileColumns.MIME_TYPE)
        }
        val helper = XposedHelpers.callMethod(param.thisObject, "getDatabaseForUri", uri)
        val qb = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                param.thisObject, "getQueryBuilder", TYPE_QUERY, table, uri, query,
                object : Consumer<String> {
                    override fun accept(t: String) {
                        honoredArgs.add(t)
                    }
                },
                Optional.empty<Any>()
            )

            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                param.thisObject, "getQueryBuilder", TYPE_QUERY, uri, table, query
            )

            else -> throw UnsupportedOperationException()
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val targetSdkVersion = XposedHelpers.callMethod(
                param.thisObject, "getCallingPackageTargetSdkVersion"
            ) as Int
            val databaseUtilsClass = XposedHelpers.findClass(
                "com.android.providers.media.util.DatabaseUtils", service.classLoader
            )
            if (targetSdkVersion < Build.VERSION_CODES.R) {
                // Some apps are abusing "ORDER BY" clauses to inject "LIMIT"
                // clauses; gracefully lift them out.
                XposedHelpers.callStaticMethod(databaseUtilsClass, "recoverAbusiveSortOrder", query)

                // Some apps are abusing the Uri query parameters to inject LIMIT
                // clauses; gracefully lift them out.
                XposedHelpers.callStaticMethod(
                    databaseUtilsClass, "recoverAbusiveLimit", uri, query
                )
            }
            if (targetSdkVersion < Build.VERSION_CODES.Q) {
                // Some apps are abusing the "WHERE" clause by injecting "GROUP BY"
                // clauses; gracefully lift them out.
                XposedHelpers.callStaticMethod(databaseUtilsClass, "recoverAbusiveSelection", query)
            }
        }

        val c = try {
            when {
                Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                    qb, "query", helper, dataProjection, query, signal
                )

                Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> {
                    val selection = query.getString(ContentResolver.QUERY_ARG_SQL_SELECTION)
                    val selectionArgs =
                        query.getStringArray(ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS)
                    val sortOrder =
                        query.getString(ContentResolver.QUERY_ARG_SQL_SORT_ORDER) ?: let {
                            if (query.containsKey(ContentResolver.QUERY_ARG_SORT_COLUMNS)) {
                                XposedHelpers.callStaticMethod(
                                    ContentResolver::class.java, "createSqlSortClause", query
                                ) as String?
                            } else {
                                null
                            }
                        }
                    val groupBy = if (table == AUDIO_ARTISTS_ID_ALBUMS) "audio.album_id"
                    else null
                    val having = null
                    val limit = uri.getQueryParameter("limit")

                    XposedHelpers.callMethod(
                        qb, "query", XposedHelpers.callMethod(helper, "getWritableDatabase"),
                        dataProjection, selection, selectionArgs, groupBy, having, sortOrder, limit,
                        signal
                    )
                }

                else -> throw UnsupportedOperationException()
            } as Cursor
        } catch (e: XposedHelpers.InvocationTargetError) {
            // IllegalArgumentException that thrown from the media provider. Nothing I can do.
            return
        }
        if (c.count == 0) {
            // querying nothing.
            c.close()
            return
        }
        val dataColumn = c.getColumnIndexOrThrow(FileColumns.DATA)
        val mimeTypeColumn = c.getColumnIndex(FileColumns.MIME_TYPE)

        val data = mutableListOf<String>()
        val mimeType = mutableListOf<String>()
        while (c.moveToNext()) {
            data += c.getString(dataColumn)
            mimeType += c.getString(mimeTypeColumn)
        }

        /** INTERCEPT */
        val shouldIntercept = service.ruleSp.templates
            .filterTemplate(javaClass, param.callingPackage)
            .applyTemplates(data, mimeType)
        if (shouldIntercept.isEmpty()) {
            c.close()
        } else {
            c.moveToFirst()
            val filter = shouldIntercept
                .mapIndexedNotNull { index, b ->
                    if (!b) index else null
                }
                .toIntArray()
            param.result = FilteredCursor.createUsingFilter(c, filter)
        }

        /** RECORD */
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    param.callingPackage,
                    table,
                    OP_QUERY,
                    if (data.size < MAX_SIZE) data else data.subList(0, MAX_SIZE),
                    mimeType,
                    shouldIntercept
                )
            )
            service.dispatchMediaChange()
        }
    }

    private fun isClientQuery(callingPackage: String, uri: Uri) =
        callingPackage == BuildConfig.APPLICATION_ID && uri == MediaStore.Images.Media.INTERNAL_CONTENT_URI

    /**
     * This function handles queries from the client. It takes effect when calling package is
     * [BuildConfig.APPLICATION_ID] and query Uri is [MediaStore.Images.Media.INTERNAL_CONTENT_URI].
     * @param table We regard projection as table name.
     * @param queryArgs We regard selection as start time millis, sort order as end time millis,
     * selection args as package names.
     * @return Returns an empty [Cursor] with [ManagerService]'s [android.os.IBinder] in its extras
     * when queryArgs is empty. Returns a [Cursor] queried from the [MediaProviderRecordDatabase]
     * when at least table name, start time millis and end time millis are declared.
     * @throws [NullPointerException] or [IllegalArgumentException] when we don't know how to
     * handle the query.
     */
    private fun handleClientQuery(table: Array<String>?, queryArgs: Bundle): Cursor {
        if (table == null || queryArgs.isEmpty) {
            return MatrixCursor(arrayOf("binder")).apply {
                extras = bundleOf("me.gm.cleaner.plugin.cursor.extra.BINDER" to service)
            }
        }
        val start = queryArgs.getString(ContentResolver.QUERY_ARG_SQL_SELECTION)!!.toLong()
        val end = queryArgs.getString(ContentResolver.QUERY_ARG_SQL_SORT_ORDER)!!.toLong()
        val packageNames = queryArgs.getStringArray(ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS)
        return service.dao.loadForTimeMillis(start, end, *table.map { it.toInt() }.toIntArray())
    }

    companion object {
        private const val INCLUDED_DEFAULT_DIRECTORIES = "android:included-default-directories"
        private const val TYPE_QUERY = 0

        private const val MAX_SIZE = 1000
    }
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FileCreationObserver.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.util;

import android.os.FileObserver;

import androidx.annotation.Nullable;

import java.io.File;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class FileCreationObserver extends FileObserver {
    private final File mTarget;
    private final Supplier<ScheduledExecutorService> mScheduler;
    private Predicate<Integer> mOnMaybeFileCreatedListener;
    private final AtomicInteger mQueueSize = new AtomicInteger();

    public FileCreationObserver(File file, Supplier<ScheduledExecutorService> scheduler) {
        super(file.getParentFile(), FileObserver.MODIFY | FileObserver.CREATE);
        mTarget = file;
        mScheduler = scheduler;
    }

    @Override
    public void onEvent(int event, @Nullable String path) {
        if (path == null) {
            return;
        }
        if (mTarget.getName().equals(path)) {
            mQueueSize.incrementAndGet();
            mScheduler.get().schedule(() -> {
                var queueSize = mQueueSize.decrementAndGet();
                var testTimes = 1 - queueSize;
                // Less than 0 when predicate returns false.
                if (queueSize <= 0 && mOnMaybeFileCreatedListener.test(testTimes)) {
                    stopWatching();
                }
            }, 5, TimeUnit.SECONDS);
        }
    }

    public FileCreationObserver setOnMaybeFileCreatedListener(Predicate<Integer> l) {
        mOnMaybeFileCreatedListener = l;
        return this;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FileUtils.kt
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.util

import android.annotation.SuppressLint
import android.os.Environment
import java.io.File

object FileUtils {
    fun contains(parent: File, child: File): Boolean = contains(parent.path, child.path)
    fun contains(parent: String, child: File): Boolean = contains(parent, child.path)
    fun contains(parent: File, child: String): Boolean = contains(parent.path, child)
    fun contains(parent: String, child: String): Boolean =
        child.equals(parent, true) || parent.equals(File.separator, true) ||
                child.startsWith(parent + File.separator, true)

    val externalStorageDirPath: String = Environment.getExternalStorageDirectory().path
    val androidDir: File = File(externalStorageDirPath, "Android")
    val standardDirs: Array<String>
        @Suppress("UNCHECKED_CAST")
        @SuppressLint("SoonBlockedPrivateApi")
        get() = Environment::class.java
            .getDeclaredField("STANDARD_DIRECTORIES")
            .apply { isAccessible = true }[null] as Array<String>
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FilteredCursor.java
================================================
```
/*
 * Copyright (C) 2014 Clover Network, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://github.com/clover/android-filteredcursor

package me.gm.cleaner.plugin.xposed.util;

import android.database.CharArrayBuffer;
import android.database.Cursor;
import android.database.CursorWrapper;

import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

/**
 * Wraps a Cursor and allowing its positions to be filtered out, repeated, or reordered. Common ways of creating
 * FilteredCursor objects are provided by the {@link FilteredCursorFactory}.
 * <p>
 * Note that if the source Cursor exceeds the size of the {@link android.database.CursorWindow} the FilteredCursor
 * may end up having extremely poor performance due to frequent CursorWindow cache misses. In those cases it is
 * recommended that source Cursor contain less data.
 *
 * @author Jacob Whitaker Abrams
 */
public class FilteredCursor extends CursorWrapper {

  // Globally map master Cursor to FilteredCursors, when all FilteredCursors are closed go ahead and close the master
  // This would need to go into a singleton if other classes similar to FilteredCursor exist
  private static final Map<Cursor, Set<FilteredCursor>> sMasterCursorMap =
          Collections.synchronizedMap(new WeakHashMap<Cursor, Set<FilteredCursor>>());

  private int[] mFilterMap;
  private int mPos = -1;
  private final Cursor mCursor;
  private boolean mClosed;

  /**
   * Create a FilteredCursor that appears identical to its wrapped Cursor.
   */
  public static FilteredCursor createUsingIdentityFilter(Cursor cursor) {
    if (cursor == null) {
      return null;
    }
    return new FilteredCursor(cursor);
  }

  /**
   * Create a new FilteredCursor using the given filter. The filter specifies where rows of the given Cursor should
   * appear in the FilteredCursor. For example if filter = { 5, 9 } then the FilteredCursor will have two rows, the
   * first row maps to row 5 in the source Cursor and the second row maps to row 9 in the source cursor. Returns null
   * if the provided cursor is null. A value of -1 in the filter is treated as an empty row in the Cursor with no data,
   * see {@link FilteredCursor#isPositionEmpty()}.
   */
  public static FilteredCursor createUsingFilter(Cursor cursor, int[] filter) {
    if (cursor == null) {
      return null;
    }
    if (filter == null) {
      throw new NullPointerException();
    }
    return new FilteredCursor(cursor, filter);
  }

  private FilteredCursor(Cursor cursor) {
    this(cursor, null);
    resetToIdentityFilter();
  }

  private FilteredCursor(Cursor cursor, int[] filterMap) {
    super(cursor);
    mCursor = cursor;
    mFilterMap = filterMap;
    attachToMasterCursor();
  }

  public int[] getFilterMap() {
    return mFilterMap;
  }

  /**
   * Reset the filter so it appears identical to its wrapped Cursor.
   */
  public FilteredCursor resetToIdentityFilter() {
    int count = mCursor.getCount();
    int[] filterMap = new int[count];

    for (int i = 0; i < count; i++) {
      filterMap[i] = i;
    }

    mFilterMap = filterMap;
    mPos = -1;
    return this;
  }

  /**
   * Returns true if the FilteredCursor appears identical to its wrapped Cursor.
   */
  public boolean isIdentityFilter() {
    int count = mCursor.getCount();
    if (mFilterMap.length != count) {
      return false;
    }

    for (int i = 0; i < count; i++) {
      if (mFilterMap[i] != i) {
        return false;
      }
    }

    return true;
  }

  /**
   * Rearrange the filter. The new arrangement is based on the current filter arrangement, not on the source Cursor's
   * arrangement.
   */
  public FilteredCursor refilter(int[] newArrangement) {
    final int newMapSize = newArrangement.length;
    int[] newMap = new int[newMapSize];
    for (int i = 0; i < newMapSize; i++) {
      newMap[i] = mFilterMap[newArrangement[i]];
    }

    mFilterMap = newMap;
    mPos = -1;
    return this;
  }

  /**
   * True if the current cursor position has no data. Attempting to access data in an empty row with any of the getters
   * will throw {@link UnsupportedOperationException}.
   */
  public boolean isPositionEmpty() {
    return mFilterMap[mPos] == -1;
  }

  private void throwIfEmptyRow() {
    if (isPositionEmpty()) {
      throw new UnsupportedOperationException("Cannot access data in an empty row");
    }
  }

  public void swapItems(int itemOne, int itemTwo) {
    int temp = mFilterMap[itemOne];
    mFilterMap[itemOne] = mFilterMap[itemTwo];
    mFilterMap[itemTwo] = temp;
  }

  @Override
  public int getCount() {
    return mFilterMap.length;
  }

  @Override
  public int getPosition() {
    return mPos;
  }

  @Override
  public boolean moveToPosition(int position) {
    // Make sure position isn't past the end of the cursor
    final int count = getCount();
    if (position >= count) {
      mPos = count;
      return false;
    }

    // Make sure position isn't before the beginning of the cursor
    if (position < 0) {
      mPos = -1;
      return false;
    }

    final int realPosition = mFilterMap[position];

    // When moving to an empty position, just pretend we did it
    boolean moved = realPosition == -1 || super.moveToPosition(realPosition);
    if (moved) {
      mPos = position;
    } else {
      mPos = -1;
    }
    return moved;
  }

  @Override
  public final boolean move(int offset) {
    return moveToPosition(mPos + offset);
  }

  @Override
  public final boolean moveToFirst() {
    return moveToPosition(0);
  }

  @Override
  public final boolean moveToLast() {
    return moveToPosition(getCount() - 1);
  }

  @Override
  public final boolean moveToNext() {
    return moveToPosition(mPos + 1);
  }

  @Override
  public final boolean moveToPrevious() {
    return moveToPosition(mPos - 1);
  }

  @Override
  public final boolean isFirst() {
    return mPos == 0 && getCount() != 0;
  }

  @Override
  public final boolean isLast() {
    int count = getCount();
    return mPos == (count - 1) && count != 0;
  }

  @Override
  public final boolean isBeforeFirst() {
    if (getCount() == 0) {
      return true;
    }
    return mPos == -1;
  }

  @Override
  public final boolean isAfterLast() {
    if (getCount() == 0) {
      return true;
    }
    return mPos == getCount();
  }

  @Override
  public boolean isNull(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.isNull(columnIndex);
  }

  @Override
  public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
    throwIfEmptyRow();
    mCursor.copyStringToBuffer(columnIndex, buffer);
  }

  @Override
  public byte[] getBlob(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getBlob(columnIndex);
  }

  @Override
  public double getDouble(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getDouble(columnIndex);
  }

  @Override
  public float getFloat(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getFloat(columnIndex);
  }

  @Override
  public int getInt(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getInt(columnIndex);
  }

  @Override
  public long getLong(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getLong(columnIndex);
  }

  @Override
  public short getShort(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getShort(columnIndex);
  }

  @Override
  public String getString(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getString(columnIndex);
  }

  @Override
  public boolean isClosed() {
    return mClosed || getMasterCursor().isClosed();
  }

  @Override
  public void close() {
    // Mark this Cursor as closed
    mClosed = true;

    // Only close the wrapped cursor if no other FilteredCursors are referencing the master cursor
    Cursor masterCursor = getMasterCursor();

    Set<FilteredCursor> linkedFilteredCursorSet = sMasterCursorMap.get(masterCursor);
    if (linkedFilteredCursorSet == null) {
      super.close(); // Shouldn't ever happen?
    } else {
      linkedFilteredCursorSet.remove(this);
      if (linkedFilteredCursorSet.isEmpty()) {
        super.close();
      }
    }

    if (masterCursor.isClosed()) {
      sMasterCursorMap.remove(masterCursor);
    }
  }

  @Override
  @Deprecated
  public boolean requery() {
    throw new UnsupportedOperationException();
  }

  private void attachToMasterCursor() {
    Cursor masterCursor = getMasterCursor();
    Set<FilteredCursor> filteredCursorSet = sMasterCursorMap.get(masterCursor);
    if (filteredCursorSet == null) {
      filteredCursorSet = Collections.synchronizedSet(new HashSet<FilteredCursor>());
      sMasterCursorMap.put(masterCursor, filteredCursorSet);
    }
    filteredCursorSet.add(this);
  }

  /**
   * Returns the first non-CursorWrapper instance contained within this object.
   */
  public Cursor getMasterCursor() {
    Cursor cursor = mCursor;

    while (cursor instanceof CursorWrapper) {
      cursor = ((CursorWrapper) cursor).getWrappedCursor();
    }

    return cursor;
  }

  /**
   * Returns the first FilteredCursor wrapped by the provided cursor or null if no FilteredCursor is found.
   */
  public static FilteredCursor unwrapFilteredCursor(Cursor cursor) {
    while (cursor instanceof CursorWrapper) {
      if (cursor instanceof FilteredCursor) {
        return (FilteredCursor) cursor;
      } else {
        cursor = ((CursorWrapper) cursor).getWrappedCursor();
      }
    }

    return null;
  }

}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FilteredCursorFactory.java
================================================
```
/*
 * Copyright (C) 2014 Clover Network, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.util;

import android.database.Cursor;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Common techniques for creating FilteredCursor objects.
 */
public class FilteredCursorFactory {

  private FilteredCursorFactory() {
  }

  /**
   * An interface to select rows to appear in a new FilteredCursor.
   */
  public interface Selector {
    /**
     * Return true to include the current position of the source Cursor into a FilteredCursor.
     */
    boolean select(Cursor cursor);
  }

  /**
   * Create a FilteredCursor that contains only rows selected by the given Selector. The order of the rows in the
   * FilteredCursor matches the order of the source Cursor.
   */
  public static FilteredCursor createUsingSelector(Cursor cursor, Selector selector) {
    if (cursor == null) {
      return null;
    }

    ArrayList<Integer> filterList = new ArrayList<Integer>();

    if (cursor.moveToFirst()) {
      do {
        if (selector.select(cursor)) {
          filterList.add(cursor.getPosition());
        }
      } while (cursor.moveToNext());
    }

    return FilteredCursor.createUsingFilter(cursor, toIntArray(filterList));
  }


  /**
   * Create a group of FilteredCursors. Each FilteredCursor will contain only rows with the same value for the given
   * column. The order of the rows in each FilteredCursor matches the order of the source Cursor. NULL is not treated
   * as unique so if there are any rows with the value NULL they will be grouped together.
   */
  public static Map<String, FilteredCursor> createGroups(Cursor cursor, String columnName) {
    if (cursor == null) {
      return null;
    }
    final int columnIndex = cursor.getColumnIndexOrThrow(columnName);
    return createGroups(cursor, columnIndex);
  }

  /**
   * Just like {@link FilteredCursorFactory#createGroups(Cursor, String)}, except takes a column index instead of column name.
   */
  public static Map<String, FilteredCursor> createGroups(Cursor cursor, int columnIndex) {
    if (cursor == null) {
      return null;
    }

    Map<String, List<Integer>> filters = new HashMap<String, List<Integer>>();

    if (cursor.moveToFirst()) {
      do {
        String key = cursor.getString(columnIndex);
        List<Integer> filterList = filters.get(key);
        if (filterList == null) {
          filterList = new ArrayList<Integer>();
          filters.put(key, filterList);
        }
        filterList.add(cursor.getPosition());
      } while (cursor.moveToNext());
    }

    Map<String, FilteredCursor> groups = new HashMap<String, FilteredCursor>();

    for (Map.Entry<String, List<Integer>> entry : filters.entrySet()) {
      groups.put(entry.getKey(), FilteredCursor.createUsingFilter(cursor, toIntArray(entry.getValue())));
    }

    return groups;
  }

  /**
   * When a source Cursor is joined with a list of values the JoinType specifies how rows are filtered. The JoinTypes
   * operates similarly to standard SQL joins.
   */
  public enum JoinType {
    /**
     * Specifies a left outer join, for rows where there is no match in the cursor {@link FilteredCursor#isEmpty()}
     * returns true.
     */
    LEFT_OUTER_JOIN,
    /**
     * Just like {@link JoinType#LEFT_OUTER_JOIN} except every row must match, if not {@link IllegalArgumentException}
     * is thrown.
     */
    STRICT_LEFT_OUTER_JOIN,
    /**
     * Specifies an inner join.
     */
    INNER_JOIN,
  }

  /**
   * Create a new FilteredCursor using a {@link JoinType#STRICT_LEFT_OUTER_JOIN}. The joinList acts as the left table
   * with a single column of values and source Cursor acts as the right table. The join is performed on the values of
   * the given columnName. Returns null if the provided cursor
   * is null.
   *
   * @see JoinType
   */
  public static FilteredCursor createUsingJoinList(Cursor cursor, String columnName, List<String> joinList) {
    return createUsingJoinList(cursor, columnName, joinList, JoinType.STRICT_LEFT_OUTER_JOIN);
  }

  /**
   * Create a new FilteredCursor using a {@link JoinType#STRICT_LEFT_OUTER_JOIN}. The joinList acts as the left table
   * with a single column of values and source Cursor acts as the right table. The join is performed on the values of
   * the given columnName. Returns null if the provided cursor
   * is null.
   *
   * @see JoinType
   */
  public static FilteredCursor createUsingJoinList(Cursor cursor, int columnIndex, List<String> joinList) {
    return createUsingJoinList(cursor, columnIndex, joinList, JoinType.STRICT_LEFT_OUTER_JOIN);
  }

  /**
   * Create a new FilteredCursor by joining the source Cursor with the given list using a {@link JoinType}. The
   * joinList acts as the left table with a single column of values and source Cursor acts as the right table. The join
   * is performed on the values of the given columnName. Returns null if the provided cursor is null.
   *
   * @see JoinType
   */
  public static FilteredCursor createUsingJoinList(Cursor cursor, String columnName, List<String> joinList, JoinType joinType) {
    if (cursor == null) {
      return null;
    }
    final int columnIndex = cursor.getColumnIndexOrThrow(columnName);
    return createUsingJoinList(cursor, columnIndex, joinList, joinType);
  }

  /**
   * Just like {@link FilteredCursorFactory#createUsingJoinList(Cursor, String, List<String>, JoinType)}, except it takes a
   * column index instead of column name.
   *
   * @see JoinType
   */
  public static FilteredCursor createUsingJoinList(Cursor cursor, int columnIndex, List<String> joinList, JoinType joinType) {
    if (cursor == null) {
      return null;
    }

    if (joinList == null || joinList.size() == 0) {
      return FilteredCursor.createUsingFilter(cursor, new int[0]);
    }

    int[] filterMap;

    final int filterListSize = joinList.size();
    filterMap = new int[filterListSize];
    // -1 is a magic value indicating this position has not been mapped, which is illegal
    Arrays.fill(filterMap, -1);

    Map<String, Deque<Integer>> filterValueMap = new HashMap<String, Deque<Integer>>(filterListSize);

    for (int i = 0; i < filterListSize; i++) {
      String value = joinList.get(i);

      Deque<Integer> filterIndexList = filterValueMap.get(value);
      if (filterIndexList == null) {
        filterIndexList = new ArrayDeque<Integer>();
        filterValueMap.put(value, filterIndexList);
      }
      filterIndexList.add(i);
    }

    if (cursor.moveToFirst()) {
      do {
        String value = cursor.getString(columnIndex);
        Deque<Integer> filterIndexList = filterValueMap.get(value);

        if (filterIndexList != null) {
          int cursorPosition = cursor.getPosition();

          for (Integer filterIndex : filterIndexList) {
            filterMap[filterIndex] = cursorPosition;
          }

          // If this cursor value comes up again point remaining filter indexes to it
          if (filterIndexList.size() > 1) {
            filterIndexList.removeFirst();
          } else {
            filterValueMap.remove(value);
          }
        }
      } while (cursor.moveToNext());
    }

    switch (joinType) {
      case STRICT_LEFT_OUTER_JOIN: {
        failOnEmptyPositions(cursor, filterMap, columnIndex, filterValueMap);
        break;
      }
      case INNER_JOIN: {
        filterMap = cullEmptyPositions(filterMap);
        break;
      }
      case LEFT_OUTER_JOIN: {
        // no need to do anything
        break;
      }
    }

    return FilteredCursor.createUsingFilter(cursor, filterMap);
  }

  private static void failOnEmptyPositions(Cursor cursor, int[] filterMap, int columnIndex, Map<String, Deque<Integer>> filterValueMap) {
    for (Map.Entry<String, Deque<Integer>> filterMapEntry : filterValueMap.entrySet()) {
      int filterIndex = filterMapEntry.getValue().getFirst();
      if (filterMap[filterIndex] == -1) {
        throw new IllegalArgumentException("Source cursor is missing entries for the column \""
                + cursor.getColumnName(columnIndex) + "\" with values " + filterMapEntry.getKey());
      }
    }
  }

  private static int[] cullEmptyPositions(int[] filterMap) {
    int culledSize = 0;
    for (int value : filterMap) {
      if (value != -1) {
        culledSize++;
      }
    }
    int[] culledFilterMap = new int[culledSize];
    int pos = 0;
    for (int value : filterMap) {
      if (value != -1) {
        culledFilterMap[pos++] = value;
      }
    }
    return culledFilterMap;
  }

  private static int[] toIntArray(List<Integer> list) {
    int[] ret = new int[list.size()];
    int i = 0;
    for (Integer e : list)
      ret[i++] = e;
    return ret;
  }

}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/MimeUtils.java
================================================
```
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.gm.cleaner.plugin.xposed.util;

import android.content.ClipDescription;
import android.mtp.MtpConstants;
import android.provider.MediaStore.Files.FileColumns;
import android.webkit.MimeTypeMap;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.File;
import java.util.Locale;
import java.util.Objects;

public class MimeUtils {
    /**
     * Variant of {@link Objects#equals(Object, Object)} but which tests with
     * case-insensitivity.
     */
    public static boolean equalIgnoreCase(@Nullable String a, @Nullable String b) {
        return (a != null) && a.equalsIgnoreCase(b);
    }

    /**
     * Variant of {@link String#startsWith(String)} but which tests with
     * case-insensitivity.
     */
    public static boolean startsWithIgnoreCase(@Nullable String target, @Nullable String other) {
        if (target == null || other == null) return false;
        if (other.length() > target.length()) return false;
        return target.regionMatches(true, 0, other, 0, other.length());
    }

    /**
     * Resolve the MIME type of the given file, returning
     * {@code application/octet-stream} if the type cannot be determined.
     */
    public static @NonNull String resolveMimeType(@NonNull File file) {
        final String extension = extractFileExtension(file.getPath());
        if (extension == null) return ClipDescription.MIMETYPE_UNKNOWN;

        final String mimeType = MimeTypeMap.getSingleton()
                .getMimeTypeFromExtension(extension.toLowerCase(Locale.ROOT));
        if (mimeType == null) return ClipDescription.MIMETYPE_UNKNOWN;

        return mimeType;
    }

    public static @Nullable String extractFileExtension(@Nullable String data) {
        if (data == null) return null;

        final int lastDot = data.lastIndexOf('.');
        if (lastDot == -1) {
            return null;
        } else {
            return data.substring(lastDot + 1);
        }
    }

    /**
     * Resolve the {@link FileColumns#MEDIA_TYPE} of the given MIME type. This
     * carefully checks for more specific types before generic ones, such as
     * treating {@code audio/mpegurl} as a playlist instead of an audio file.
     */
    public static int resolveMediaType(@NonNull String mimeType) {
        if (isPlaylistMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_PLAYLIST;
        } else if (isSubtitleMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_SUBTITLE;
        } else if (isAudioMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_AUDIO;
        } else if (isVideoMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_VIDEO;
        } else if (isImageMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_IMAGE;
        } else if (isDocumentMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_DOCUMENT;
        } else {
            return FileColumns.MEDIA_TYPE_NONE;
        }
    }

    /**
     * Resolve the {@link FileColumns#FORMAT} of the given MIME type. Note that
     * since this column isn't public API, we're okay only getting very rough
     * values in place, and it's not worthwhile to build out complex matching.
     */
    public static int resolveFormatCode(@Nullable String mimeType) {
        final int mediaType = resolveMediaType(mimeType);
        switch (mediaType) {
            case FileColumns.MEDIA_TYPE_AUDIO:
                return MtpConstants.FORMAT_UNDEFINED_AUDIO;
            case FileColumns.MEDIA_TYPE_VIDEO:
                return MtpConstants.FORMAT_UNDEFINED_VIDEO;
            case FileColumns.MEDIA_TYPE_IMAGE:
                return MtpConstants.FORMAT_DEFINED;
            default:
                return MtpConstants.FORMAT_UNDEFINED;
        }
    }

    public static @NonNull String extractPrimaryType(@NonNull String mimeType) {
        final int slash = mimeType.indexOf('/');
        if (slash == -1) {
            throw new IllegalArgumentException();
        }
        return mimeType.substring(0, slash);
    }

    public static boolean isAudioMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "audio/");
    }

    public static boolean isVideoMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "video/");
    }

    public static boolean isImageMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "image/");
    }

    public static boolean isPlaylistMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/vnd.apple.mpegurl":
            case "application/vnd.ms-wpl":
            case "application/x-extension-smpl":
            case "application/x-mpegurl":
            case "application/xspf+xml":
            case "audio/mpegurl":
            case "audio/x-mpegurl":
            case "audio/x-scpls":
                return true;
            default:
                return false;
        }
    }

    public static boolean isSubtitleMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/lrc":
            case "application/smil+xml":
            case "application/ttml+xml":
            case "application/x-extension-cap":
            case "application/x-extension-srt":
            case "application/x-extension-sub":
            case "application/x-extension-vtt":
            case "application/x-subrip":
            case "text/vtt":
                return true;
            default:
                return false;
        }
    }

    public static boolean isDocumentMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;

        if (startsWithIgnoreCase(mimeType, "text/")) return true;

        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/epub+zip":
            case "application/msword":
            case "application/pdf":
            case "application/rtf":
            case "application/vnd.ms-excel":
            case "application/vnd.ms-excel.addin.macroenabled.12":
            case "application/vnd.ms-excel.sheet.binary.macroenabled.12":
            case "application/vnd.ms-excel.sheet.macroenabled.12":
            case "application/vnd.ms-excel.template.macroenabled.12":
            case "application/vnd.ms-powerpoint":
            case "application/vnd.ms-powerpoint.addin.macroenabled.12":
            case "application/vnd.ms-powerpoint.presentation.macroenabled.12":
            case "application/vnd.ms-powerpoint.slideshow.macroenabled.12":
            case "application/vnd.ms-powerpoint.template.macroenabled.12":
            case "application/vnd.ms-word.document.macroenabled.12":
            case "application/vnd.ms-word.template.macroenabled.12":
            case "application/vnd.oasis.opendocument.chart":
            case "application/vnd.oasis.opendocument.database":
            case "application/vnd.oasis.opendocument.formula":
            case "application/vnd.oasis.opendocument.graphics":
            case "application/vnd.oasis.opendocument.graphics-template":
            case "application/vnd.oasis.opendocument.presentation":
            case "application/vnd.oasis.opendocument.presentation-template":
            case "application/vnd.oasis.opendocument.spreadsheet":
            case "application/vnd.oasis.opendocument.spreadsheet-template":
            case "application/vnd.oasis.opendocument.text":
            case "application/vnd.oasis.opendocument.text-master":
            case "application/vnd.oasis.opendocument.text-template":
            case "application/vnd.oasis.opendocument.text-web":
            case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            case "application/vnd.openxmlformats-officedocument.presentationml.template":
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            case "application/vnd.stardivision.calc":
            case "application/vnd.stardivision.chart":
            case "application/vnd.stardivision.draw":
            case "application/vnd.stardivision.impress":
            case "application/vnd.stardivision.impress-packed":
            case "application/vnd.stardivision.mail":
            case "application/vnd.stardivision.math":
            case "application/vnd.stardivision.writer":
            case "application/vnd.stardivision.writer-global":
            case "application/vnd.sun.xml.calc":
            case "application/vnd.sun.xml.calc.template":
            case "application/vnd.sun.xml.draw":
            case "application/vnd.sun.xml.draw.template":
            case "application/vnd.sun.xml.impress":
            case "application/vnd.sun.xml.impress.template":
            case "application/vnd.sun.xml.math":
            case "application/vnd.sun.xml.writer":
            case "application/vnd.sun.xml.writer.global":
            case "application/vnd.sun.xml.writer.template":
            case "application/x-mspublisher":
                return true;
            default:
                return false;
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/ItemsHeightsObserver.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll

import android.graphics.Canvas
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.ktx.getObjectField

open class ItemsHeightsObserver(list: RecyclerView, measureAllItemsOnStart: Boolean = true) :
    RecyclerView.AdapterDataObserver() {
    val itemsHeights: PrefixSumArrayList = PrefixSumArrayList()
    private val heightUndeterminedPositions: MutableList<Int> = mutableListOf()

    protected val adapter: RecyclerView.Adapter<RecyclerView.ViewHolder> = list.adapter!!
    protected val layoutManager: RecyclerView.LayoutManager = list.layoutManager!!

    /**
     * You should override it if you are not using [LinearLayoutManager].
     * @return Returns the adapter position of all visible view.
     */
    open val visibleItemPositions: Iterable<Int>
        get() {
            val layoutManager = layoutManager as LinearLayoutManager
            return layoutManager.findFirstVisibleItemPosition()..
                    layoutManager.findLastVisibleItemPosition()
        }

    private val recycler: RecyclerView.Recycler
            by lazy { list.getObjectField<RecyclerView.Recycler>() }

    private fun enforceItemOffset(position: Int): Int {
        var itemView = layoutManager.findViewByPosition(position)
        var newHolderCreated = false
        if (itemView == null) {
            itemView = recycler.getViewForPosition(position)
            newHolderCreated = true
            layoutManager.measureChildWithMargins(itemView, 0, 0)
        }
        try {
            return itemView.measuredHeight
        } finally {
            if (newHolderCreated) {
                recycler.recycleView(itemView)
            }
        }
    }

    /**
     * You should override it if you are not using [LinearLayoutManager].
     * @return Returns one item's height obtained in the easiest way.
     */
    open fun getOneItemOffset(): Int = itemsHeights.firstOrNull { it > 0 }
        ?: getVisibleItemOffset((layoutManager as LinearLayoutManager).findFirstVisibleItemPosition())

    /**
     * You can override it to get a better user experience if you know how to estimate the height
     * of the view at the specific position.
     * @param position The adapter position of the view we need to estimate its height.
     * @return Returns the height of the view at the specific position. Return `null` if you don't
     * know how to estimate the height of the view at the specific position.
     */
    open fun guessItemOffsetAt(position: Int): Int? = null

    protected fun getVisibleItemOffset(position: Int): Int {
        val itemView = layoutManager.findViewByPosition(position) ?: return -1
        return itemView.measuredHeight
    }

    private fun enforceAllItemsOffset(measureAllItems: Boolean) {
        val oneItemOffset = if (measureAllItems) {
            0
        } else {
            getOneItemOffset()
        }
        itemsHeights.clear()
        heightUndeterminedPositions.clear()
        val visibleItemPositions = visibleItemPositions
        for (i in 0 until adapter.itemCount) {
            itemsHeights += if (measureAllItems) {
                enforceItemOffset(i)
            } else {
                if (i in visibleItemPositions) {
                    getVisibleItemOffset(i)
                } else {
                    heightUndeterminedPositions += i
                    guessItemOffsetAt(i) ?: oneItemOffset
                }
            }
        }
    }

    override fun onChanged() {
        enforceAllItemsOffset(false)
    }

    override fun onItemRangeChanged(positionStart: Int, itemCount: Int) {
        for (i in positionStart until positionStart + itemCount) {
            heightUndeterminedPositions += i
        }
    }

    override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {
        for (i in 0 until heightUndeterminedPositions.size) {
            if (heightUndeterminedPositions[i] >= positionStart) {
                heightUndeterminedPositions[i] += itemCount
            }
        }
        val oneItemOffset = itemsHeights.firstOrNull { it > 0 } ?: 0
        for (i in positionStart until positionStart + itemCount) {
            // getVisibleItemOffset(i) can't get accurate result here, so we can only guess.
            val guessItemOffset = guessItemOffsetAt(i) ?: oneItemOffset
            itemsHeights.add(i, guessItemOffset)
            heightUndeterminedPositions += i
        }
    }

    override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {
        repeat(itemCount) {
            itemsHeights.removeAt(positionStart)
        }
        for (i in positionStart until positionStart + itemCount) {
            heightUndeterminedPositions -= i
        }
        for (i in 0 until heightUndeterminedPositions.size) {
            if (heightUndeterminedPositions[i] > positionStart) {
                heightUndeterminedPositions[i] -= itemCount
            }
        }
    }

    override fun onItemRangeMoved(fromPosition: Int, toPosition: Int, itemCount: Int) {
        // itemCount is always 1
        itemsHeights.add(toPosition, itemsHeights.removeAt(fromPosition))
        if (fromPosition > toPosition) {
            for (i in 0 until heightUndeterminedPositions.size) {
                when (heightUndeterminedPositions[i]) {
                    fromPosition -> heightUndeterminedPositions[i] = toPosition
                    in toPosition until fromPosition -> heightUndeterminedPositions[i]++
                }
            }
        } else if (fromPosition < toPosition) {
            for (i in 0 until heightUndeterminedPositions.size) {
                when (heightUndeterminedPositions[i]) {
                    fromPosition -> heightUndeterminedPositions[i] = toPosition
                    in fromPosition..toPosition -> heightUndeterminedPositions[i]--
                }
            }
        }
    }

    private fun updateAllVisibleItemsOffset() {
        if (heightUndeterminedPositions.isEmpty()) {
            return
        }
        for (position in visibleItemPositions) {
            if (heightUndeterminedPositions.remove(position)) {
                val offset = getVisibleItemOffset(position)
                itemsHeights[position] = offset
            }
        }
    }

    private fun itemHeightsInitialized(): Boolean = itemsHeights.any { it > 0 }

    init {
        list.addItemDecoration(object : RecyclerView.ItemDecoration() {
            override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
                // added by onItemRangeInserted()
                if (!itemHeightsInitialized()) {
                    enforceAllItemsOffset(measureAllItemsOnStart)
                } else {
                    updateAllVisibleItemsOffset()
                }
            }
        })
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/Md3PopupBackground.java
================================================
```
/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Matrix;
import android.graphics.Outline;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.view.View;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.graphics.drawable.DrawableCompat;

class Md3PopupBackground extends Drawable {

    @NonNull
    private final Paint mPaint;
    private final int mPaddingStart;
    private final int mPaddingEnd;

    @NonNull
    private final Path mPath = new Path();

    @NonNull
    private final Matrix mTempMatrix = new Matrix();

    public Md3PopupBackground(@NonNull Context context) {
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setColor(Utils.getColorFromAttrRes(R.attr.colorPrimary, context));
        mPaint.setStyle(Paint.Style.FILL);
        Resources resources = context.getResources();
        mPaddingStart = resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_padding_start);
        mPaddingEnd = resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_padding_end);
    }

    @Override
    public void draw(@NonNull Canvas canvas) {
        canvas.drawPath(mPath, mPaint);
    }

    @Override
    public boolean onLayoutDirectionChanged(int layoutDirection) {
        updatePath();
        return true;
    }

    @Override
    public void setAlpha(int alpha) {
    }

    @Override
    public void setColorFilter(@Nullable ColorFilter colorFilter) {
    }

    @Override
    public boolean isAutoMirrored() {
        return true;
    }

    private boolean needMirroring() {
        return DrawableCompat.getLayoutDirection(this) == View.LAYOUT_DIRECTION_RTL;
    }

    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }

    @Override
    protected void onBoundsChange(@NonNull Rect bounds) {
        updatePath();
    }

    private void updatePath() {

        mPath.reset();

        Rect bounds = getBounds();
        float width = bounds.width();
        float height = bounds.height();
        float r = height / 2;
        float sqrt2 = (float) Math.sqrt(2);
        // Ensure we are convex.
        width = Math.max(r + sqrt2 * r, width);
        pathArcTo(mPath, r, r, r, 90, 180);
        float o1X = width - sqrt2 * r;
        pathArcTo(mPath, o1X, r, r, -90, 45f);
        float r2 = r / 5;
        float o2X = width - sqrt2 * r2;
        pathArcTo(mPath, o2X, r, r2, -45, 90);
        pathArcTo(mPath, o1X, r, r, 45f, 45f);
        mPath.close();

        if (needMirroring()) {
            mTempMatrix.setScale(-1, 1, width / 2, 0);
        } else {
            mTempMatrix.reset();
        }
        mTempMatrix.postTranslate(bounds.left, bounds.top);
        mPath.transform(mTempMatrix);
    }

    private static void pathArcTo(@NonNull Path path, float centerX, float centerY, float radius,
                                  float startAngle, float sweepAngle) {
        path.arcTo(centerX - radius, centerY - radius, centerX + radius, centerY + radius,
                startAngle, sweepAngle, false);
    }

    @Override
    public boolean getPadding(@NonNull Rect padding) {
        if (needMirroring()) {
            padding.set(mPaddingEnd, 0, mPaddingStart, 0);
        } else {
            padding.set(mPaddingStart, 0, mPaddingEnd, 0);
        }
        return true;
    }

    @Override
    public void getOutline(@NonNull Outline outline) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q && !mPath.isConvex()) {
            // The outline path must be convex before Q, but we may run into floating point error
            // caused by calculation involving sqrt(2) or OEM implementation difference, so in this
            // case we just omit the shadow instead of crashing.
            super.getOutline(outline);
            return;
        }
        outline.setConvexPath(mPath);
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/NoInterceptionRecyclerViewHelper.java
================================================
```
/*
 * Copyright 2021 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll;

import android.view.MotionEvent;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.recyclerview.widget.RecyclerView;

public class NoInterceptionRecyclerViewHelper extends RecyclerViewHelper {

    @NonNull
    private final RecyclerView mView;
    private boolean mDragging;

    public NoInterceptionRecyclerViewHelper(@NonNull RecyclerView view,
                                            @Nullable PopupTextProvider popupTextProvider) {
        super(view, popupTextProvider);
        mView = view;
    }

    @Override
    public void addOnTouchEventListener(@NonNull Predicate<MotionEvent> onTouchEvent) {
        mView.addOnItemTouchListener(new RecyclerView.SimpleOnItemTouchListener() {
            @Override
            public boolean onInterceptTouchEvent(@NonNull RecyclerView recyclerView,
                                                 @NonNull MotionEvent event) {
                var action = event.getAction();
                // Intercept up event to disable fling.
                var shouldInterceptTouchEvent = (action == MotionEvent.ACTION_UP ||
                        action == MotionEvent.ACTION_CANCEL) && mDragging;
                mDragging = onTouchEvent.test(event);
                return shouldInterceptTouchEvent;
            }

            @Override
            public void onTouchEvent(@NonNull RecyclerView recyclerView,
                                     @NonNull MotionEvent event) {
                onTouchEvent.test(event);
            }
        });
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PopupStyle.java
================================================
```
/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll;

import android.content.Context;
import android.content.res.Resources;
import android.text.TextUtils;
import android.util.TypedValue;
import android.view.Gravity;
import android.widget.FrameLayout;
import android.widget.TextView;

import androidx.core.util.Consumer;

public class PopupStyle {

    private PopupStyle() {
    }

    public static Consumer<TextView> MD3 = popupView -> {
        Resources resources = popupView.getResources();
        popupView.setMinimumWidth(resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_min_width));
        popupView.setMinimumHeight(resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_min_height));
        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)
                popupView.getLayoutParams();
        layoutParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP;
        layoutParams.setMarginEnd(resources.getDimensionPixelOffset(
                R.dimen.afs_md2_popup_margin_end));
        popupView.setLayoutParams(layoutParams);
        Context context = popupView.getContext();
        popupView.setBackground(new Md3PopupBackground(context));
        popupView.setElevation(resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_elevation));
        popupView.setEllipsize(TextUtils.TruncateAt.MIDDLE);
        popupView.setGravity(Gravity.CENTER);
        popupView.setIncludeFontPadding(false);
        popupView.setSingleLine(true);
        popupView.setTextColor(Utils.getColorFromAttrRes(android.R.attr.textColorPrimaryInverse,
                context));
        popupView.setTextSize(TypedValue.COMPLEX_UNIT_PX, resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_text_size));
    };
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PreciseRecyclerViewHelper.kt
================================================
```
/*
 * Copyright 2022 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll

import android.graphics.Rect
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView

open class PreciseRecyclerViewHelper(
    private val list: RecyclerView,
    popupTextProvider: PopupTextProvider? = null,
    measureAllItemsOnStart: Boolean = true,
    val observer: ItemsHeightsObserver = ItemsHeightsObserver(list, measureAllItemsOnStart)
) : NoInterceptionRecyclerViewHelper(list, popupTextProvider) {
    private val layoutManager: LinearLayoutManager = list.layoutManager as LinearLayoutManager
    private val mTempRect: Rect = Rect()
    private val isGridLayoutManager: Boolean =
        layoutManager is GridLayoutManager && layoutManager.spanCount > 1

    init {
        list.adapter!!.registerAdapterDataObserver(observer)
    }

    private fun calcPrefixSumForGridLayoutManager(
        requestSize: Int, prefixSum: MutableList<Int> = mutableListOf()
    ): MutableList<Int> {
        val spanSizeLookup = (layoutManager as GridLayoutManager).spanSizeLookup
        val spanCount = layoutManager.spanCount
        val chunkHeights = mutableListOf<Int>()
        while (prefixSum.size < requestSize) {
            chunkHeights.clear()
            var remainingSpan = spanCount
            while (true) {
                val position = prefixSum.size + chunkHeights.size
                if (position >= observer.itemsHeights.size) {
                    break
                }
                val spanSize = spanSizeLookup.getSpanSize(position)
                remainingSpan -= spanSize
                if (remainingSpan < 0) {
                    break // item did not fit into this row or column
                }
                val itemHeight = observer.itemsHeights[position]
                chunkHeights.add(itemHeight)
            }
            val newSum = (prefixSum.lastOrNull() ?: 0) + chunkHeights.max()
            repeat(chunkHeights.size) { // possibly more than requestSize
                prefixSum.add(newSum)
            }
        }
        return prefixSum
    }

    override fun getScrollRange(): Int = list.paddingTop + list.paddingBottom +
            if (!isGridLayoutManager) {
                observer.itemsHeights.sum()
            } else {
                calcPrefixSumForGridLayoutManager(observer.itemsHeights.size).lastOrNull() ?: 0
            }

    override fun getScrollOffset(): Int {
        val firstItemPosition = layoutManager.getPosition(list.getChildAt(0))
        if (firstItemPosition == RecyclerView.NO_POSITION ||
            firstItemPosition >= observer.itemsHeights.size
        ) {
            return 0
        }
        val itemsHeightsSum = if (!isGridLayoutManager) {
            observer.itemsHeights.query(0, firstItemPosition)
        } else {
            calcPrefixSumForGridLayoutManager(firstItemPosition).lastOrNull() ?: 0
        }
        return list.paddingTop - getFirstItemOffset() + itemsHeightsSum
    }

    private fun getFirstItemOffset(): Int {
        if (list.childCount == 0) {
            return 0
        }
        val itemView = list.getChildAt(0)
        list.getDecoratedBoundsWithMargins(itemView, mTempRect)
        return mTempRect.top
    }

    override fun scrollTo(offset: Int) {
        // Stop any scroll in progress for RecyclerView.
        list.stopScroll()
        val offset = offset - list.paddingTop
        var sum = 0
        var firstItemPosition = 0
        if (!isGridLayoutManager) {
            for (i in 0 until observer.itemsHeights.size) {
                val next = sum + observer.itemsHeights[i]
                if (next > offset) break
                sum = next
                firstItemPosition++
            }
        } else {
            val prefixSum = mutableListOf<Int>()
            for (i in 0 until observer.itemsHeights.size) {
                val next = calcPrefixSumForGridLayoutManager(firstItemPosition + 1, prefixSum)
                    .lastOrNull() ?: 0
                if (next > offset) break
                sum = next
                firstItemPosition++
            }
        }
        val firstItemTop = sum - offset
        scrollToPositionWithOffset(firstItemPosition, firstItemTop)
    }

    private fun scrollToPositionWithOffset(position: Int, offset: Int) {
        // LinearLayoutManager actually takes offset from paddingTop instead of top of RecyclerView.
        val offset = offset - list.paddingTop
        layoutManager.scrollToPositionWithOffset(position, offset)
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PrefixSumArrayList.java
================================================
```
/*
 * Copyright 2023 Green Mushroom
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package me.zhanghai.android.fastscroll;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;

/**
 * Lazy prefix sum {@link #ArrayList} implementation.
 *
 * @author Green Mushroom
 */
public class PrefixSumArrayList extends ArrayList<Integer> {
    private final ArrayList<Integer> prefixSum = new ArrayList<>();

    private Integer getPrefixSumBefore(final int index) {
        if (index == 0) {
            return 0;
        }
        return prefixSum.get(index - 1);
    }

    private void ensurePrefixSum(final int left, final int right) {
        if (getPrefixSumBefore(left) == null) {
            ensurePrefixSum(0, left);
        }
        if (getPrefixSumBefore(right) == null) {
            for (int i = left; i < right; i++) {
                prefixSum.set(i, getPrefixSumBefore(i) + super.get(i));
            }
        }
    }

    /**
     * Query range sum.
     *
     * @param left  The left endpoint of the range.
     * @param right The right endpoint of the range.
     * @return the sum of elements in the range
     */
    public int query(final int left, final int right) {
        ensurePrefixSum(left, right);
        return getPrefixSumBefore(right) - getPrefixSumBefore(left);
    }

    /**
     * @return the sum of all elements in this list
     */
    public int sum() {
        return query(0, super.size());
    }

    private void invalidatePrefixSum(final int index) {
        final int newSize = super.size();
        final Integer[] elementData = new Integer[newSize];
        Arrays.fill(elementData, null);
        for (int i = 0; i < index; i++) {
            if (i >= prefixSum.size()) {
                break;
            }
            final Integer val = prefixSum.get(i);
            if (val == null) {
                break;
            }
            elementData[i] = val;
        }

        prefixSum.clear();
        Collections.addAll(prefixSum, elementData);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void trimToSize() {
        super.trimToSize();
        prefixSum.trimToSize();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void ensureCapacity(final int minCapacity) {
        super.ensureCapacity(minCapacity);
        prefixSum.ensureCapacity(minCapacity);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Integer set(final int index, final Integer element) {
        try {
            return super.set(index, element);
        } finally {
            invalidatePrefixSum(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(final Integer integer) {
        final int index = super.size();
        try {
            return super.add(integer);
        } finally {
            invalidatePrefixSum(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void add(final int index, final Integer element) {
        super.add(index, element);
        invalidatePrefixSum(index);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Integer remove(final int index) {
        try {
            return super.remove(index);
        } finally {
            invalidatePrefixSum(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(@Nullable final Object o) {
        final int index = super.indexOf(o);
        try {
            return index != -1;
        } finally {
            remove(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clear() {
        super.clear();
        prefixSum.clear();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean addAll(@NonNull final Collection<? extends Integer> c) {
        final int index = super.size();
        try {
            return super.addAll(c);
        } finally {
            invalidatePrefixSum(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean addAll(final int index, @NonNull final Collection<? extends Integer> c) {
        try {
            return super.addAll(index, c);
        } finally {
            invalidatePrefixSum(index);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void removeRange(final int fromIndex, final int toIndex) {
        super.removeRange(fromIndex, toIndex);
        invalidatePrefixSum(fromIndex);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean removeAll(@NonNull final Collection<?> c) {
        try {
            return super.removeAll(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean retainAll(@NonNull final Collection<?> c) {
        try {
            return super.retainAll(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean removeIf(@NonNull final Predicate<? super Integer> filter) {
        try {
            return super.removeIf(filter);
        } finally {
            invalidatePrefixSum(0);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void replaceAll(@NonNull final UnaryOperator<Integer> operator) {
        try {
            super.replaceAll(operator);
        } finally {
            invalidatePrefixSum(0);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void sort(@Nullable final Comparator<? super Integer> c) {
        try {
            super.sort(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }
}

```

================================================
FILE: ./build.gradle
================================================
```
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    ext {
        hiltVersion = '2.51'
        kotlinVersion = '1.9.23'
        navigationVersion = '2.7.7'
    }
    repositories {
        google()
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$navigationVersion"
        classpath 'com.android.tools.build:gradle:8.4.0'
        classpath "com.google.dagger:hilt-android-gradle-plugin:$hiltVersion"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
    }
}

plugins {
    // https://github.com/google/ksp/releases
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url 'https://api.xposed.info/' }
        maven { url 'https://jitpack.io' }
        jcenter() 
    }
}

task clean(type: Delete) {
    delete rootProject.layout.buildDirectory
}
```

================================================
FILE: ./gradle.properties
================================================
```
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=false
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
android.experimental.enableNewResourceShrinker=true
android.experimental.enableNewResourceShrinker.preciseShrinking=true
android.defaults.buildfeatures.buildconfig=true
android.nonFinalResIds=false
#android.enableR8.fullMode=true
#org.gradle.unsafe.configuration-cache=true

```

================================================
FILE: ./settings.gradle
================================================
```
include ':app'
rootProject.name = "Media Provider Manager"

include ':photoview'
project(':photoview').projectDir = new File('PhotoView/photoview')

```

