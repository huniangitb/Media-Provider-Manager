--- PROJECT STRUCTURE ---
.
./LICENSE
./README.md
./README_zh-CN.md
./app
./app/build.gradle
./app/proguard-rules.pro
./app/src
./app/src/main
./app/src/main/AndroidManifest.xml
./app/src/main/aidl
./app/src/main/assets
./app/src/main/java
./app/src/main/res
./screenshots
./screenshots/about.jpg
./screenshots/record.jpg
./screenshots/template.jpg
./settings.gradle
./h.sh
./android_app_logic.txt
./android_logic_no_comments.txt

--- CLEAN CODE CONTENTS ---

================================================
FILE: ./app/build.gradle
================================================
```
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'androidx.navigation.safeargs.kotlin'
apply plugin: 'com.google.devtools.ksp'
apply plugin: 'dagger.hilt.android.plugin'
def gitCommitCount = Integer.parseInt('git rev-list --count HEAD'.execute([], project.rootDir).text.trim())
def sdk = 34
android {
    compileSdk sdk
    buildToolsVersion = '34.0.0'
    defaultConfig {
        applicationId 'me.gm.cleaner.plugin'
        minSdk 29
        targetSdk sdk
        versionCode gitCommitCount
        versionName 'beta13'
        testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
        multiDexEnabled false
        resourceConfigurations += ['en', 'zh-rCN', 'zh-rTW']
    }
    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            outputFileName = "Media Provider Manager_${defaultConfig.versionName}-${variant.buildType.name}.apk"
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    buildFeatures {
        aidl true
        viewBinding true
        buildConfig = true
    }
    lint {
        abortOnError = false
        checkReleaseBuilds = false
    }
    namespace 'me.gm.cleaner.plugin'
    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17
    }
}
dependencies {
    compileOnly 'de.robv.android.xposed:api:82'
    implementation 'androidx.core:core-ktx:1.13.1'
    implementation 'androidx.fragment:fragment-ktx:1.7.0'
    def lifecycleVersion = '2.7.0'
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycleVersion"
    def media3Version = '1.3.1'
    implementation "androidx.media3:media3-exoplayer:$media3Version"
    implementation "androidx.media3:media3-ui:$media3Version"
    implementation "androidx.navigation:navigation-fragment-ktx:$rootProject.navigationVersion"
    implementation "androidx.navigation:navigation-ui-ktx:$rootProject.navigationVersion"
    implementation 'androidx.preference:preference-ktx:1.2.1'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.recyclerview:recyclerview-selection:1.1.0'
    def roomVersion = '2.6.1'
    annotationProcessor "androidx.room:room-compiler:$roomVersion"
    ksp "androidx.room:room-compiler:$roomVersion"
    implementation "androidx.room:room-ktx:$roomVersion"
    implementation "androidx.room:room-runtime:$roomVersion"
    implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
    implementation 'com.caverock:androidsvg:1.4'
    def glideVersion = '4.16.0'
    implementation "com.github.bumptech.glide:glide:$glideVersion"
    ksp "com.github.bumptech.glide:ksp:$glideVersion"
    implementation 'com.google.android.material:material:1.12.0'
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation "com.google.dagger:hilt-android:$rootProject.hiltVersion"
    ksp "com.google.dagger:hilt-android-compiler:$rootProject.hiltVersion"
    def retrofitVersion = '2.9.0'
    implementation "com.squareup.retrofit2:converter-gson:$retrofitVersion"
    implementation "com.squareup.retrofit2:converter-scalars:$retrofitVersion"
    implementation "com.squareup.retrofit2:retrofit:$retrofitVersion"
    implementation 'dev.rikka.rikkax.recyclerview:recyclerview-ktx:1.3.2'
    def markwonVersion = '4.6.2'
    implementation "io.noties.markwon:core:$markwonVersion"
    implementation "io.noties.markwon:ext-strikethrough:$markwonVersion"
    implementation "io.noties.markwon:html:$markwonVersion"
    implementation "io.noties.markwon:image:$markwonVersion"
    def appIconLoaderVersion = '1.5.0'
    implementation "me.zhanghai.android.appiconloader:appiconloader:$appIconLoaderVersion"
    implementation "me.zhanghai.android.appiconloader:appiconloader-glide:$appIconLoaderVersion"
    implementation 'me.zhanghai.android.fastscroll:library:1.3.0'
    def kotlinxCoroutinesVersion = '1.8.0'
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlinxCoroutinesVersion"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlinxCoroutinesVersion"
    implementation 'org.lsposed.hiddenapibypass:hiddenapibypass:4.3'
    implementation project(':photoview')
    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.2.25'
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.13'
}

```

================================================
FILE: ./app/src/main/AndroidManifest.xml
================================================
```
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="32" />
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.INTERNET" />
    <application
        android:name=".app.App"
        android:label="@string/app_name"
        android:largeHeap="true"
        android:multiArch="true"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity
            android:name=".app.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="audio/*" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
            </intent-filter>
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="video/*" />
            </intent-filter>
            <meta-data
                android:name="android.app.shortcuts"
                android:resource="@xml/shortcuts" />
        </activity>
        <activity-alias
            android:name=".MainActivityAlias"
            android:exported="true"
            android:targetActivity=".app.MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="de.robv.android.xposed.category.MODULE_SETTINGS" />
            </intent-filter>
        </activity-alias>
        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="@string/description" />
        <meta-data
            android:name="xposedminversion"
            android:value="53" />
        <meta-data
            android:name="xposedscope"
            android:resource="@array/recommend_package" />
    </application>
</manifest>

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/IManagerService.aidl
================================================
```
package me.gm.cleaner.plugin;
import me.gm.cleaner.plugin.model.ParceledListSlice;
import me.gm.cleaner.plugin.IMediaChangeObserver;
interface IManagerService {
    int getModuleVersion() = 0;
    ParceledListSlice<PackageInfo> getInstalledPackages(int userId, int flags) = 10;
    PackageInfo getPackageInfo(String packageName, int flags, int userId) = 11;
    String readSp(int who) = 20;
    void writeSp(int who, String what) = 21;
    void clearAllTables() = 30;
    int packageUsageTimes(int operation, in List<String> packageNames) = 31;
    void registerMediaChangeObserver(in IMediaChangeObserver observer) = 32;
    void unregisterMediaChangeObserver(in IMediaChangeObserver observer) = 33;
}

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/IMediaChangeObserver.aidl
================================================
```
package me.gm.cleaner.plugin;
oneway interface IMediaChangeObserver {
    void onChange();
}

```

================================================
FILE: ./app/src/main/aidl/me/gm/cleaner/plugin/model/ParceledListSlice.aidl
================================================
```
package me.gm.cleaner.plugin.model;
parcelable ParceledListSlice<T>;

```

================================================
FILE: ./app/src/main/java/androidx/media3/ui/PlayerControlViewLayoutManagerAccessor.kt
================================================
```
package androidx.media3.ui
import me.gm.cleaner.plugin.ktx.getObjectField
class PlayerControlViewLayoutManagerAccessor(controller: PlayerControlView) {
    private val controlViewLayoutManager =
        controller.getObjectField<PlayerControlViewLayoutManager>()
    fun show() {
        controlViewLayoutManager.show()
    }
    fun showImmediately() {
        controlViewLayoutManager.isAnimationEnabled = false
        controlViewLayoutManager.show()
        controlViewLayoutManager.isAnimationEnabled = true
    }
    fun hide() {
        controlViewLayoutManager.hide()
    }
    fun hideImmediately() {
        controlViewLayoutManager.hideImmediately()
    }
    fun removeHideCallbacks() {
        controlViewLayoutManager.removeHideCallbacks()
    }
    fun resetHideCallbacks() {
        controlViewLayoutManager.resetHideCallbacks()
    }
}

```

================================================
FILE: ./app/src/main/java/androidx/swiperefreshlayout/widget/ThemedSwipeRefreshLayout.kt
================================================
```
package androidx.swiperefreshlayout.widget
import android.annotation.SuppressLint
import android.content.Context
import android.graphics.drawable.ShapeDrawable
import android.util.AttributeSet
import androidx.core.content.ContextCompat
import androidx.core.graphics.ColorUtils
import com.google.android.material.R
import me.gm.cleaner.plugin.ktx.colorOnSurfaceVariant
import me.gm.cleaner.plugin.ktx.colorSurface
@SuppressLint("PrivateResource")
open class ThemedSwipeRefreshLayout @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null
) : SwipeRefreshLayout(context, attrs) {
    init {
        val overlayColor = ContextCompat
            .getColorStateList(context, R.color.m3_popupmenu_overlay_color)!!
            .defaultColor
        val backgroundColor = ColorUtils.compositeColors(overlayColor, context.colorSurface)
        (mCircleView.background as ShapeDrawable).paint.color = backgroundColor
        setColorSchemeColors(context.colorOnSurfaceVariant)
    }
}

```

================================================
FILE: ./app/src/main/java/com/google/android/material/carousel/CustomHeroCarouselStrategy.java
================================================
```
package com.google.android.material.carousel;
import static com.google.android.material.carousel.CarouselStrategyHelper.createKeylineState;
import static com.google.android.material.carousel.CarouselStrategyHelper.getSmallSizeMax;
import static com.google.android.material.carousel.CarouselStrategyHelper.getSmallSizeMin;
import android.view.View;
import androidx.annotation.NonNull;
import androidx.core.math.MathUtils;
import androidx.recyclerview.widget.RecyclerView.LayoutParams;
public class CustomHeroCarouselStrategy extends CarouselStrategy {
    @Override
    @NonNull
    KeylineState onFirstChildMeasuredWithMargins(@NonNull Carousel carousel, @NonNull View child) {
        int availableSpace = carousel.getContainerHeight();
        if (carousel.isHorizontal()) {
            availableSpace = carousel.getContainerWidth();
        }
        LayoutParams childLayoutParams = (LayoutParams) child.getLayoutParams();
        float childMargins = childLayoutParams.topMargin + childLayoutParams.bottomMargin;
        float measuredChildSize = child.getMeasuredWidth();
        if (carousel.isHorizontal()) {
            childMargins = childLayoutParams.leftMargin + childLayoutParams.rightMargin;
            measuredChildSize = child.getMeasuredHeight();
        }
        float smallSizeMin = getSmallSizeMin(child.getContext()) / 2;
        float smallSizeMax = getSmallSizeMax(child.getContext());
        float smallChildSizeMin = smallSizeMin + childMargins;
        float smallChildSizeMax = smallSizeMax + childMargins;
        float targetLargeChildSize = measuredChildSize + childMargins;
        float targetSmallChildSize =
                MathUtils.clamp(
                        measuredChildSize * 2F / 3F + childMargins,
                        smallChildSizeMin,
                        smallChildSizeMax);
        Arrangement arrangement = new Arrangement(
                 0,
                targetSmallChildSize,
                smallChildSizeMin,
                smallChildSizeMax,
                 2,
                 0,
                 0,
                targetLargeChildSize,
                 1,
                availableSpace);
        return createKeylineState(
                child.getContext(),
                childMargins,
                availableSpace,
                arrangement,
                carousel.getCarouselAlignment());
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/App.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.os.Build
import android.view.ViewConfiguration
import androidx.appcompat.app.AppCompatDelegate
import com.google.android.material.color.DynamicColors
import dagger.hilt.android.HiltAndroidApp
import me.gm.cleaner.plugin.dao.RootPreferences
import org.lsposed.hiddenapibypass.HiddenApiBypass
@HiltAndroidApp
class App : Application() {
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            HiddenApiBypass.addHiddenApiExemptions("")
        }
    }
    override fun onCreate() {
        super.onCreate()
        RootPreferences.init(createDeviceProtectedStorageContext())
        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
        DynamicColors.applyToActivitiesIfAvailable(this)
        reduceScaledMinimumScalingSpan()
    }
    @SuppressLint("BlockedPrivateApi")
    private fun reduceScaledMinimumScalingSpan() {
        val field = ViewConfiguration::class.java.getDeclaredField("mMinScalingSpan")
        field.isAccessible = true
        val viewConfiguration = ViewConfiguration.get(this)
        field.set(viewConfiguration, viewConfiguration.scaledTouchSlop * 2)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/BaseActivity.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.content.res.Configuration
import android.os.Bundle
import android.view.View
import android.view.WindowManager
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.view.WindowCompat
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R
abstract class BaseActivity : AppCompatActivity() {
    lateinit var appBarLayout: AppBarLayout
    override fun setContentView(view: View) {
        super.setContentView(view)
        appBarLayout = findViewById(R.id.toolbar_container)
        val toolbar: Toolbar = findViewById(R.id.toolbar)
        setSupportActionBar(toolbar)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        WindowCompat.setDecorFitsSystemWindows(window, false)
        window.attributes.layoutInDisplayCutoutMode = when (resources.configuration.orientation) {
            Configuration.ORIENTATION_PORTRAIT -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES
            Configuration.ORIENTATION_LANDSCAPE -> WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT
            else -> throw IllegalArgumentException()
        }
    }
    override fun onSupportNavigateUp(): Boolean {
        if (!super.onSupportNavigateUp()) {
            finish()
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/BaseFragment.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.content.pm.ActivityInfo
import android.os.Bundle
import android.view.View
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.WindowInsetsControllerCompat
import androidx.fragment.app.Fragment
import androidx.navigation.NavDestination
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R
import java.lang.ref.WeakReference
abstract class BaseFragment : Fragment() {
    val supportActionBar: ActionBar?
        get() = (activity as? AppCompatActivity)?.supportActionBar
    val appBarLayout: AppBarLayout?
        get() = activity?.findViewById(R.id.toolbar_container)
    protected var liftOnScrollTargetView: WeakReference<View>? = null
    @Deprecated("Deprecated in Java")
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        appBarLayout?.setLiftOnScrollTargetView(liftOnScrollTargetView?.get())
    }
    open fun toggleAppBar(show: Boolean) {
        val window = requireActivity().window
        val insetsController = WindowInsetsControllerCompat(window, window.decorView)
        insetsController.systemBarsBehavior =
            WindowInsetsControllerCompat.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
        if (show) {
            supportActionBar?.show()
            insetsController.show(WindowInsetsCompat.Type.systemBars())
        } else {
            supportActionBar?.hide()
            insetsController.hide(WindowInsetsCompat.Type.systemBars())
        }
    }
    fun restoreAppBar(currentDestination: NavDestination) {
        supportActionBar?.apply {
            title = currentDestination.label
            subtitle = null
        }
        toggleAppBar(true)
        requireActivity().requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/ConfirmationDialog.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import androidx.fragment.app.viewModels
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import java.util.function.Consumer
class ConfirmationDialog : AppCompatDialogFragment() {
    private val viewModel: ConfirmationViewModel by viewModels()
    private val pendingViewModelActions: MutableList<Runnable> = mutableListOf()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        if (savedInstanceState == null) {
            val iterator = pendingViewModelActions.iterator()
            while (iterator.hasNext()) {
                iterator.next().run()
                iterator.remove()
            }
        }
    }
    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getCharSequence(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok) { _, _ ->
                viewModel.onPositiveButtonClickListeners.forEach { listener ->
                    listener.accept(this)
                }
            }
            .setNegativeButton(android.R.string.cancel) { _, _ ->
                viewModel.onNegativeButtonClickListeners.forEach { listener ->
                    listener.accept(this)
                }
            }
            .create()
    private fun handleAction(action: Runnable) {
        if (!isAdded) {
            pendingViewModelActions += action
        } else {
            action.run()
        }
    }
    fun addOnPositiveButtonClickListener(onPositiveButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onPositiveButtonClickListeners.add(onPositiveButtonClickListener)
        }
    fun removeOnPositiveButtonClickListener(onPositiveButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onPositiveButtonClickListeners.remove(onPositiveButtonClickListener)
        }
    fun clearOnPositiveButtonClickListeners() = handleAction {
        viewModel.onPositiveButtonClickListeners.clear()
    }
    fun addOnNegativeButtonClickListener(onNegativeButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onNegativeButtonClickListeners.add(onNegativeButtonClickListener)
        }
    fun removeOnNegativeButtonClickListener(onNegativeButtonClickListener: Consumer<ConfirmationDialog>) =
        handleAction {
            viewModel.onNegativeButtonClickListeners.remove(onNegativeButtonClickListener)
        }
    fun clearOnNegativeButtonClickListeners() = handleAction {
        viewModel.onNegativeButtonClickListeners.clear()
    }
    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"
        fun newInstance(message: CharSequence): ConfirmationDialog = ConfirmationDialog().apply {
            arguments = bundleOf(KEY_MESSAGE to message)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/ConfirmationViewModel.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.app.Application
import androidx.lifecycle.AndroidViewModel
import java.util.function.Consumer
class ConfirmationViewModel(application: Application) : AndroidViewModel(application) {
    val onPositiveButtonClickListeners = mutableSetOf<Consumer<ConfirmationDialog>>()
    val onNegativeButtonClickListeners = mutableSetOf<Consumer<ConfirmationDialog>>()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/InfoDialog.kt
================================================
```
package me.gm.cleaner.plugin.app
import android.os.Bundle
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import com.google.android.material.dialog.MaterialAlertDialogBuilder
class InfoDialog : AppCompatDialogFragment() {
    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getString(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok, null)
            .create()
    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"
        fun newInstance(message: String): InfoDialog =
            InfoDialog().apply { arguments = bundleOf(KEY_MESSAGE to message) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/app/MainActivity.kt
================================================
```
package me.gm.cleaner.plugin.app
import dagger.hilt.android.AndroidEntryPoint
import me.gm.cleaner.plugin.ui.drawer.DrawerActivity
@AndroidEntryPoint
class MainActivity : DrawerActivity()

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/JsonSharedPreferencesImpl.java
================================================
```
package me.gm.cleaner.plugin.dao;
import android.content.SharedPreferences;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.function.Predicate;
public class JsonSharedPreferencesImpl implements SharedPreferences {
    private final Object mLock = new Object();
    private static final Object CONTENT = new Object();
    private final JSONObject mStore;
    private final WeakHashMap<OnSharedPreferenceChangeListener, Object> mListeners = new WeakHashMap<>();
    public JsonSharedPreferencesImpl() {
        mStore = new JSONObject();
    }
    public JsonSharedPreferencesImpl(JSONObject jsonObject) {
        mStore = jsonObject;
    }
    public JsonSharedPreferencesImpl(@Nullable String json) throws JSONException {
        if (TextUtils.isEmpty(json)) {
            mStore = new JSONObject();
        } else {
            mStore = new JSONObject(json);
        }
    }
    public JSONObject getDelegate() {
        synchronized (mLock) {
            try {
                return new JSONObject(mStore, getNames(mStore));
            } catch (JSONException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
        }
    }
    public static String[] getNames(JSONObject jo) {
        var length = jo.length();
        if (length == 0) {
            return null;
        }
        var iterator = jo.keys();
        var names = new String[length];
        var i = 0;
        while (iterator.hasNext()) {
            names[i] = iterator.next();
            i += 1;
        }
        return names;
    }
    @Override
    public Map<String, ?> getAll() {
        var all = new HashMap<String, Object>();
        synchronized (mLock) {
            var iterator = mStore.keys();
            while (iterator.hasNext()) {
                var key = iterator.next();
                all.put(key, mStore.opt(key));
            }
        }
        return all;
    }
    @SuppressWarnings("unchecked")
    private <T> T get(String key, @Nullable T defValue) {
        synchronized (mLock) {
            var result = mStore.opt(key);
            if (result == null) {
                return defValue;
            }
            return (T) result;
        }
    }
    @Nullable
    @Override
    public String getString(String key, @Nullable String defValue) {
        return get(key, defValue);
    }
    @Nullable
    @Override
    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {
        synchronized (mLock) {
            var result = new HashSet<String>();
            var jsonArray = mStore.optJSONArray(key);
            if (jsonArray == null) {
                return defValues;
            }
            try {
                for (int i = 0, length = jsonArray.length(); i < length; i++) {
                    result.add(jsonArray.get(i).toString());
                }
            } catch (JSONException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
            return result;
        }
    }
    @Override
    public int getInt(String key, int defValue) {
        return get(key, defValue);
    }
    @Override
    public long getLong(String key, long defValue) {
        return get(key, defValue);
    }
    @Override
    public float getFloat(String key, float defValue) {
        return get(key, defValue);
    }
    @Override
    public boolean getBoolean(String key, boolean defValue) {
        return get(key, defValue);
    }
    @Override
    public boolean contains(String key) {
        synchronized (mLock) {
            return mStore.has(key);
        }
    }
    @Override
    public JsonEditorImpl edit() {
        return new JsonEditorImpl(jsonObject -> false);
    }
    @Override
    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        synchronized (mLock) {
            mListeners.put(listener, CONTENT);
        }
    }
    @Override
    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        synchronized (mLock) {
            mListeners.remove(listener);
        }
    }
    @NonNull
    @Override
    public String toString() {
        synchronized (mLock) {
            return mStore.toString();
        }
    }
    public class JsonEditorImpl implements Editor {
        private final Object mEditorLock = new Object();
        private final Map<String, Object> mModified = new HashMap<>();
        private boolean mClear = false;
        private final Predicate<JSONObject> mAwaitCommit;
        public JsonEditorImpl(Predicate<JSONObject> awaitCommit) {
            mAwaitCommit = awaitCommit;
        }
        @Override
        public Editor putString(String key, @Nullable String value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        @Override
        public Editor putStringSet(String key, @Nullable Set<String> values) {
            synchronized (mEditorLock) {
                mModified.put(key, new JSONArray(values));
                return this;
            }
        }
        @Override
        public Editor putInt(String key, int value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        @Override
        public Editor putLong(String key, long value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        @Override
        public Editor putFloat(String key, float value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        @Override
        public Editor putBoolean(String key, boolean value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        public Editor putAny(String key, Object value) {
            synchronized (mEditorLock) {
                mModified.put(key, value);
                return this;
            }
        }
        @Override
        public Editor remove(String key) {
            synchronized (mEditorLock) {
                mModified.put(key, this);
                return this;
            }
        }
        @Override
        public Editor clear() {
            synchronized (mEditorLock) {
                mClear = true;
                return this;
            }
        }
        @Override
        public boolean commit() {
            var jsonToWriteToDisk = commitToMemory();
            return commitToDisk(jsonToWriteToDisk);
        }
        @NonNull
        private JSONObject commitToMemory() {
            JSONObject jsonToWriteToDisk;
            Set<OnSharedPreferenceChangeListener> listeners;
            var keysModified = new ArrayList<String>();
            synchronized (mLock) {
                listeners = mListeners.keySet();
                var hasListeners = !listeners.isEmpty();
                synchronized (mEditorLock) {
                    if (mClear) {
                        mModified.clear();
                        mStore.keys().forEachRemaining(this::remove);
                        mClear = false;
                    }
                    for (Map.Entry<String, Object> e : mModified.entrySet()) {
                        String k = e.getKey();
                        Object v = e.getValue();
                        if (v == this || v == null) {
                            if (!contains(k)) {
                                continue;
                            }
                            mStore.remove(k);
                        } else {
                            Object existingValue = get(k, null);
                            if (existingValue != null && existingValue.equals(v)) {
                                continue;
                            }
                            try {
                                mStore.put(k, v);
                            } catch (JSONException jsonException) {
                                jsonException.printStackTrace();
                                throw new RuntimeException(jsonException);
                            }
                        }
                        if (hasListeners) {
                            keysModified.add(k);
                        }
                    }
                    mModified.clear();
                }
                jsonToWriteToDisk = new JSONObject(getAll());
            }
            notifyListeners(listeners, keysModified);
            return jsonToWriteToDisk;
        }
        private void notifyListeners(Set<OnSharedPreferenceChangeListener> listeners, List<String> keysModified) {
            if (Looper.myLooper() == Looper.getMainLooper()) {
                for (int i = keysModified.size() - 1; i >= 0; i--) {
                    final String key = keysModified.get(i);
                    for (OnSharedPreferenceChangeListener listener : listeners) {
                        if (listener != null) {
                            listener.onSharedPreferenceChanged(JsonSharedPreferencesImpl.this, key);
                        }
                    }
                }
            } else {
                new Handler(Looper.getMainLooper()).post(() -> notifyListeners(listeners, keysModified));
            }
        }
        public boolean commitToDisk(JSONObject jo) {
            return mAwaitCommit.test(jo);
        }
        @Override
        public void apply() {
            var jsonToWriteToDisk = commitToMemory();
            new Thread(() -> commitToDisk(jsonToWriteToDisk)).start();
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/ListConverter.kt
================================================
```
package me.gm.cleaner.plugin.dao
import androidx.room.TypeConverter
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import java.lang.Character.MAX_RADIX
import java.math.BigInteger
object ListConverter {
    @TypeConverter
    fun fromString(value: String?): List<String>? {
        val listType = object : TypeToken<List<String>?>() {}.type
        val list = Gson().fromJson<List<String?>?>(value, listType)
        return if (list.isEmpty() || list.any { it == null }) null
        else list as List<String>?
    }
    @TypeConverter
    fun listToString(list: List<String>?) = Gson().toJson(list)
    @TypeConverter
    fun booleanListFromString(value: String): List<Boolean> {
        val splitIndex = value.indexOf(':', 1)
        val size = value.substring(0, splitIndex).toInt()
        val values = BigInteger(value.substring(splitIndex + 1), MAX_RADIX)
        val list = MutableList(size) { i ->
            values.testBit(i)
        }
        return list
    }
    @TypeConverter
    fun booleanListToString(list: List<Boolean>): String {
        var value = BigInteger("0", MAX_RADIX)
        list.forEachIndexed { index, b ->
            if (b) {
                value = value.setBit(index)
            }
        }
        return "${list.size}:${value.toString(MAX_RADIX)}"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/MediaProviderRecord.kt
================================================
```
package me.gm.cleaner.plugin.dao
import android.content.pm.PackageInfo
import android.database.Cursor
import androidx.annotation.IntDef
import androidx.room.*
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
@Entity
data class MediaProviderRecord(
    @PrimaryKey(autoGenerate = true) val id: Int,
    @ColumnInfo(name = "time_millis") val timeMillis: Long,
    @ColumnInfo(name = "package_name") val packageName: String,
    @ColumnInfo(name = "match") val match: Int,
    @ColumnInfo(name = "operation") @MediaProviderOperation val operation: Int,
    @ColumnInfo(name = "data") val data: List<String>,
    @ColumnInfo(name = "mime_type") val mimeType: List<String>,
    @ColumnInfo(name = "intercepted") val intercepted: List<Boolean>,
) {
    @Ignore
    var packageInfo: PackageInfo? = null
    @Ignore
    var label: String? = null
    companion object {
        fun convert(cursor: Cursor): List<MediaProviderRecord> {
            if (cursor.count == 0) {
                return emptyList()
            }
            val timeMillisColumn = cursor.getColumnIndexOrThrow("time_millis")
            val packageNameColumn = cursor.getColumnIndexOrThrow("package_name")
            val matchColumn = cursor.getColumnIndexOrThrow("match")
            val operationColumn = cursor.getColumnIndexOrThrow("operation")
            val dataColumn = cursor.getColumnIndexOrThrow("data")
            val mimeTypeColumn = cursor.getColumnIndexOrThrow("mime_type")
            val interceptedColumn = cursor.getColumnIndexOrThrow("intercepted")
            val records = mutableListOf<MediaProviderRecord>()
            while (cursor.moveToNext()) {
                records += MediaProviderRecord(
                    0,
                    cursor.getLong(timeMillisColumn),
                    cursor.getString(packageNameColumn),
                    cursor.getInt(matchColumn),
                    cursor.getInt(operationColumn),
                    ListConverter.fromString(cursor.getString(dataColumn)) ?: continue,
                    ListConverter.fromString(cursor.getString(mimeTypeColumn)) ?: continue,
                    ListConverter.booleanListFromString(cursor.getString(interceptedColumn)),
                )
            }
            return records
        }
    }
}
@Dao
interface MediaProviderRecordDao {
    @Query("SELECT * FROM MediaProviderRecord WHERE time_millis BETWEEN (:start) AND (:end) AND operation IN (:operations) ORDER BY time_millis DESC")
    fun loadForTimeMillis(
        start: Long, end: Long, @MediaProviderOperation vararg operations: Int
    ): Cursor
    @Query("SELECT count(*) FROM MediaProviderRecord WHERE package_name IN (:packageNames) AND operation IN (:operation)")
    fun packageUsageTimes(@MediaProviderOperation operation: Int, vararg packageNames: String): Int
    @Insert
    fun insert(records: MediaProviderRecord)
    @Delete
    fun delete(record: MediaProviderRecord)
}
@IntDef(value = [OP_QUERY, OP_INSERT, OP_DELETE])
@kotlin.annotation.Retention(AnnotationRetention.SOURCE)
annotation class MediaProviderOperation {
    companion object {
        const val OP_QUERY = 0
        const val OP_INSERT = 1
        const val OP_DELETE = 2
    }
}
@Database(entities = [MediaProviderRecord::class], version = 2, exportSchema = false)
@TypeConverters(ListConverter::class)
abstract class MediaProviderRecordDatabase : RoomDatabase() {
    abstract fun mediaProviderRecordDao(): MediaProviderRecordDao
}
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(_db: SupportSQLiteDatabase) {
        _db.execSQL("DELETE FROM `MediaProviderQueryRecord`")
        _db.execSQL("DELETE FROM `MediaProviderInsertRecord`")
        _db.execSQL("DELETE FROM `MediaProviderDeleteRecord`")
        _db.execSQL("CREATE TABLE IF NOT EXISTS `MediaProviderRecord` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `time_millis` INTEGER NOT NULL, `package_name` TEXT NOT NULL, `match` INTEGER NOT NULL, `operation` INTEGER NOT NULL, `data` TEXT NOT NULL, `mime_type` TEXT NOT NULL, `intercepted` TEXT NOT NULL)")
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/RootPreferences.kt
================================================
```
package me.gm.cleaner.plugin.dao
import android.content.Context
import android.content.SharedPreferences
import android.content.res.Resources
import androidx.core.content.edit
import androidx.preference.PreferenceManager
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.util.FlowableSharedPreferences
object RootPreferences {
    const val SORT_BY_APP_NAME = 0
    const val SORT_BY_UPDATE_TIME = 1
    const val SORT_BY_PATH = 0
    const val SORT_BY_DATE_TAKEN = 1
    const val SORT_BY_SIZE = 2
    private lateinit var resources: Resources
    private lateinit var defaultSp: SharedPreferences
    fun init(context: Context) {
        resources = context.resources
        defaultSp = PreferenceManager.getDefaultSharedPreferences(context)
    }
    var startDestination: Int
        get() = defaultSp.getInt(
            resources.getString(R.string.start_destination_key), R.id.about_fragment
        )
        set(value) = defaultSp.edit {
            putInt(resources.getString(R.string.start_destination_key), value)
        }
    val sortByFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.sort_key),
            SORT_BY_APP_NAME
        )
    }
    val ruleCountFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_rule_count_key),
            true
        )
    }
    val isHideSystemAppFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_system_app_key),
            true
        )
    }
    val isHideQueryFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_query_key),
            false
        )
    }
    val isHideInsertFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_insert_key),
            false
        )
    }
    val isHideDeleteFlowable: FlowableSharedPreferences<Boolean> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.menu_hide_delete_key),
            false
        )
    }
    val sortMediaByFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.sort_media_key),
            SORT_BY_PATH
        )
    }
    val spanCountFlowable: FlowableSharedPreferences<Int> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.span_count_key),
            3
        )
    }
    val playbackSpeedFlowable: FlowableSharedPreferences<Float> by lazy {
        FlowableSharedPreferences(
            defaultSp,
            resources.getString(R.string.playback_speed_key),
            1F
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/dao/SharedPreferencesWrapper.java
================================================
```
package me.gm.cleaner.plugin.dao;
import android.content.SharedPreferences;
import androidx.annotation.Nullable;
import java.util.Map;
import java.util.Set;
public class SharedPreferencesWrapper implements SharedPreferences {
    protected SharedPreferences delegate;
    @Override
    public Map<String, ?> getAll() {
        return delegate.getAll();
    }
    @Nullable
    @Override
    public String getString(String key, @Nullable String defValue) {
        return delegate.getString(key, defValue);
    }
    @Nullable
    @Override
    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {
        return delegate.getStringSet(key, defValues);
    }
    @Override
    public int getInt(String key, int defValue) {
        return delegate.getInt(key, defValue);
    }
    @Override
    public long getLong(String key, long defValue) {
        return delegate.getLong(key, defValue);
    }
    @Override
    public float getFloat(String key, float defValue) {
        return delegate.getFloat(key, defValue);
    }
    @Override
    public boolean getBoolean(String key, boolean defValue) {
        return delegate.getBoolean(key, defValue);
    }
    @Override
    public boolean contains(String key) {
        return delegate.contains(key);
    }
    @Override
    public Editor edit() {
        return delegate.edit();
    }
    @Override
    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        delegate.registerOnSharedPreferenceChangeListener(listener);
    }
    @Override
    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
        delegate.unregisterOnSharedPreferenceChangeListener(listener);
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/github/ReadmeRepository.kt
================================================
```
package me.gm.cleaner.plugin.data.github
import javax.inject.Inject
class ReadmeRepository @Inject constructor(private val service: ReadmeService) {
    fun getRawReadme(languageTag: String): Result<String> = runCatching {
        when (languageTag) {
            "zh-CN", "zh-TW" -> service.zh.execute().body() ?: throw NullPointerException()
             else -> service.en.execute().body() ?: throw NullPointerException()
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/github/ReadmeService.kt
================================================
```
package me.gm.cleaner.plugin.data.github
import android.content.Context
import me.gm.cleaner.plugin.ktx.hasWifiTransport
import okhttp3.Cache
import okhttp3.OkHttpClient
import retrofit2.Call
import retrofit2.Retrofit
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.GET
import java.io.File
interface ReadmeService {
    @get:GET("README.md")
    val en: Call<String>
    @get:GET("README_zh-CN.md")
    val zh: Call<String>
    companion object {
        const val BASE_URL =
            "https://raw.githubusercontent.com/MaterialCleaner/Media-Provider-Manager/main/"
        fun create(context: Context): ReadmeService {
            val client = OkHttpClient.Builder()
                .addInterceptor { chain ->
                    val originalResponse = chain.proceed(chain.request())
                    if (context.hasWifiTransport) {
                        val maxAge = 60 * 60 * 24 * 7 
                        originalResponse.newBuilder()
                            .header("Cache-Control", "public, max-age=$maxAge")
                            .build()
                    } else {
                        val maxStale = 60 * 60 * 24 * 28 
                        originalResponse.newBuilder()
                            .header("Cache-Control", "public, only-if-cached, max-stale=$maxStale")
                            .build()
                    }
                }
                .cache(Cache(File(context.cacheDir, "okhttp"), 1024L * 1024L))
                .build()
            return Retrofit.Builder()
                .baseUrl(BASE_URL)
                .client(client)
                .addConverterFactory(ScalarsConverterFactory.create())
                .build()
                .create(ReadmeService::class.java)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashPhoto.kt
================================================
```
package me.gm.cleaner.plugin.data.unsplash
import com.google.gson.annotations.SerializedName
data class UnsplashPhoto(
    @field:SerializedName("format") val format: String,
    @field:SerializedName("width") val width: Int,
    @field:SerializedName("height") val height: Int,
    @field:SerializedName("filename") val filename: String,
    @field:SerializedName("id") val id: Int,
    @field:SerializedName("author") val author: String,
    @field:SerializedName("author_url") val authorUrl: String,
    @field:SerializedName("post_url") val postUrl: String,
) {
    fun getPhotoUrl(requestWidth: Int) = PHOTO_URL_BASE.format(requestWidth, id)
    companion object {
        private const val PHOTO_URL_BASE = "https://unsplash.it/%d?image=%d"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashRepository.kt
================================================
```
package me.gm.cleaner.plugin.data.unsplash
import javax.inject.Inject
class UnsplashRepository @Inject constructor(private val service: UnsplashService) {
    fun fetchUnsplashPhotoList(): Result<List<UnsplashPhoto>> = runCatching {
        service.feed.execute().body() ?: throw NullPointerException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/data/unsplash/UnsplashService.kt
================================================
```
package me.gm.cleaner.plugin.data.unsplash
import retrofit2.Call
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
interface UnsplashService {
    @get:GET("/list")
    val feed: Call<List<UnsplashPhoto>>
    companion object {
        const val BASE_URL = "https://unsplash.it"
        fun create(): UnsplashService = Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(UnsplashService::class.java)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/AppGlideModule.java
================================================
```
package me.gm.cleaner.plugin.di;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.graphics.Bitmap;
import android.net.Uri;
import androidx.annotation.NonNull;
import com.bumptech.glide.Glide;
import com.bumptech.glide.Registry;
import com.bumptech.glide.annotation.GlideModule;
import java.nio.ByteBuffer;
import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.MediaModelLoader;
import me.zhanghai.android.appiconloader.glide.AppIconModelLoader;
@GlideModule
public class AppGlideModule extends com.bumptech.glide.module.AppGlideModule {
    @Override
    public boolean isManifestParsingEnabled() {
        return false;
    }
    @Override
    public void registerComponents(@NonNull Context context, @NonNull Glide glide,
                                   @NonNull Registry registry) {
        int iconSize = context.getResources().getDimensionPixelSize(R.dimen.badge_size);
        registry.prepend(PackageInfo.class, Bitmap.class, new AppIconModelLoader.Factory(iconSize,
                false, context))
                .prepend(Uri.class, ByteBuffer.class, new MediaModelLoader.Factory(context));
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/BinderModule.kt
================================================
```
package me.gm.cleaner.plugin.di
import android.content.Context
import android.provider.MediaStore
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton
@InstallIn(SingletonComponent::class)
@Module
class BinderModule {
    @Singleton
    @Provides
    fun provideBinder(@ApplicationContext context: Context) = context.contentResolver.query(
        MediaStore.Images.Media.INTERNAL_CONTENT_URI, null, null, null, null
    )?.use {
        it.extras.getBinder("me.gm.cleaner.plugin.cursor.extra.BINDER")
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/di/NetworkModule.kt
================================================
```
package me.gm.cleaner.plugin.di
import android.content.Context
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import me.gm.cleaner.plugin.data.github.ReadmeService
import me.gm.cleaner.plugin.data.unsplash.UnsplashService
import javax.inject.Singleton
@InstallIn(SingletonComponent::class)
@Module
class NetworkModule {
    @Singleton
    @Provides
    fun provideReadmeService(@ApplicationContext context: Context) = ReadmeService.create(context)
    @Singleton
    @Provides
    fun provideUnsplashService() = UnsplashService.create()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Configuration.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.content.res.Configuration
import android.os.Build
import android.view.View
val Configuration.isNightModeActiveCompat
    get() = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
        isNightModeActive
    } else {
        uiMode and Configuration.UI_MODE_NIGHT_MASK == Configuration.UI_MODE_NIGHT_YES
    }
val Configuration.isRtl
    get() = layoutDirection == View.LAYOUT_DIRECTION_RTL

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Context.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.res.ColorStateList
import android.content.res.TypedArray
import android.graphics.drawable.Drawable
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.Spanned
import android.text.style.ForegroundColorSpan
import android.text.style.TextAppearanceSpan
import android.widget.Toast
import androidx.annotation.AnyRes
import androidx.annotation.AttrRes
import androidx.annotation.ColorInt
fun Context.buildSpannableString(
    text: CharSequence,
    style: Int = com.google.android.material.R.attr.textAppearanceBody2,
    color: Int? = colorAccent
): SpannableStringBuilder = SpannableStringBuilder(text).apply {
    setSpan(
        TextAppearanceSpan(this@buildSpannableString, getResourceIdByAttr(style)), 0, length,
        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE
    )
    if (color != null) {
        setSpan(ForegroundColorSpan(color), 0, length, Spannable.SPAN_INCLUSIVE_INCLUSIVE)
    }
}
fun Context.startActivitySafe(intent: Intent) {
    try {
        startActivity(intent)
    } catch (e: ActivityNotFoundException) {
        Toast.makeText(this, e.message, Toast.LENGTH_SHORT).show()
    }
}
val Context.hasWifiTransport: Boolean
    get() {
        val connManager =
            getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val capabilities = connManager.getNetworkCapabilities(connManager.activeNetwork)
        return capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true
    }
inline fun <T : TypedArray, R> T.use(block: (T) -> R): R = try {
    block(this)
} finally {
    recycle()
}
fun Context.getDimenByAttr(@AttrRes attr: Int): Float =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getDimension(0, 0F)
    }
@ColorInt
fun Context.getColorByAttr(@AttrRes attr: Int): Int? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getColorStateList(0)?.defaultColor
    }
fun Context.getColorStateListByAttr(@AttrRes attr: Int): ColorStateList? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getColorStateList(0)
    }
fun Context.getDrawableByAttr(@AttrRes attr: Int): Drawable? =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getDrawable(0)
    }
@AnyRes
fun Context.getResourceIdByAttr(@AttrRes attr: Int, index: Int = 0): Int =
    obtainStyledAttributes(intArrayOf(attr)).use {
        it.getResourceId(index, 0)
    }
fun Context.dpToPx(dps: Int): Int {
    val density = resources.displayMetrics.density
    return (dps * density + 0.5F).toInt()
}
fun Context.pxToDp(px: Int): Int {
    val density = resources.displayMetrics.density
    return (px / density).toInt()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/ContextConstants.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.content.Context
import android.content.res.ColorStateList
import androidx.annotation.ColorInt
val Context.colorPrimary: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorPrimary)!!
val Context.colorPrimaryContainer: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorPrimaryContainer)!!
val Context.colorOnPrimaryContainer: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnPrimaryContainer)!!
val Context.colorAccent: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorAccent)!!
val Context.colorBackground: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorBackground)!!
val Context.colorBackgroundFloating: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorBackgroundFloating)!!
val Context.colorSurface: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorSurface)!!
val Context.colorOnSurface: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnSurface)!!
val Context.colorOnSurfaceVariant: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorOnSurfaceVariant)!!
val Context.colorError: Int
    @ColorInt
    get() = getColorByAttr(com.google.android.material.R.attr.colorError)!!
val Context.colorControlNormal: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorControlNormal)!!
val Context.colorControlHighlight: Int
    @ColorInt
    get() = getColorByAttr(android.R.attr.colorControlHighlight)!!
val Context.textColorPrimary: ColorStateList
    get() = getColorStateListByAttr(android.R.attr.textColorPrimary)!!
val Context.textColorPrimaryInverse: ColorStateList
    get() = getColorStateListByAttr(android.R.attr.textColorPrimaryInverse)!!
val Context.navAnimTime: Long
    get() = resources.getInteger(androidx.navigation.ui.R.integer.config_navAnimTime).toLong()
val Context.shortAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_shortAnimTime).toLong()
val Context.mediumAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_mediumAnimTime).toLong()
val Context.longAnimTime: Long
    get() = resources.getInteger(android.R.integer.config_longAnimTime).toLong()

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Flow.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlin.reflect.KProperty
operator fun <T> StateFlow<T>.getValue(thisObj: Any?, property: KProperty<*>): T = value
operator fun <T> MutableStateFlow<T>.setValue(
    thisObj: Any?, property: KProperty<*>, value: T
) {
    this.value = value
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/MaterialDialog.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.annotation.SuppressLint
import android.content.Context
import android.content.res.ColorStateList
import android.graphics.Rect
import android.os.Build
import android.os.Build.VERSION_CODES
import android.util.TypedValue
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes
import androidx.appcompat.view.ContextThemeWrapper
import com.google.android.material.R
import com.google.android.material.color.MaterialColors
import com.google.android.material.dialog.MaterialDialogs
import com.google.android.material.resources.MaterialAttributes
import com.google.android.material.shape.MaterialShapeDrawable
import com.google.android.material.theme.overlay.MaterialThemeOverlay
@AttrRes
val DEF_STYLE_ATTR = R.attr.alertDialogStyle
@StyleRes
val DEF_STYLE_RES = R.style.MaterialAlertDialog_MaterialComponents
@AttrRes
val MATERIAL_ALERT_DIALOG_THEME_OVERLAY = R.attr.materialAlertDialogTheme
@SuppressLint("RestrictedApi")
private fun getMaterialAlertDialogThemeOverlay(context: Context): Int {
    val materialAlertDialogThemeOverlay =
        MaterialAttributes.resolve(context, MATERIAL_ALERT_DIALOG_THEME_OVERLAY) ?: return 0
    return materialAlertDialogThemeOverlay.data
}
fun Context.createMaterialAlertDialogThemedContext(): Context {
    val themeOverlayId = getMaterialAlertDialogThemeOverlay(this)
    val themedContext = MaterialThemeOverlay.wrap(this, null, DEF_STYLE_ATTR, DEF_STYLE_RES)
    if (themeOverlayId == 0) {
        return themedContext
    }
    return ContextThemeWrapper(themedContext, themeOverlayId)
}
@SuppressLint("RestrictedApi")
fun Context.materialDialogBackgroundInsets(): Rect = MaterialDialogs.getDialogBackgroundInsets(
    this, DEF_STYLE_ATTR, DEF_STYLE_RES
)
fun Context.materialDialogBackgroundDrawable(): MaterialShapeDrawable {
    val surfaceColor = MaterialColors.getColor(this, R.attr.colorSurface, javaClass.canonicalName)
    val materialShapeDrawable = MaterialShapeDrawable(this, null, DEF_STYLE_ATTR, DEF_STYLE_RES)
    materialShapeDrawable.initializeElevationOverlay(this)
    materialShapeDrawable.fillColor = ColorStateList.valueOf(surfaceColor)
    if (Build.VERSION.SDK_INT >= VERSION_CODES.P) {
        val dialogCornerRadiusValue = TypedValue()
        theme.resolveAttribute(android.R.attr.dialogCornerRadius, dialogCornerRadiusValue, true)
        val dialogCornerRadius = dialogCornerRadiusValue.getDimension(resources.displayMetrics)
        if (dialogCornerRadiusValue.type === TypedValue.TYPE_DIMENSION && dialogCornerRadius >= 0) {
            materialShapeDrawable.setCornerSize(dialogCornerRadius)
        }
    }
    return materialShapeDrawable
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/NavController.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.os.Bundle
import androidx.navigation.NavController
import androidx.navigation.NavController.OnDestinationChangedListener
import androidx.navigation.NavDestination
private val destinationToListener: MutableMap<NavDestination, OneShotDestinationChangedListener> =
    mutableMapOf()
fun NavController.addOnExitListener(action: (controller: NavController, destination: NavDestination, arguments: Bundle?) -> Unit) {
    val newListener = OneShotDestinationChangedListener(this, action)
    val oldListener = destinationToListener.put(currentDestination!!, newListener)
    if (oldListener != null) {
        removeOnDestinationChangedListener(oldListener)
    }
    addOnDestinationChangedListener(newListener)
}
class OneShotDestinationChangedListener(
    navController: NavController,
    private val action: (controller: NavController, destination: NavDestination, arguments: Bundle?) -> Unit
) : OnDestinationChangedListener {
    private val callerDestination = navController.currentDestination
    override fun onDestinationChanged(
        controller: NavController, destination: NavDestination, arguments: Bundle?
    ) {
        if (destination != callerDestination) {
            destinationToListener.remove(callerDestination)
            controller.removeOnDestinationChangedListener(this)
            action(controller, destination, arguments)
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/RecyclerView.kt
================================================
```
package me.gm.cleaner.plugin.ktx
import android.graphics.Canvas
import android.graphics.Rect
import android.graphics.drawable.Drawable
import android.view.View
import androidx.core.view.doOnPreDraw
import androidx.core.view.forEach
import androidx.recyclerview.widget.DefaultItemAnimator
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.zhanghai.android.fastscroll.FastScroller
private val rect = Rect()
fun <T, VH : RecyclerView.ViewHolder> ListAdapter<T, VH>.submitListKeepPosition(
    list: List<T>, recyclerView: RecyclerView, commitCallback: Runnable? = null
) {
    val layoutManager = recyclerView.layoutManager as LinearLayoutManager
    val position = layoutManager.findFirstVisibleItemPosition()
    if (position == RecyclerView.NO_POSITION) {
        submitList(list, commitCallback)
    } else {
        recyclerView.getDecoratedBoundsWithMargins(
            layoutManager.findViewByPosition(position)!!, rect
        )
        submitList(list) {
            layoutManager.scrollToPositionWithOffset(position, rect.top - recyclerView.paddingTop)
            commitCallback?.run()
        }
    }
}
class DividerDecoration(private val list: RecyclerView) : RecyclerView.ItemDecoration() {
    private lateinit var divider: Drawable
    private var dividerHeight = 0
    private var allowDividerAfterLastItem = true
    override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
        if (!::divider.isInitialized) {
            return
        }
        val width = parent.width
        parent.forEach { view ->
            if (shouldDrawDividerBelow(view, parent)) {
                val top = view.y.toInt() + view.height
                divider.setBounds(0, top, width, top + dividerHeight)
                divider.setTint(parent.context.colorControlHighlight)
                divider.draw(c)
            }
        }
    }
    override fun getItemOffsets(
        outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State
    ) {
        if (shouldDrawDividerBelow(view, parent)) {
            outRect.bottom = dividerHeight
        }
    }
    private fun shouldDrawDividerBelow(view: View, parent: RecyclerView): Boolean {
        val holder = parent.getChildViewHolder(view)
        val dividerAllowedBelow = holder is DividerViewHolder && holder.isDividerAllowedBelow
        if (dividerAllowedBelow) {
            return true
        }
        var nextAllowed = allowDividerAfterLastItem
        val index = parent.indexOfChild(view)
        if (index < parent.childCount - 1) {
            val nextView = parent.getChildAt(index + 1)
            val nextHolder = parent.getChildViewHolder(nextView)
            nextAllowed = nextHolder is DividerViewHolder && nextHolder.isDividerAllowedAbove
        }
        return nextAllowed
    }
    fun setDivider(divider: Drawable) {
        dividerHeight = divider.intrinsicHeight
        this.divider = divider
        list.invalidateItemDecorations()
    }
    fun setDividerHeight(dividerHeight: Int) {
        this.dividerHeight = dividerHeight
        list.invalidateItemDecorations()
    }
    fun setAllowDividerAfterLastItem(allowDividerAfterLastItem: Boolean) {
        this.allowDividerAfterLastItem = allowDividerAfterLastItem
    }
}
abstract class DividerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    var isDividerAllowedAbove = false
    var isDividerAllowedBelow = false
}
fun RecyclerView.overScrollIfContentScrollsPersistent(supportsChangeAnimations: Boolean = true) {
    doOnPreDraw {
        overScrollIfContentScrolls()
    }
    addOnLayoutChangeListener { _, _, _, _, _, _, _, _, _ -> overScrollIfContentScrolls() }
    itemAnimator = object : DefaultItemAnimator() {
        init {
            this.supportsChangeAnimations = supportsChangeAnimations
        }
        override fun onAnimationFinished(viewHolder: RecyclerView.ViewHolder) {
            super.onAnimationFinished(viewHolder)
            overScrollIfContentScrolls()
        }
    }
}
fun RecyclerView.overScrollIfContentScrolls() {
    overScrollMode = if (isContentScrolls(this)) {
        View.OVER_SCROLL_IF_CONTENT_SCROLLS
    } else {
        View.OVER_SCROLL_NEVER
    }
}
private fun isContentScrolls(list: RecyclerView): Boolean {
    val layoutManager = list.layoutManager
    if (layoutManager == null || list.adapter == null || list.adapter?.itemCount == 0) {
        return false
    }
    if (!list.isItemCompletelyVisible(0)) {
        return true
    }
    return !list.isItemCompletelyVisible(layoutManager.itemCount - 1)
}
fun RecyclerView.isItemCompletelyVisible(position: Int): Boolean {
    val vh = findViewHolderForAdapterPosition(position)
    vh ?: return false
    val layoutManager = layoutManager!!
    return layoutManager.isViewPartiallyVisible(vh.itemView, true, true)
}
fun RecyclerView.isItemCompletelyInvisible(position: Int): Boolean {
    val vh = findViewHolderForAdapterPosition(position)
    vh ?: return true
    val layoutManager = layoutManager!!
    return !layoutManager.isViewPartiallyVisible(vh.itemView, true, true) &&
            !layoutManager.isViewPartiallyVisible(vh.itemView, false, false)
}
fun View.fitsSystemWindowInsets(fastScroller: FastScroller? = null) {
    val paddingLeft = paddingLeft
    val paddingTop = paddingTop
    val paddingRight = paddingRight
    val paddingBottom = paddingBottom
    setOnApplyWindowInsetsListener { view, insets ->
        view.setPadding(
            paddingLeft, paddingTop + insets.systemWindowInsetTop,
            paddingRight, paddingBottom + insets.systemWindowInsetBottom
        )
        fastScroller?.setPadding(
            0, paddingTop + insets.systemWindowInsetTop,
            0, paddingBottom + insets.systemWindowInsetBottom
        )
        insets
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ktx/Reflection.kt
================================================
```
package me.gm.cleaner.plugin.ktx
inline fun <reified T> Any.getObjectField(sourceCls: Class<*> = javaClass) =
    sourceCls.declaredFields
        .first { it.type == T::class.java }
        .apply { isAccessible = true }[this] as T
inline fun <reified T> Any.setObjectField(value: T, sourceCls: Class<*> = javaClass) {
    sourceCls.declaredFields
        .first { it.type == T::class.java }
        .apply { isAccessible = true }[this] = value
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/BaseParceledListSlice.java
================================================
```
package me.gm.cleaner.plugin.model;
import android.os.Binder;
import android.os.IBinder;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.RemoteException;
import android.util.Log;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
abstract class BaseParceledListSlice<T> implements Parcelable {
    private static String TAG = "ParceledListSlice";
    private static final int MAX_IPC_SIZE = 64 * 1024;
    private final List<T> mList;
    private int mInlineCountLimit = Integer.MAX_VALUE;
    public BaseParceledListSlice(List<T> list) {
        if (list == null) {
            mList = Collections.emptyList();
        } else {
            mList = list;
        }
    }
    @SuppressWarnings("unchecked")
    BaseParceledListSlice(Parcel p, ClassLoader loader) {
        final int N = p.readInt();
        mList = new ArrayList<T>(N);
        if (N <= 0) {
            return;
        }
        Creator<?> creator = readParcelableCreator(p, loader);
        Class<?> listElementClass = null;
        int i = 0;
        while (i < N) {
            if (p.readInt() == 0) {
                break;
            }
            final T parcelable = readCreator(creator, p, loader);
            if (listElementClass == null) {
                listElementClass = parcelable.getClass();
            } else {
                verifySameType(listElementClass, parcelable.getClass());
            }
            mList.add(parcelable);
            i++;
        }
        if (i >= N) {
            return;
        }
        final IBinder retriever = p.readStrongBinder();
        while (i < N) {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            data.writeInt(i);
            try {
                retriever.transact(IBinder.FIRST_CALL_TRANSACTION, data, reply, 0);
            } catch (RemoteException e) {
                Log.w(TAG, "Failure retrieving array; only received " + i + " of " + N, e);
                return;
            }
            while (i < N && reply.readInt() != 0) {
                final T parcelable = readCreator(creator, reply, loader);
                verifySameType(listElementClass, parcelable.getClass());
                mList.add(parcelable);
                i++;
            }
            reply.recycle();
            data.recycle();
        }
    }
    private T readCreator(Creator<?> creator, Parcel p, ClassLoader loader) {
        if (creator instanceof ClassLoaderCreator<?>) {
            ClassLoaderCreator<?> classLoaderCreator =
                    (ClassLoaderCreator<?>) creator;
            return (T) classLoaderCreator.createFromParcel(p, loader);
        }
        return (T) creator.createFromParcel(p);
    }
    private static void verifySameType(final Class<?> expected, final Class<?> actual) {
        if (!actual.equals(expected)) {
            throw new IllegalArgumentException("Can't unparcel type "
                    + (actual == null ? null : actual.getName()) + " in list of type "
                    + (expected == null ? null : expected.getName()));
        }
    }
    public List<T> getList() {
        return mList;
    }
    public void setInlineCountLimit(int maxCount) {
        mInlineCountLimit = maxCount;
    }
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        final int N = mList.size();
        final int callFlags = flags;
        dest.writeInt(N);
        if (N > 0) {
            final Class<?> listElementClass = mList.get(0).getClass();
            writeParcelableCreator(mList.get(0), dest);
            int i = 0;
            while (i < N && i < mInlineCountLimit && dest.dataSize() < MAX_IPC_SIZE) {
                dest.writeInt(1);
                final T parcelable = mList.get(i);
                verifySameType(listElementClass, parcelable.getClass());
                writeElement(parcelable, dest, callFlags);
                i++;
            }
            if (i < N) {
                dest.writeInt(0);
                Binder retriever = new Binder() {
                    @Override
                    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
                            throws RemoteException {
                        if (code != FIRST_CALL_TRANSACTION) {
                            return super.onTransact(code, data, reply, flags);
                        }
                        int i = data.readInt();
                        while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                            reply.writeInt(1);
                            final T parcelable = mList.get(i);
                            verifySameType(listElementClass, parcelable.getClass());
                            writeElement(parcelable, reply, callFlags);
                            i++;
                        }
                        if (i < N) {
                            reply.writeInt(0);
                        }
                        return true;
                    }
                };
                dest.writeStrongBinder(retriever);
            }
        }
    }
    protected abstract void writeElement(T parcelable, Parcel reply, int callFlags);
    protected abstract void writeParcelableCreator(T parcelable, Parcel dest);
    protected abstract Creator<?> readParcelableCreator(Parcel from, ClassLoader loader);
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/ParceledListSlice.java
================================================
```
package me.gm.cleaner.plugin.model;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.os.BadParcelableException;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
public class ParceledListSlice<T extends Parcelable> extends BaseParceledListSlice<T> {
    private static final String TAG = "ParceledListSlice";
    private static final HashMap<ClassLoader, HashMap<String, Creator<?>>>
            CREATORS = new HashMap<>();
    static {
        putCreator(PackageInfo.class.getName(), PackageInfo.CREATOR);
        putCreator(ApplicationInfo.class.getName(), ApplicationInfo.CREATOR);
    }
    public static void putCreator(String name, Creator<?> creator) {
        HashMap<String, Creator<?>> map = CREATORS.get(null);
        if (map == null) {
            map = new HashMap<>();
            CREATORS.put(null, map);
        }
        map.put(name, creator);
    }
    public ParceledListSlice(List<T> list) {
        super(list);
    }
    private ParceledListSlice(Parcel in, ClassLoader loader) {
        super(in, loader);
    }
    public static <T extends Parcelable> ParceledListSlice<T> emptyList() {
        return new ParceledListSlice<T>(Collections.<T>emptyList());
    }
    @Override
    public int describeContents() {
        int contents = 0;
        final List<T> list = getList();
        for (int i = 0; i < list.size(); i++) {
            contents |= list.get(i).describeContents();
        }
        return contents;
    }
    @Override
    protected void writeElement(T parcelable, Parcel dest, int callFlags) {
        parcelable.writeToParcel(dest, callFlags);
    }
    @Override
    protected void writeParcelableCreator(T parcelable, Parcel dest) {
        String name = parcelable.getClass().getName();
        dest.writeString(name);
    }
    @Override
    protected Creator<?> readParcelableCreator(Parcel from, ClassLoader loader) {
        String name = from.readString();
        if (name == null) {
            return null;
        }
        Creator<?> creator;
        synchronized (CREATORS) {
            HashMap<String, Creator<?>> map = CREATORS.get(loader);
            if (map == null) {
                map = new HashMap<>();
                CREATORS.put(loader, map);
            }
            creator = map.get(name);
            if (creator == null) {
                try {
                    ClassLoader parcelableClassLoader =
                            (loader == null ? getClass().getClassLoader() : loader);
                    Class<?> parcelableClass = Class.forName(name, false ,
                            parcelableClassLoader);
                    if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
                        throw new BadParcelableException("Parcelable protocol requires subclassing "
                                + "from Parcelable on class " + name);
                    }
                    Field f = parcelableClass.getField("CREATOR");
                    if ((f.getModifiers() & Modifier.STATIC) == 0) {
                        throw new BadParcelableException("Parcelable protocol requires "
                                + "the CREATOR object to be static on class " + name);
                    }
                    Class<?> creatorType = f.getType();
                    if (!Creator.class.isAssignableFrom(creatorType)) {
                        throw new BadParcelableException("Parcelable protocol requires a "
                                + "Parcelable.Creator object called "
                                + "CREATOR on class " + name);
                    }
                    creator = (Creator<?>) f.get(null);
                } catch (IllegalAccessException e) {
                    Log.e(TAG, "Illegal access when unmarshalling: " + name, e);
                    throw new BadParcelableException(
                            "IllegalAccessException when unmarshalling: " + name);
                } catch (ClassNotFoundException e) {
                    Log.e(TAG, "Class not found when unmarshalling: " + name, e);
                    throw new BadParcelableException(
                            "ClassNotFoundException when unmarshalling: " + name);
                } catch (NoSuchFieldException e) {
                    throw new BadParcelableException("Parcelable protocol requires a "
                            + "Parcelable.Creator object called "
                            + "CREATOR on class " + name);
                }
                if (creator == null) {
                    throw new BadParcelableException("Parcelable protocol requires a "
                            + "non-null Parcelable.Creator object called "
                            + "CREATOR on class " + name);
                }
                map.put(name, creator);
            }
        }
        return creator;
    }
    public static final ClassLoaderCreator<ParceledListSlice> CREATOR =
            new ClassLoaderCreator<ParceledListSlice>() {
                public ParceledListSlice createFromParcel(Parcel in) {
                    return new ParceledListSlice(in, null);
                }
                @Override
                public ParceledListSlice createFromParcel(Parcel in, ClassLoader loader) {
                    return new ParceledListSlice(in, loader);
                }
                @Override
                public ParceledListSlice[] newArray(int size) {
                    return new ParceledListSlice[size];
                }
            };
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/model/Template.kt
================================================
```
package me.gm.cleaner.plugin.model
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import me.gm.cleaner.plugin.xposed.hooker.InsertHooker
import me.gm.cleaner.plugin.xposed.hooker.QueryHooker
import me.gm.cleaner.plugin.xposed.util.FileUtils
import me.gm.cleaner.plugin.xposed.util.MimeUtils
data class Template(
    @field:SerializedName("template_name") val templateName: String,
    @field:SerializedName("hook_operation") val hookOperation: List<String>,
    @field:SerializedName("apply_to_app") val applyToApp: List<String>?,
    @field:SerializedName("permitted_media_types") val permittedMediaTypes: List<Int>?,
    @field:SerializedName("filter_path") val filterPath: List<String>?,
    @field:SerializedName("redirect_path") val redirectPath: String? = null,
)
class Templates(json: String?) {
    private val _values = mutableListOf<Template>()
    val values: List<Template>
        get() = _values
    private lateinit var matchingTemplates: List<Template>
    init {
        if (!json.isNullOrEmpty()) {
            _values.addAll(
                Gson().fromJson(json, Array<Template>::class.java)
            )
        }
    }
    fun filterTemplate(cls: Class<*>, packageName: String): Templates {
        matchingTemplates = _values.filter { template ->
            when (cls) {
                QueryHooker::class.java -> template.hookOperation.contains("query")
                InsertHooker::class.java -> template.hookOperation.contains("insert")
                else -> throw IllegalArgumentException()
            } && template.applyToApp?.contains(packageName) == true
        }
        return this
    }
    fun applyTemplates(dataList: List<String>, mimeTypeList: List<String>): List<Boolean> =
        dataList.zip(mimeTypeList).map { (data, mimeType) ->
            (if (::matchingTemplates.isInitialized) matchingTemplates else _values)
                .any { template ->
                    MimeUtils.resolveMediaType(mimeType) !in
                            (template.permittedMediaTypes ?: emptyList()) ||
                            template.filterPath?.any { FileUtils.contains(it, data) } == true
                }
        }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/DrawerActivity.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer
import android.annotation.SuppressLint
import android.content.Intent
import android.os.Bundle
import android.widget.TextView
import androidx.activity.viewModels
import androidx.core.os.bundleOf
import androidx.drawerlayout.widget.DrawerLayout
import androidx.navigation.NavController
import androidx.navigation.findNavController
import androidx.navigation.ui.AppBarConfiguration
import androidx.navigation.ui.navigateUp
import androidx.navigation.ui.setupActionBarWithNavController
import androidx.navigation.ui.setupWithNavController
import com.google.android.material.internal.NavigationMenuPresenter
import com.google.android.material.internal.NavigationMenuView
import com.google.android.material.navigation.NavigationView
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseActivity
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.DrawerActivityBinding
import me.gm.cleaner.plugin.ktx.getObjectField
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.mediastore.ToolbarActionModeIndicator
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import rikka.recyclerview.fixEdgeEffect
abstract class DrawerActivity : BaseActivity() {
    private val viewModel: BinderViewModel by viewModels()
    private lateinit var drawerLayout: DrawerLayout
    private lateinit var navController: NavController
    private val appBarConfiguration by lazy {
        AppBarConfiguration(topLevelDestinationIds, drawerLayout)
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val binding = DrawerActivityBinding.inflate(layoutInflater)
        setContentView(binding.root)
        navController = findNavController(R.id.nav_host)
        val action = intent.action
        val shouldAlterStartDestination = savedInstanceState == null &&
                (action != Intent.ACTION_MAIN ||
                        RootPreferences.startDestination in topLevelDestinationIds)
        if (shouldAlterStartDestination) {
            when (action) {
                "me.gm.cleaner.plugin.intent.action.AUDIO" ->
                    RootPreferences.startDestination = R.id.audio_fragment
                "me.gm.cleaner.plugin.intent.action.FILES" ->
                    RootPreferences.startDestination = R.id.files_fragment
                "me.gm.cleaner.plugin.intent.action.IMAGES" ->
                    RootPreferences.startDestination = R.id.images_fragment
                "me.gm.cleaner.plugin.intent.action.VIDEO" ->
                    RootPreferences.startDestination = R.id.video_fragment
            }
            val navGraph = navController.navInflater.inflate(R.navigation.nav_graph).apply {
                val startDestId = if (action == Intent.ACTION_VIEW) {
                    when {
                        MimeUtils.isAudioMimeType(intent.type) -> R.id.audio_fragment
                        MimeUtils.isImageMimeType(intent.type) -> R.id.image_pager_fragment
                        MimeUtils.isVideoMimeType(intent.type) -> R.id.video_player_fragment
                        else -> throw IllegalArgumentException(intent.type)
                    }
                } else {
                    RootPreferences.startDestination
                }
                setStartDestination(startDestId)
            }
            val args = if (action == Intent.ACTION_VIEW) {
                bundleOf(
                    "uri" to intent.data,
                    "uris" to arrayOf(intent.data),
                )
            } else {
                null
            }
            navController.setGraph(navGraph, args)
        }
        navController.addOnDestinationChangedListener { _, destination, _ ->
            if (destination.id in topLevelDestinationIds) {
                RootPreferences.startDestination = destination.id
                supportFragmentManager.findFragmentById(R.id.nav_host)
                    ?.childFragmentManager?.fragments?.forEach {
                        if (it.exitTransition is Hold) {
                            it.exitTransition = null
                        }
                    }
            }
        }
        drawerLayout = binding.drawerLayout
        setupActionBarWithNavController(navController, appBarConfiguration)
        val navView = binding.navView
        navView.setupWithNavController(navController)
        customizeNavViewStyle(navView)
        if (shouldAlterStartDestination) {
            navView.setCheckedItem(RootPreferences.startDestination)
        }
        navView.getHeaderView(0).findViewById<TextView>(R.id.status).setText(
            when {
                !viewModel.pingBinder() -> R.string.not_active
                viewModel.moduleVersion != BuildConfig.VERSION_CODE -> R.string.restart_system
                else -> R.string.active
            }
        )
    }
    @SuppressLint("RestrictedApi")
    private fun customizeNavViewStyle(navView: NavigationView) {
        val presenter = navView.getObjectField<NavigationMenuPresenter>()
        val menuView = presenter.getMenuView(navView) as NavigationMenuView
        menuView.fixEdgeEffect(false)
        menuView.overScrollIfContentScrollsPersistent()
    }
    override fun onBackPressed() {
        when {
            drawerLayout.isOpen -> drawerLayout.close()
            navController.currentDestination?.id in topLevelDestinationIds &&
                    supportFragmentManager.findFragmentById(R.id.nav_host)
                        ?.childFragmentManager?.fragments?.first()?.let {
                            it !is ToolbarActionModeIndicator || !it.isInActionMode()
                        } == true -> super.onSupportNavigateUp()
            else -> super.onBackPressed()
        }
    }
    override fun onSupportNavigateUp() =
        navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()
    companion object {
        val topLevelDestinationIds = setOf(
            R.id.applist_fragment,
            R.id.usage_record_fragment,
            R.id.settings_fragment,
            R.id.audio_fragment,
            R.id.downloads_fragment,
            R.id.files_fragment,
            R.id.images_fragment,
            R.id.video_fragment,
            R.id.playground_fragment,
            R.id.about_fragment,
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/about/AboutFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.about
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import dagger.hilt.android.AndroidEntryPoint
import io.noties.markwon.Markwon
import io.noties.markwon.ext.strikethrough.StrikethroughPlugin
import io.noties.markwon.html.HtmlPlugin
import io.noties.markwon.image.ImagesPlugin
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.AboutFragmentBinding
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import java.lang.ref.WeakReference
@AndroidEntryPoint
class AboutFragment : BaseFragment() {
    private val viewModel: AboutViewModel by viewModels()
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = AboutFragmentBinding.inflate(layoutInflater)
        liftOnScrollTargetView = WeakReference(binding.listContainer)
        binding.listContainer.fitsSystemWindowInsets()
        lifecycleScope.launch {
            val rawReadme = viewModel.getRawReadmeAsync().await()
            binding.progress.hide()
            val md = rawReadme.getOrElse {
                binding.content.text = it.stackTraceToString()
                return@launch
            }
            val markwon = Markwon.builder(requireContext())
                .usePlugin(StrikethroughPlugin.create())
                .usePlugin(HtmlPlugin.create())
                .usePlugin(ImagesPlugin.create())
                .build()
            markwon.setMarkdown(binding.content, md)
        }
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/about/AboutViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.about
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.data.github.ReadmeRepository
import java.util.Locale
import javax.inject.Inject
@HiltViewModel
class AboutViewModel @Inject constructor(private val repository: ReadmeRepository) : ViewModel() {
    private var rawReadme: Result<String> = Result.failure(UninitializedPropertyAccessException())
    fun getRawReadmeAsync() = viewModelScope.async {
        if (rawReadme.isFailure) {
            withContext(Dispatchers.IO) {
                rawReadme = repository.getRawReadme(Locale.getDefault().toLanguageTag())
            }
        }
        rawReadme
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.playground
import android.annotation.SuppressLint
import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.FrameLayout
import androidx.coordinatorlayout.widget.CoordinatorLayout
import androidx.lifecycle.viewModelScope
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.behavior.SwipeDismissBehavior
import com.google.android.material.divider.MaterialDivider
import kotlinx.coroutines.CoroutineStart
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.async
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.ConfirmationDialog
import me.gm.cleaner.plugin.databinding.PlaygroundCardActionBinding
import me.gm.cleaner.plugin.databinding.PlaygroundCardHeaderBinding
import me.gm.cleaner.plugin.databinding.PlaygroundCardSubheaderBinding
import me.gm.cleaner.plugin.ktx.hasWifiTransport
@SuppressLint("PrivateResource")
class PlaygroundAdapter(
    private val fragment: PlaygroundFragment, private val viewModel: PlaygroundViewModel
) : ListAdapter<PlaygroundContentItem, RecyclerView.ViewHolder>(CALLBACK) {
    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is PlaygroundContentSeparatorItem -> com.google.android.material.R.layout.design_navigation_item_separator
        is PlaygroundContentHeaderItem -> R.layout.playground_card_header
        is PlaygroundContentSubHeaderItem -> R.layout.playground_card_subheader
        is PlaygroundContentActionItem -> R.layout.playground_card_action
        else -> throw IndexOutOfBoundsException()
    }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder =
        when (viewType) {
            com.google.android.material.R.layout.design_navigation_item_separator ->
                SeparatorViewHolder(parent.context)
            R.layout.playground_card_header -> HeaderCardViewHolder(
                PlaygroundCardHeaderBinding.inflate(LayoutInflater.from(parent.context))
            )
            R.layout.playground_card_subheader -> SubHeaderCardViewHolder(
                PlaygroundCardSubheaderBinding.inflate(LayoutInflater.from(parent.context))
            )
            R.layout.playground_card_action -> ActionCardViewHolder(
                PlaygroundCardActionBinding.inflate(LayoutInflater.from(parent.context))
            )
            else -> throw IndexOutOfBoundsException()
        }
    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is HeaderCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentHeaderItem
                binding.title.text = item.title
            }
            is SubHeaderCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentSubHeaderItem
                binding.cardContextText.text = item.content
                val card = binding.card
                val swipeDismissBehavior = SwipeDismissBehavior<View>().apply {
                    setSwipeDirection(SwipeDismissBehavior.SWIPE_DIRECTION_ANY)
                    setListener(object : SwipeDismissBehavior.OnDismissListener {
                        override fun onDragStateChanged(state: Int) {
                            when (state) {
                                SwipeDismissBehavior.STATE_DRAGGING,
                                SwipeDismissBehavior.STATE_SETTLING -> card.isDragged = true
                                SwipeDismissBehavior.STATE_IDLE -> card.isDragged = false
                            }
                        }
                        override fun onDismiss(view: View) {
                            viewModel.dismissedCards.add(item.id)
                            viewModel.prepareContentItems(fragment, this@PlaygroundAdapter)
                        }
                    })
                }
                val coordinatorParams = card.layoutParams as CoordinatorLayout.LayoutParams
                coordinatorParams.behavior = swipeDismissBehavior
            }
            is ActionCardViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as PlaygroundContentActionItem
                binding.title.text = item.title
                binding.summary.text = item.summary
                val button = binding.button
                button.addOnCheckedChangeListener { _, isChecked ->
                    button.setText(
                        if (isChecked) android.R.string.cancel
                        else R.string.start
                    )
                }
                val deferred = viewModel.actions[item.id]
                button.isChecked = deferred != null && deferred.isActive
                button.setOnClickListener {
                    var deferred = viewModel.actions[item.id] as? Deferred<Unit>
                    if (deferred == null || !deferred.isActive) {
                        deferred = viewModel.viewModelScope
                            .async(Dispatchers.Main.immediate, CoroutineStart.LAZY) {
                                item.action!!()
                            }
                        viewModel.actions.put(item.id, deferred)
                        if (item.needsNetwork && !fragment.requireContext().hasWifiTransport) {
                            ConfirmationDialog
                                .newInstance(fragment.getString(R.string.no_wifi))
                                .apply {
                                    addOnPositiveButtonClickListener {
                                        startAction(deferred)
                                    }
                                }
                                .show(fragment.childFragmentManager, null)
                        } else {
                            startAction(deferred)
                        }
                    } else {
                        deferred.cancel()
                    }
                }
            }
        }
    }
    private fun startAction(deferred: Deferred<Unit>): Job = viewModel.viewModelScope.launch {
        deferred.await()
    }
    override fun getItemId(position: Int): Long = getItem(position).id.toLong()
    class SeparatorViewHolder(context: Context) :
        RecyclerView.ViewHolder(FrameLayout(context).apply {
            val cardMargin = context.resources.getDimensionPixelSize(R.dimen.card_margin)
            addView(MaterialDivider(context).apply {
                dividerInsetStart = cardMargin
                dividerInsetEnd = cardMargin
            })
            setPaddingRelative(0, cardMargin, 0, 0)
        })
    class HeaderCardViewHolder(val binding: PlaygroundCardHeaderBinding) :
        RecyclerView.ViewHolder(binding.root)
    class SubHeaderCardViewHolder(val binding: PlaygroundCardSubheaderBinding) :
        RecyclerView.ViewHolder(binding.root)
    class ActionCardViewHolder(val binding: PlaygroundCardActionBinding) :
        RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<PlaygroundContentItem>() {
            override fun areItemsTheSame(
                oldItem: PlaygroundContentItem, newItem: PlaygroundContentItem
            ): Boolean = oldItem.id == newItem.id
            @SuppressLint("DiffUtilEquals")
            override fun areContentsTheSame(
                oldItem: PlaygroundContentItem, newItem: PlaygroundContentItem
            ): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundContentItem.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.playground
import android.annotation.SuppressLint
import android.view.View
import androidx.appcompat.view.menu.MenuBuilder
import kotlinx.coroutines.CoroutineScope
abstract class PlaygroundContentItem(
    open val id: Int
)
data class PlaygroundContentSeparatorItem(
    override val id: Int = View.generateViewId()
) : PlaygroundContentItem(id)
data class PlaygroundContentHeaderItem(
    override val id: Int,
    var title: CharSequence?
) : PlaygroundContentItem(id)
data class PlaygroundContentSubHeaderItem(
    override val id: Int,
    var content: CharSequence?,
    var dismissed: Boolean
) : PlaygroundContentItem(id)
data class PlaygroundContentActionItem(
    override val id: Int,
    var title: CharSequence?,
    var summary: CharSequence?,
    var action: (suspend CoroutineScope.() -> Unit)? = null,
    var needsNetwork: Boolean
) : PlaygroundContentItem(id)
object PlaygroundContentItems {
    fun forMenuBuilder(menu: MenuBuilder): MutableList<PlaygroundContentItem> {
        val items = mutableListOf<PlaygroundContentItem>()
        convertTo(items, menu)
        return items
    }
    @SuppressLint("RestrictedApi")
    private fun convertTo(items: MutableList<PlaygroundContentItem>, menu: MenuBuilder) {
        menu.visibleItems.forEach { menuItemImpl ->
            when {
                menuItemImpl.hasSubMenu() -> {
                    if (items.isNotEmpty()) {
                        items.add(PlaygroundContentSeparatorItem())
                    }
                    items.add(PlaygroundContentHeaderItem(menuItemImpl.itemId, menuItemImpl.title))
                    convertTo(items, menuItemImpl.subMenu as MenuBuilder)
                }
                menuItemImpl.isCheckable -> items.add(
                    PlaygroundContentSubHeaderItem(
                        menuItemImpl.itemId, menuItemImpl.title, menuItemImpl.isChecked
                    )
                )
                else -> items.add(
                    PlaygroundContentActionItem(
                        menuItemImpl.itemId,
                        menuItemImpl.title,
                        menuItemImpl.titleCondensed,
                        needsNetwork = menuItemImpl.isChecked
                    )
                )
            }
        }
    }
    inline fun <reified T : PlaygroundContentItem> Collection<PlaygroundContentItem>.findItemById(id: Int) =
        first { id == it.id } as T
    fun Collection<PlaygroundContentItem>.findIndexById(id: Int) = indexOfFirst { id == it.id }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.playground
import android.graphics.Rect
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.util.keyIterator
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import dagger.hilt.android.AndroidEntryPoint
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.PlaygroundFragmentBinding
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findIndexById
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
@AndroidEntryPoint
class PlaygroundFragment : BaseFragment() {
    private val viewModel: PlaygroundViewModel by viewModels()
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = PlaygroundFragmentBinding.inflate(layoutInflater)
        val adapter = PlaygroundAdapter(this, viewModel).apply {
            setHasStableIds(true)
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        list.addItemDecoration(object : RecyclerView.ItemDecoration() {
            private var dividerHeight = resources.getDimensionPixelSize(R.dimen.card_margin)
            override fun getItemOffsets(
                outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State
            ) {
                outRect.bottom = dividerHeight
            }
        })
        viewModel.prepareContentItems(this, adapter)
        viewModel.unsplashPhotosLiveData.observe(viewLifecycleOwner) {
            val changedItemIds = mutableListOf<Int>()
            viewModel.actions.keyIterator().forEach { id ->
                if (!viewModel.actions[id].isActive) {
                    changedItemIds.add(id)
                    val position = adapter.currentList.findIndexById(id)
                    adapter.notifyItemChanged(position)
                }
            }
            changedItemIds.forEach { id ->
                viewModel.actions.remove(id)
            }
        }
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/drawer/playground/PlaygroundViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.drawer.playground
import android.annotation.SuppressLint
import android.app.DownloadManager
import android.content.ContentValues
import android.content.Context
import android.os.Environment
import android.os.FileUtils
import android.provider.MediaStore
import android.util.SparseArray
import android.widget.Toast
import androidx.appcompat.view.menu.MenuBuilder
import androidx.core.net.toUri
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.navigation.fragment.findNavController
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ensureActive
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.data.unsplash.UnsplashPhoto
import me.gm.cleaner.plugin.data.unsplash.UnsplashRepository
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findIndexById
import me.gm.cleaner.plugin.ui.drawer.playground.PlaygroundContentItems.findItemById
import java.io.File
import java.net.URL
import javax.inject.Inject
@HiltViewModel
class PlaygroundViewModel @Inject constructor(private val repository: UnsplashRepository) :
    ViewModel() {
    val dismissedCards = mutableListOf<Int>()
    @SuppressLint("RestrictedApi")
    fun prepareContentItems(fragment: PlaygroundFragment, adapter: PlaygroundAdapter) {
        val activity = fragment.requireActivity()
        val menu = MenuBuilder(activity)
        activity.menuInflater.inflate(R.menu.playground_content, menu)
        val items = PlaygroundContentItems.forMenuBuilder(menu)
        dismissedCards.asSequence()
            .map { id -> items.findIndexById(id) }
            .sortedDescending()
            .forEach { indexOfSubHeader ->
                if (indexOfSubHeader + 1 <= items.size &&
                    items[indexOfSubHeader + 1] is PlaygroundContentSeparatorItem
                ) {
                    items.removeAt(indexOfSubHeader + 1)
                }
                items.removeAt(indexOfSubHeader)
            }
        items.findItemById<PlaygroundContentActionItem>(R.id.unsplash_download_manager).action =
            unsplashDownloadManager(activity)
        items.findItemById<PlaygroundContentActionItem>(R.id.unsplash_insert).action =
            unsplashInsert(activity)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_insert).action =
            interceptInsert(fragment)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_download_manager).action =
            interceptDownloadManager(fragment)
        items.findItemById<PlaygroundContentActionItem>(R.id.intercept_query).action =
            interceptQuery(fragment)
        adapter.submitList(items)
    }
    val actions = SparseArray<Deferred<*>>()
    private val _unsplashPhotosLiveData: MutableLiveData<Result<List<UnsplashPhoto>>> =
        MutableLiveData(Result.failure(UninitializedPropertyAccessException()))
    val unsplashPhotosLiveData: LiveData<Result<List<UnsplashPhoto>>> = _unsplashPhotosLiveData
    private var unsplashPhotos: Result<List<UnsplashPhoto>>
        get() = _unsplashPhotosLiveData.value!!
        set(value) {
            _unsplashPhotosLiveData.postValue(value)
        }
    private var width = 0
    private lateinit var downloadManager: DownloadManager
    private fun unsplashDownloadManager(context: Context): suspend CoroutineScope.() -> Unit {
        if (!::downloadManager.isInitialized) {
            width = context.resources.displayMetrics.widthPixels
            downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
        }
        return {
            val unsplashPhotoListResult = withContext(Dispatchers.IO) {
                if (unsplashPhotos.isSuccess) unsplashPhotos
                else repository.fetchUnsplashPhotoList()
            }
            unsplashPhotoListResult.onSuccess { unsplashPhotos ->
                withContext(Dispatchers.IO) {
                    repeat(10) {
                        ensureActive()
                        val unsplashPhoto = unsplashPhotos.random()
                        val request = DownloadManager
                            .Request(unsplashPhoto.getPhotoUrl(width).toUri())
                            .setDestinationInExternalPublicDir(
                                Environment.DIRECTORY_PICTURES,
                                File.separator + "MPM" + File.separator + unsplashPhoto.filename
                            )
                        val id = downloadManager.enqueue(request)
                    }
                }
            }.onFailure { e ->
                e.printStackTrace()
                Toast.makeText(context, e.message, Toast.LENGTH_LONG).show()
            }
            unsplashPhotos = unsplashPhotoListResult
        }
    }
    private fun unsplashInsert(context: Context): suspend CoroutineScope.() -> Unit {
        if (!::downloadManager.isInitialized) {
            width = context.resources.displayMetrics.widthPixels
        }
        return {
            val unsplashPhotoListResult = withContext(Dispatchers.IO) {
                if (unsplashPhotos.isSuccess) unsplashPhotos
                else repository.fetchUnsplashPhotoList()
            }
            unsplashPhotoListResult.onSuccess { unsplashPhotos ->
                withContext(Dispatchers.IO) {
                    val resolver = context.contentResolver
                    repeat(10) {
                        ensureActive()
                        val unsplashPhoto = unsplashPhotos.random()
                        val imageDetails = ContentValues().apply {
                            put(
                                MediaStore.MediaColumns.RELATIVE_PATH,
                                Environment.DIRECTORY_PICTURES + File.separator + "MPM"
                            )
                            put(MediaStore.MediaColumns.DISPLAY_NAME, unsplashPhoto.filename)
                            put(
                                MediaStore.MediaColumns.MIME_TYPE,
                                "image/${unsplashPhoto.filename.substringAfterLast('.')}"
                            )
                            put(MediaStore.Audio.Media.IS_PENDING, 1)
                        }
                        val imageUri = resolver.insert(
                            MediaStore.Images.Media.EXTERNAL_CONTENT_URI, imageDetails
                        ) ?: return@repeat
                        runCatching {
                            val `is` = URL(unsplashPhoto.getPhotoUrl(width)).openStream()
                            val os = resolver.openOutputStream(imageUri, "w") ?: return@runCatching
                            FileUtils.copy(`is`, os)
                        }
                        imageDetails.clear()
                        imageDetails.put(MediaStore.Audio.Media.IS_PENDING, 0)
                        resolver.update(imageUri, imageDetails, null, null)
                    }
                }
            }.onFailure { e ->
                e.printStackTrace()
                Toast.makeText(context, e.message, Toast.LENGTH_LONG).show()
            }
            unsplashPhotos = unsplashPhotoListResult
        }
    }
    private fun interceptInsert(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_insert_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_query),
                packageNames = arrayOf(BuildConfig.APPLICATION_ID),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }
    private fun interceptDownloadManager(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_download_manager_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_query),
                packageNames = fragment.resources.getStringArray(R.array.recommend_package),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }
    private fun interceptQuery(fragment: PlaygroundFragment): suspend CoroutineScope.() -> Unit {
        return {
            val direction = PlaygroundFragmentDirections.actionPlaygroundToCreateTemplate(
                templateName = fragment.getString(R.string.intercept_query_title),
                hookOperation = fragment.resources.getStringArray(R.array.hook_operation_entryValues) -
                        fragment.getString(R.string.hook_operation_insert),
                packageNames = arrayOf(BuildConfig.APPLICATION_ID),
                permittedMediaTypes = fragment.resources.getStringArray(R.array.media_types_entryValues) -
                        fragment.getString(R.string.media_type_image),
            )
            fragment.findNavController().navigate(direction)
        }
    }
}
private inline operator fun <reified T> Array<T>.minus(string: T): Array<T> {
    return (toMutableSet() - string).toTypedArray()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaModelLoader.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore;
import android.content.Context;
import android.media.MediaMetadataRetriever;
import android.net.Uri;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.bumptech.glide.Priority;
import com.bumptech.glide.load.DataSource;
import com.bumptech.glide.load.Options;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.model.ModelLoaderFactory;
import com.bumptech.glide.load.model.MultiModelLoaderFactory;
import com.bumptech.glide.signature.ObjectKey;
import java.nio.ByteBuffer;
public class MediaModelLoader implements ModelLoader<Uri, ByteBuffer> {
    private final Context mContext;
    MediaModelLoader(Context context) {
        mContext = context;
    }
    @Override
    public boolean handles(@NonNull Uri uri) {
        return true;
    }
    @Nullable
    @Override
    public LoadData<ByteBuffer> buildLoadData(@NonNull Uri uri, int width, int height,
                                              @NonNull Options options) {
        return new LoadData<>(new ObjectKey(uri), new MediaMetadataFetcher(uri));
    }
    class MediaMetadataFetcher implements DataFetcher<ByteBuffer> {
        private final Uri mUri;
        private MediaMetadataFetcher(Uri uri) {
            mUri = uri;
        }
        @Override
        public void loadData(@NonNull Priority priority,
                             @NonNull DataCallback<? super ByteBuffer> callback) {
            try (var retriever = new MediaMetadataRetriever()) {
                retriever.setDataSource(mContext, mUri);
                var data = retriever.getEmbeddedPicture();
                var byteBuffer = ByteBuffer.wrap(data);
                callback.onDataReady(byteBuffer);
            } catch (Exception e) {
                callback.onLoadFailed(e);
            }
        }
        @Override
        public void cleanup() {
        }
        @Override
        public void cancel() {
        }
        @NonNull
        @Override
        public Class<ByteBuffer> getDataClass() {
            return ByteBuffer.class;
        }
        @NonNull
        @Override
        public DataSource getDataSource() {
            return DataSource.LOCAL;
        }
    }
    public static class Factory implements ModelLoaderFactory<Uri, ByteBuffer> {
        @NonNull
        private final Context mContext;
        public Factory(@NonNull Context context) {
            mContext = context.getApplicationContext();
        }
        @NonNull
        @Override
        public ModelLoader<Uri, ByteBuffer> build(@NonNull MultiModelLoaderFactory multiFactory) {
            return new MediaModelLoader(mContext);
        }
        @Override
        public void teardown() {
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.net.Uri
import android.text.format.DateUtils
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import androidx.annotation.CallSuper
import androidx.fragment.app.Fragment
import androidx.recyclerview.selection.ItemDetailsLookup
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import androidx.recyclerview.selection.SelectionTracker
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.databinding.MediaStoreHeaderBinding
import java.util.Calendar
abstract class MediaStoreAdapter(private val fragment: Fragment) :
    ListAdapter<MediaStoreModel, MediaStoreAdapter.ViewHolder>(
        MediaStoreModel.createCallback<MediaStoreModel>()
    ) {
    lateinit var selectionTracker: SelectionTracker<Long>
    protected val selectionTrackerInitialized: Boolean
        get() = ::selectionTracker.isInitialized
    @CallSuper
    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreHeader -> R.layout.media_store_header
        else -> throw IndexOutOfBoundsException()
    }
    @CallSuper
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.media_store_header -> HeaderViewHolder(
                MediaStoreHeaderBinding.inflate(LayoutInflater.from(parent.context), parent, false)
            )
            else -> throw IndexOutOfBoundsException()
        }
    @CallSuper
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is HeaderViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreHeader
                binding.title.text = item.title
            }
        }
    }
    override fun getItemId(position: Int): Long = getItem(position).id
    protected val then: Calendar = Calendar.getInstance()
    protected val now: Calendar = Calendar.getInstance()
    protected open fun formatDateTime(timeMillis: Long): String {
        fun onTheSameDay(): Boolean = then[Calendar.YEAR] == now[Calendar.YEAR] &&
                then[Calendar.DAY_OF_YEAR] == now[Calendar.DAY_OF_YEAR]
        then.timeInMillis = timeMillis
        now.timeInMillis = System.currentTimeMillis()
        return when {
            onTheSameDay() -> {
                fragment.getString(R.string.today)
            }
            run {
                now.add(Calendar.DATE, -1)
                onTheSameDay()
            } -> {
                fragment.getString(R.string.yesterday)
            }
            else -> {
                val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                        DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_DATE
                DateUtils.formatDateTime(fragment.requireContext(), timeMillis, flags)
            }
        }
    }
    private val uriPositionMap: MutableList<Int> = mutableListOf()
    fun getHolderPositionForUriPosition(position: Int): Int? = uriPositionMap.getOrNull(position)
    protected fun getUriPositionForAdapterPosition(position: Int): Int =
        uriPositionMap.binarySearch(position)
    protected open fun onPreSubmitList(list: List<MediaStoreModel>): List<MediaStoreModel> {
        uriPositionMap.clear()
        return when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH -> {
                val groupedList = mutableListOf<MediaStoreModel>()
                var lastHeader = ""
                list.forEach { model ->
                    val header = model.relativePath
                    if (lastHeader != header) {
                        lastHeader = header
                        groupedList += MediaStoreHeader(header)
                    }
                    uriPositionMap += groupedList.size
                    groupedList += model
                }
                groupedList
            }
            SORT_BY_DATE_TAKEN -> {
                val groupedList = mutableListOf<MediaStoreModel>()
                var lastHeader = ""
                list.forEach { model ->
                    val header = formatDateTime(model.dateTaken)
                    if (lastHeader != header) {
                        lastHeader = header
                        groupedList += MediaStoreHeader(header)
                    }
                    uriPositionMap += groupedList.size
                    groupedList += model
                }
                groupedList
            }
            else -> {
                repeat(list.size) { position ->
                    uriPositionMap += position
                }
                list
            }
        }
    }
    override fun submitList(list: List<MediaStoreModel>?) {
        submitList(list, null)
    }
    override fun submitList(list: List<MediaStoreModel>?, commitCallback: Runnable?) {
        if (list != null) {
            super.submitList(onPreSubmitList(list), commitCallback)
        } else {
            super.submitList(list, commitCallback)
        }
    }
    abstract class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        var details: ItemDetails<Long>? = null
    }
    class HeaderViewHolder(val binding: MediaStoreHeaderBinding) : ViewHolder(binding.root)
}
class DetailsLookup(private val list: RecyclerView) : ItemDetailsLookup<Long>() {
    override fun getItemDetails(e: MotionEvent): ItemDetails<Long>? {
        val view = list.findChildViewUnder(e.x, e.y)
        if (view != null) {
            val viewHolder = list.getChildViewHolder(view)
            if (viewHolder is MediaStoreAdapter.ViewHolder) {
                return viewHolder.details
            }
        }
        return null
    }
}
class MediaStoreHeader(val title: String) :
    MediaStoreModel(title.hashCode().toLong(), Uri.EMPTY, "", "", "", -1L) {
    override fun hashCode(): Int = title.hashCode()
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as MediaStoreHeader
        if (title != other.title) return false
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.app.Activity
import android.content.ActivityNotFoundException
import android.content.Intent
import android.media.MediaScannerConnection
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.view.ActionMode
import androidx.core.view.children
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.selection.SelectionTracker
import androidx.recyclerview.selection.SelectionTracker.SelectionPredicate
import androidx.recyclerview.selection.StorageStrategy
import androidx.recyclerview.widget.RecyclerView
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.app.ConfirmationDialog
import me.gm.cleaner.plugin.app.InfoDialog
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.submitListKeepPosition
import me.gm.cleaner.plugin.ui.mediastore.audio.AudioFragment
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment
import me.gm.cleaner.plugin.ui.mediastore.files.MediaStoreFiles
import me.gm.cleaner.plugin.ui.mediastore.images.ImagesFragment
import me.gm.cleaner.plugin.ui.mediastore.video.VideoFragment
import me.gm.cleaner.plugin.util.MediaStoreCompat
import me.gm.cleaner.plugin.util.MediaStoreCompat.DELETE_PERMISSION_REQUEST
import me.gm.cleaner.plugin.util.PermissionUtils
import me.gm.cleaner.plugin.util.RequesterFragment
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import me.zhanghai.android.fastscroll.ItemsHeightsObserver
import me.zhanghai.android.fastscroll.PreciseRecyclerViewHelper
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import java.util.function.Supplier
abstract class MediaStoreFragment : BaseFragment(), ToolbarActionModeIndicator {
    protected abstract val viewModel: MediaStoreViewModel<*>
    protected abstract val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment>
    protected lateinit var selectionTracker: SelectionTracker<Long>
    private var actionMode: ActionMode? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View? {
        val binding = MediaStoreFragmentBinding.inflate(inflater)
        val adapter = onCreateAdapter().apply {
            setHasStableIds(true)
            stateRestorationPolicy = RecyclerView.Adapter.StateRestorationPolicy.PREVENT_WHEN_EMPTY
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        selectionTracker = SelectionTracker
            .Builder(
                 javaClass.name,
                list,
                StableIdKeyProvider(adapter),
                DetailsLookup(list),
                StorageStrategy.createLongStorage()
            )
            .withSelectionPredicate(object : SelectionPredicate<Long>() {
                override fun canSetStateForKey(key: Long, nextState: Boolean): Boolean =
                    !nextState || viewModel.medias.any { it.id == key }
                override fun canSetStateAtPosition(position: Int, nextState: Boolean): Boolean {
                    if (position == RecyclerView.NO_POSITION) {
                        return false
                    }
                    val currentList = adapter.currentList
                    return currentList.isEmpty() || currentList[position] !is MediaStoreHeader
                }
                override fun canSelectMultiple(): Boolean = true
            })
            .build()
        selectionTracker.onRestoreInstanceState(savedInstanceState)
        selectionTracker.addObserver(object : SelectionTracker.SelectionObserver<Long>() {
            override fun onSelectionChanged() {
                if (selectionTracker.hasSelection()) {
                    startActionMode()
                } else {
                    actionMode?.finish()
                }
            }
        })
        adapter.selectionTracker = selectionTracker
        onBindView(binding, list, adapter)
        findNavController().addOnExitListener { _, destination, _ ->
            actionMode?.finish()
            supportActionBar?.title = destination.label
        }
        lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.mediasFlow.collect { medias ->
                    val mediaIds = medias.map { it.id }.toSet()
                    val deletedItems =
                        selectionTracker.selection.filterNot { mediaIds.contains(it) }
                    deletedItems.forEach { key ->
                        selectionTracker.deselect(key)
                    }
                    adapter.submitListKeepPosition(medias, list)
                }
            }
        }
        if (savedInstanceState == null) {
            PermissionUtils.requestPermissions(
                childFragmentManager, requesterFragmentClass.newInstance()
            )
        }
        return binding.root
    }
    abstract fun onCreateAdapter(): MediaStoreAdapter
    open fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
    }
    class MediaStoreRecyclerViewHelper(
        list: RecyclerView, currentListSupplier: Supplier<List<MediaStoreModel>>
    ) : PreciseRecyclerViewHelper(
        list, null, false, object : ItemsHeightsObserver(list, false) {
            private fun guessItemOffset(isHeader: Boolean): Int? {
                for (child in list.children) {
                    val vh = list.getChildViewHolder(child)
                    val position = vh.bindingAdapterPosition
                    if (isHeader && currentListSupplier.get()[position] is MediaStoreHeader ||
                        !isHeader && currentListSupplier.get()[position] !is MediaStoreHeader
                    ) {
                        return child.measuredHeight
                    }
                }
                return null
            }
            override fun guessItemOffsetAt(position: Int): Int? = try {
                if (currentListSupplier.get()[position] is MediaStoreHeader) {
                    guessItemOffset(true)
                } else {
                    guessItemOffset(false)
                }
            } catch (e: IndexOutOfBoundsException) {
                super.guessItemOffsetAt(position)
            }
        }
    )
    fun startActionMode() {
        if (!isInActionMode()) {
            val activity = requireActivity() as AppCompatActivity
            actionMode = activity.startToolbarActionMode(object : ActionMode.Callback {
                override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
                    mode.menuInflater.inflate(R.menu.mediastore_actionmode, menu)
                    return true
                }
                override fun onPrepareActionMode(mode: ActionMode, menu: Menu) = false
                override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
                    val medias = selectionTracker.selection.mapNotNull { selection ->
                        viewModel.medias.firstOrNull { it.id == selection }
                    }
                    if (medias.isEmpty()) {
                        return true
                    }
                    when (item.itemId) {
                        R.id.menu_share -> {
                            val mimeType = when (this@MediaStoreFragment) {
                                is AudioFragment -> "audio*"
                                }
                                else -> throw UnsupportedOperationException()
                            }
                            val sendIntent = if (medias.size == 1) {
                                Intent(Intent.ACTION_SEND)
                                    .setType(mimeType)
                                    .putExtra(Intent.EXTRA_STREAM, medias.first().contentUri)
                                    .putExtra(Intent.EXTRA_TEXT, medias.first().displayName)
                            } else {
                                val mediaUris = ArrayList<Uri>(medias.size)
                                medias.mapTo(mediaUris) { it.contentUri }
                                Intent(Intent.ACTION_SEND_MULTIPLE)
                                    .setType(mimeType)
                                    .putParcelableArrayListExtra(Intent.EXTRA_STREAM, mediaUris)
                            }
                            val shareIntent = Intent.createChooser(sendIntent, null)
                            try {
                                startActivity(shareIntent)
                            } catch (e: ActivityNotFoundException) {
                                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT)
                                    .show()
                            }
                        }
                        R.id.menu_delete -> deleteSelectedMedias(true)
                        else -> return false
                    }
                    return true
                }
                override fun onDestroyActionMode(mode: ActionMode) {
                    selectionTracker.clearSelection()
                    actionMode = null
                }
            })
        }
        actionMode?.title = selectionTracker.selection.size().toString()
    }
    private fun deleteSelectedMedias(allowBulkDelete: Boolean) {
        lifecycleScope.launch {
            val medias = selectionTracker.selection.mapNotNull { selection ->
                viewModel.medias.firstOrNull { it.id == selection }
            }
            when {
                medias.size == 1 -> MediaStoreCompat.delete(
                    this@MediaStoreFragment, medias.single().contentUri
                )
                Build.VERSION.SDK_INT <= Build.VERSION_CODES.Q -> InfoDialog
                    .newInstance(getString(R.string.unsupported_delete_in_bulk))
                    .show(childFragmentManager, null)
                else -> if (allowBulkDelete) {
                    MediaStoreCompat.delete(
                        this@MediaStoreFragment, medias.map { it.contentUri }
                    )
                }
            }
        }
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == DELETE_PERMISSION_REQUEST) {
            deleteSelectedMedias(false)
        }
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        if (::selectionTracker.isInitialized) {
            selectionTracker.onSaveInstanceState(outState)
        }
    }
    override fun isInActionMode(): Boolean = actionMode != null
    abstract class MediaPermissionsRequesterFragment : RequesterFragment() {
        private val parentFragment: MediaStoreFragment by lazy {
            requireParentFragment() as MediaStoreFragment
        }
        private val viewModel: MediaStoreViewModel<*> by lazy {
            parentFragment.viewModel
        }
        override fun onRequestPermissionsSuccess(permissions: Set<String>) {
            viewModel.load()
        }
        override fun onRequestPermissionsFailure(
            shouldShowRationale: Set<String>, denied: Set<String>
        ) {
            if (shouldShowRationale.isNotEmpty()) {
                ConfirmationDialog
                    .newInstance(getString(R.string.rationale_shouldShowRationale))
                    .apply {
                        addOnPositiveButtonClickListener {
                            onRequestPermissions(
                                shouldShowRationale.toTypedArray()
                            )
                        }
                    }
                    .show(childFragmentManager, null)
            }
        }
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        if (selectionTracker.hasSelection()) {
            startActionMode()
            return
        }
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.mediastore_toolbar, menu)
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean = when (item.itemId) {
        R.id.menu_refresh -> {
            viewModel.load()
            true
        }
        R.id.menu_scan_external_storage -> {
            MediaScannerConnection.scanFile(
                requireContext(), arrayOf(Environment.getExternalStorageDirectory().path),
                null, null
            )
            true
        }
        else -> super.onOptionsItemSelected(item)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.net.Uri
import androidx.recyclerview.widget.DiffUtil
abstract class MediaStoreModel(
    open val id: Long,
    open val contentUri: Uri,
    open val displayName: String,
    open val relativePath: String,
    open val data: String,
    open val dateTaken: Long,
) {
    companion object {
        fun <M : MediaStoreModel> createCallback() = object : DiffUtil.ItemCallback<M>() {
            override fun areItemsTheSame(oldItem: M, newItem: M): Boolean = oldItem.id == newItem.id
            override fun areContentsTheSame(oldItem: M, newItem: M): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/MediaStoreViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.annotation.SuppressLint
import android.app.Application
import android.database.ContentObserver
import android.net.Uri
import android.os.Handler
import android.os.Looper
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import java.text.SimpleDateFormat
import java.util.concurrent.TimeUnit
abstract class MediaStoreViewModel<M : MediaStoreModel>(application: Application) :
    AndroidViewModel(application) {
    protected val _mediasFlow: MutableStateFlow<List<M>> = MutableStateFlow(emptyList())
    val mediasFlow: StateFlow<List<M>> = _mediasFlow.asStateFlow()
    val medias: List<M>
        get() = _mediasFlow.value
    protected lateinit var uriToLoad: Uri
    fun load() {
        if (::uriToLoad.isInitialized) {
            viewModelScope.launch {
                _mediasFlow.value =
                    queryMedias(uriToLoad, RootPreferences.sortMediaByFlowable.value)
            }
        }
    }
    protected abstract suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<M>
    @Suppress("SameParameterValue")
    @SuppressLint("SimpleDateFormat")
    protected fun dateToTimestamp(day: Int, month: Int, year: Int): Long =
        SimpleDateFormat("dd.MM.yyyy").let { formatter ->
            TimeUnit.MICROSECONDS.toSeconds(formatter.parse("$day.$month.$year")?.time ?: 0)
        }
    protected var contentObserver: ContentObserver =
        object : ContentObserver(Handler(Looper.getMainLooper())) {
            override fun onChange(selfChange: Boolean) {
                load()
            }
        }
    override fun onCleared() {
        contentObserver.let { contentObserver ->
            getApplication<Application>().contentResolver.unregisterContentObserver(contentObserver)
        }
    }
    companion object {
        const val TAG = "MediaStoreVM"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/SelectionDetector.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.content.Context
import android.view.GestureDetector
import android.view.MotionEvent
class LongPressingListener : GestureDetector.SimpleOnGestureListener() {
    var isSelecting = false
    override fun onLongPress(e: MotionEvent) {
        isSelecting = true
    }
}
class SelectionDetector(context: Context, private val l: LongPressingListener) :
    GestureDetector(context, l) {
    val isSelecting: Boolean
        get() = l.isSelecting
    private val onUp = setOf(MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL)
    override fun onTouchEvent(ev: MotionEvent): Boolean {
        if (ev.action in onUp) {
            l.isSelecting = false
        }
        return super.onTouchEvent(ev)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/StableIdKeyProvider.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore;
import androidx.annotation.NonNull;
import androidx.recyclerview.selection.ItemKeyProvider;
import androidx.recyclerview.widget.RecyclerView;
public final class StableIdKeyProvider extends ItemKeyProvider<Long> {
    private static final String TAG = "StableIdKeyProvider";
    private final RecyclerView.Adapter<?> mAdapter;
    public StableIdKeyProvider(@NonNull RecyclerView.Adapter<?> adapter) {
        super(SCOPE_CACHED);
        mAdapter = adapter;
    }
    @NonNull
    @Override
    public Long getKey(int position) {
        return mAdapter.getItemId(position);
    }
    @Override
    public int getPosition(@NonNull Long key) {
        for (int i = 0, itemCount = mAdapter.getItemCount(); i < itemCount; i++) {
            if (key == mAdapter.getItemId(i)) {
                return i;
            }
        }
        return RecyclerView.NO_POSITION;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/ToolbarActionMode.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.animation.ObjectAnimator
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.view.Window
import android.view.accessibility.AccessibilityEvent
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.graphics.drawable.DrawerArrowDrawable
import androidx.appcompat.view.ActionMode
import androidx.appcompat.view.menu.MenuBuilder
import androidx.appcompat.widget.Toolbar
import me.gm.cleaner.plugin.R
@SuppressLint("RestrictedApi")
class ToolbarActionMode(private val activity: AppCompatActivity, private val toolbar: Toolbar) {
    private val menu: MenuBuilder
        get() = toolbar.menu as MenuBuilder
    private val arrowDrawable = DrawerArrowDrawable(activity)
    private var animator: ValueAnimator? = null
    private val originalToolbarTitle = toolbar.title to toolbar.subtitle
    private var actionMode: ToolbarActionModeImpl? = null
    private var cancellable: OnBackPressedCallback? = null
    fun startActionMode(callback: ActionMode.Callback): ActionMode? {
        actionMode?.finish()
        val mode = object : ToolbarActionModeImpl(toolbar, callback) {
            override fun finish() {
                super.finish()
                actionMode = null
                closeMode()
            }
        }
        initForMode(mode)
        if (mode.dispatchOnCreate()) {
            actionMode = mode
            mode.invalidate()
            animateToMode(true)
            toolbar.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
            return mode
        }
        closeMode()
        return null
    }
    private fun initForMode(mode: ToolbarActionModeImpl) {
        menu.close()
        menu.clear()
        toolbar.setNavigationOnClickListener {
            mode.finish()
        }
        toolbar.setOnMenuItemClickListener { item ->
            mode.onMenuItemSelected(menu, item)
        }
        val onBackPressedCallback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                mode.finish()
            }
        }
        activity.onBackPressedDispatcher.addCallback(activity, onBackPressedCallback)
        cancellable = onBackPressedCallback
    }
    private fun closeMode() {
        toolbar.title = originalToolbarTitle.first
        toolbar.subtitle = originalToolbarTitle.second
        menu.close()
        menu.clear()
        activity.onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, menu)
        toolbar.setNavigationOnClickListener {
            activity.onSupportNavigateUp()
        }
        toolbar.setOnMenuItemClickListener { item ->
            activity.onMenuItemSelected(Window.FEATURE_OPTIONS_PANEL, item)
        }
        cancellable?.remove()
        cancellable = null
        animateToMode(false)
    }
    fun animateToMode(toActionMode: Boolean) {
        setActionBarUpIndicator(!toActionMode)
    }
    @SuppressLint("PrivateResource")
    private fun setActionBarUpIndicator(showAsDrawerIndicator: Boolean) {
        toolbar.navigationIcon = arrowDrawable
        toolbar.setNavigationContentDescription(
            if (showAsDrawerIndicator) androidx.navigation.ui.R.string.nav_app_bar_open_drawer_description
            else androidx.navigation.ui.R.string.nav_app_bar_navigate_up_description
        )
        val endValue = if (showAsDrawerIndicator) 0f else 1f
        val startValue = arrowDrawable.progress
        animator?.cancel()
        animator = ObjectAnimator.ofFloat(arrowDrawable, "progress", startValue, endValue)
        animator?.start()
    }
}
interface ToolbarActionModeIndicator {
    fun isInActionMode(): Boolean
}
fun AppCompatActivity.startToolbarActionMode(callback: ActionMode.Callback) =
    ToolbarActionMode(this, findViewById(R.id.toolbar)).startActionMode(callback)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/ToolbarActionModeImpl.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore
import android.annotation.SuppressLint
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.view.accessibility.AccessibilityEvent
import androidx.annotation.StringRes
import androidx.appcompat.view.ActionMode
import androidx.appcompat.view.SupportMenuInflater
import androidx.appcompat.view.menu.MenuBuilder
import androidx.appcompat.widget.Toolbar
@SuppressLint("RestrictedApi")
open class ToolbarActionModeImpl(private val toolbar: Toolbar, private val callback: Callback) :
    ActionMode(), MenuBuilder.Callback {
    private val menu: MenuBuilder
        get() = toolbar.menu as MenuBuilder
    override fun setTitle(title: CharSequence?) {
        toolbar.title = title
    }
    override fun setTitle(@StringRes resId: Int) {
        toolbar.setTitle(resId)
    }
    override fun setSubtitle(subtitle: CharSequence?) {
        toolbar.subtitle = subtitle
    }
    override fun setSubtitle(@StringRes resId: Int) {
        toolbar.setSubtitle(resId)
    }
    override fun invalidate() {
        menu.stopDispatchingItemsChanged()
        callback.onPrepareActionMode(this, menu)
        menu.startDispatchingItemsChanged()
    }
    fun dispatchOnCreate(): Boolean {
        menu.stopDispatchingItemsChanged()
        try {
            return callback.onCreateActionMode(this, menu)
        } finally {
            menu.startDispatchingItemsChanged()
        }
    }
    override fun finish() {
        callback.onDestroyActionMode(this)
        toolbar.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
    }
    override fun getMenu(): Menu = toolbar.menu
    override fun getTitle(): CharSequence = toolbar.title
    override fun getSubtitle(): CharSequence = toolbar.subtitle
    override fun getMenuInflater() = SupportMenuInflater(toolbar.context)
    override fun onMenuItemSelected(menu: MenuBuilder, item: MenuItem) =
        callback.onActionItemClicked(this, item)
    override fun onMenuModeChange(menu: MenuBuilder) {
        invalidate()
    }
    override fun setCustomView(view: View?) {
        throw UnsupportedOperationException()
    }
    override fun getCustomView(): View {
        throw UnsupportedOperationException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/audio/AudioFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.audio
import android.Manifest
import android.os.Build
import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment
class AudioFragment : FilesFragment() {
    override val viewModel: AudioViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        AudioPermissionsRequesterFragment::class.java
    class AudioPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_AUDIO)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/audio/AudioViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.audio
import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel
class AudioViewModel(application: Application) : FilesViewModel(application) {
     private val uri: Uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
     init {
          viewModelScope.launch {
               combine(
                    _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
               ) { isSearching, queryText, sortMediaBy ->
                    queryMedias(uri, sortMediaBy)
               }.collect {
                    _mediasFlow.value = it
               }
          }
          application.contentResolver.registerContentObserver(
               uri, true, contentObserver
          )
     }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/downloads/DownloadsFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.downloads
import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment
class DownloadsFragment : FilesFragment() {
    override val viewModel: DownloadsViewModel by viewModels()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/downloads/DownloadsViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.downloads
import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel
class DownloadsViewModel(application: Application) : FilesViewModel(application) {
    private val uri: Uri = MediaStore.Downloads.EXTERNAL_CONTENT_URI
    init {
        viewModelScope.launch {
            combine(
                _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
            ) { isSearching, queryText, sortMediaBy ->
                queryMedias(uri, sortMediaBy)
            }.collect {
                _mediasFlow.value = it
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.files
import android.annotation.SuppressLint
import android.content.ActivityNotFoundException
import android.content.Intent
import android.text.format.DateUtils
import android.text.format.Formatter
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import com.bumptech.glide.Glide
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.databinding.FilesItemBinding
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import java.util.Calendar
open class FilesAdapter(private val fragment: Fragment) : MediaStoreAdapter(fragment) {
    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreFiles -> R.layout.files_item
        else -> super.getItemViewType(position)
    }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.files_item -> ItemViewHolder(
                FilesItemBinding.inflate(LayoutInflater.from(parent.context))
            )
            else -> super.onCreateViewHolder(parent, viewType)
        }
    private fun formatDateTimeForItem(timeMillis: Long): String {
        then.timeInMillis = timeMillis
        now.timeInMillis = System.currentTimeMillis()
        val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                DateUtils.FORMAT_ABBREV_ALL or when {
            RootPreferences.sortMediaByFlowable.value == SORT_BY_DATE_TAKEN -> {
                DateUtils.FORMAT_SHOW_TIME
            }
            then[Calendar.YEAR] != now[Calendar.YEAR] -> {
                DateUtils.FORMAT_SHOW_YEAR or DateUtils.FORMAT_SHOW_DATE
            }
            then[Calendar.DAY_OF_YEAR] != now[Calendar.DAY_OF_YEAR] -> {
                DateUtils.FORMAT_SHOW_DATE
            }
            else -> {
                DateUtils.FORMAT_SHOW_TIME
            }
        }
        return DateUtils.formatDateTime(fragment.requireContext(), timeMillis, flags)
    }
    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreFiles
                Glide.with(fragment)
                    .load(item.contentUri)
                    .centerCrop()
                    .into(binding.icon)
                binding.title.text = item.displayName
                binding.summary.text = formatDateTimeForItem(item.dateTaken) +
                        "\u0020\u0020\u0020\u0020" +
                        Formatter.formatFileSize(fragment.requireContext(), item.size)
                binding.card.setOnClickListener {
                    val viewIntent = Intent(Intent.ACTION_VIEW)
                        .setDataAndType(item.contentUri, item.mimeType)
                        .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                    with(fragment) {
                        try {
                            startActivity(Intent.createChooser(viewIntent, null))
                        } catch (e: ActivityNotFoundException) {
                            Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
                        }
                    }
                }
                holder.details = object : ItemDetails<Long>() {
                    override fun getPosition(): Int = holder.bindingAdapterPosition
                    override fun getSelectionKey(): Long = item.id
                    override fun inSelectionHotspot(e: MotionEvent): Boolean = false
                    override fun inDragRegion(e: MotionEvent): Boolean = true
                }
                if (selectionTrackerInitialized) {
                    binding.card.isChecked = selectionTracker.isSelected(item.id)
                }
            }
            else -> super.onBindViewHolder(holder, position)
        }
    }
    class ItemViewHolder(val binding: FilesItemBinding) : ViewHolder(binding.root)
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.files
import android.Manifest
import android.os.Build
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.viewModels
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import me.zhanghai.android.fastscroll.PopupStyle
open class FilesFragment : MediaStoreFragment() {
    override val viewModel: FilesViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        FilesPermissionsRequesterFragment::class.java
    override fun onCreateAdapter(): FilesAdapter = FilesAdapter(this)
    override fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .setPopupStyle(PopupStyle.MD3)
            .setViewHelper(MediaStoreRecyclerViewHelper(list) { adapter.currentList })
            .build()
        list.fitsSystemWindowInsets(fastScroller)
    }
    class FilesPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(
                    Manifest.permission.READ_MEDIA_AUDIO,
                    Manifest.permission.READ_MEDIA_IMAGES,
                    Manifest.permission.READ_MEDIA_VIDEO
                )
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (selectionTracker.hasSelection()) {
            return
        }
        inflater.inflate(R.menu.files_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                return true
            }
            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as SearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }
            override fun onQueryTextChange(newText: String): Boolean {
                viewModel.queryText = newText
                return false
            }
        })
        when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH ->
                menu.findItem(R.id.menu_sort_by_path).isChecked = true
            SORT_BY_DATE_TAKEN ->
                menu.findItem(R.id.menu_sort_by_date_taken).isChecked = true
            SORT_BY_SIZE ->
                menu.findItem(R.id.menu_sort_by_size).isChecked = true
        }
        arrayOf(menu.findItem(R.id.menu_header_sort)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_path -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_PATH
            }
            R.id.menu_sort_by_date_taken -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_DATE_TAKEN
            }
            R.id.menu_sort_by_size -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_SIZE
            }
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/FilesViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.files
import android.app.Application
import android.content.ContentUris
import android.net.Uri
import android.provider.MediaStore
import android.util.Log
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreViewModel
import me.gm.cleaner.plugin.util.fileNameComparator
import me.gm.cleaner.plugin.xposed.util.MimeUtils
open class FilesViewModel(application: Application) :
    MediaStoreViewModel<MediaStoreFiles>(application) {
    private val uri: Uri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL)
    protected val _isSearchingFlow: MutableStateFlow<Boolean> = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    protected val _queryTextFlow: MutableStateFlow<String> = MutableStateFlow("")
    var queryText: String by _queryTextFlow
    override suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<MediaStoreFiles> {
        uriToLoad = uri
        val files = mutableListOf<MediaStoreFiles>()
        withContext(Dispatchers.IO) {
            val projection = arrayOf(
                MediaStore.MediaColumns._ID,
                MediaStore.MediaColumns.DATA,
                MediaStore.MediaColumns.DISPLAY_NAME,
                MediaStore.MediaColumns.RELATIVE_PATH,
                MediaStore.MediaColumns.DATE_TAKEN,
                MediaStore.MediaColumns.MIME_TYPE,
                MediaStore.MediaColumns.SIZE,
            )
            val selection = "${MediaStore.MediaColumns.DATE_TAKEN} >= ?"
            val selectionArgs = arrayOf(
                dateToTimestamp(day = 1, month = 1, year = 1970).toString()
            )
            val sortOrder = when (sortMediaBy) {
                SORT_BY_PATH -> MediaStore.MediaColumns.RELATIVE_PATH + ", " +
                        MediaStore.MediaColumns.DISPLAY_NAME
                SORT_BY_DATE_TAKEN -> "${MediaStore.MediaColumns.DATE_TAKEN} DESC"
                SORT_BY_SIZE -> "${MediaStore.MediaColumns.SIZE} DESC"
                else -> throw IllegalArgumentException()
            }
            getApplication<Application>().contentResolver.query(
                uri,
                projection,
                null,
                null,
                sortOrder
            )?.use { cursor ->
                val idColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
                val displayNameColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME)
                val relativePathColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.RELATIVE_PATH)
                val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
                val dateTakenColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_TAKEN)
                val mimeTypeColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.MIME_TYPE)
                val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.SIZE)
                Log.i(TAG, "Found ${cursor.count} files")
                while (cursor.moveToNext()) {
                    val id = cursor.getLong(idColumn)
                    val displayName = cursor.getString(displayNameColumn)
                    val relativePath = cursor.getString(relativePathColumn)
                    val data = cursor.getString(dataColumn)
                    val dateTaken = cursor.getLong(dateTakenColumn)
                    val mimeType = cursor.getString(mimeTypeColumn)
                    val size = cursor.getLong(sizeColumn)
                    val contentUri = ContentUris.withAppendedId(
                        when (MimeUtils.resolveMediaType(mimeType)) {
                            MediaStore.Files.FileColumns.MEDIA_TYPE_AUDIO -> MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
                            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -> MediaStore.Video.Media.EXTERNAL_CONTENT_URI
                            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -> MediaStore.Images.Media.EXTERNAL_CONTENT_URI
                            else -> uri
                        },
                        id
                    )
                    if (isSearching) {
                        if (!data.contains(queryText, true)) {
                            continue
                        }
                    }
                    val file = MediaStoreFiles(
                        id, contentUri, displayName, relativePath, data, dateTaken, mimeType, size
                    )
                    files += file
                    Log.v(TAG, "Added file: $file")
                }
            }
        }
        if (sortMediaBy == SORT_BY_PATH) {
            files.sortWith(fileNameComparator { it.displayName })
            files.sortWith(fileNameComparator { it.relativePath })
        }
        Log.v(TAG, "Found ${files.size} files")
        return files
    }
    init {
        if (this.javaClass === FilesViewModel::class.java) {
            viewModelScope.launch {
                combine(
                    _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
                ) { isSearching, queryText, sortMediaBy ->
                    queryMedias(uri, sortMediaBy)
                }.collect {
                    _mediasFlow.value = it
                }
            }
            application.contentResolver.registerContentObserver(
                uri, true, contentObserver
            )
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/files/MediaStoreFiles.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.files
import android.net.Uri
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreModel
data class MediaStoreFiles(
    override val id: Long,
    override val contentUri: Uri,
    override val displayName: String,
    override val relativePath: String,
    override val data: String,
    override val dateTaken: Long,
    val mimeType: String?,
    val size: Long,
) : MediaStoreModel(id, contentUri, displayName, relativePath, data, dateTaken)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselAdapter.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.annotation.LayoutRes;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.DiffUtil;
import androidx.recyclerview.widget.ListAdapter;
import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;
class CarouselAdapter extends ListAdapter<MediaStoreImage, CarouselItemViewHolder> {
    private static final DiffUtil.ItemCallback<MediaStoreImage> DIFF_CALLBACK =
            new DiffUtil.ItemCallback<MediaStoreImage>() {
                @Override
                public boolean areItemsTheSame(
                        @NonNull MediaStoreImage oldItem, @NonNull MediaStoreImage newItem) {
                    return oldItem.getId() == newItem.getId();
                }
                @Override
                public boolean areContentsTheSame(
                        @NonNull MediaStoreImage oldItem, @NonNull MediaStoreImage newItem) {
                    return oldItem.equals(newItem);
                }
            };
    private final CarouselItemListener listener;
    @LayoutRes
    private final int itemLayoutRes;
    CarouselAdapter(CarouselItemListener listener) {
        this(listener, R.layout.cat_carousel_item);
    }
    CarouselAdapter(CarouselItemListener listener, @LayoutRes int itemLayoutRes) {
        super(DIFF_CALLBACK);
        this.listener = listener;
        this.itemLayoutRes = itemLayoutRes;
    }
    @NonNull
    @Override
    public CarouselItemViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int pos) {
        return new CarouselItemViewHolder(
                LayoutInflater.from(viewGroup.getContext())
                        .inflate(itemLayoutRes, viewGroup, false), listener);
    }
    @Override
    public void onBindViewHolder(@NonNull CarouselItemViewHolder carouselItemViewHolder, int pos) {
        carouselItemViewHolder.bind(getItem(pos));
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselItemListener.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager;
import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;
interface CarouselItemListener {
    void onItemClicked(MediaStoreImage item, int position);
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CarouselItemViewHolder.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager;
import android.view.View;
import android.widget.ImageView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import com.bumptech.glide.Glide;
import me.gm.cleaner.plugin.R;
import me.gm.cleaner.plugin.ui.mediastore.images.MediaStoreImage;
class CarouselItemViewHolder extends RecyclerView.ViewHolder {
  private final ImageView imageView;
  private final CarouselItemListener listener;
  CarouselItemViewHolder(@NonNull View itemView, CarouselItemListener listener) {
    super(itemView);
    imageView = itemView.findViewById(R.id.carousel_image_view);
    this.listener = listener;
  }
  void bind(MediaStoreImage item) {
    Glide.with(imageView.getContext()).load(item.getContentUri()).centerCrop().into(imageView);
    imageView.setContentDescription(item.getDisplayName());
    itemView.setOnClickListener(v -> listener.onItemClicked(item, getBindingAdapterPosition()));
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/CustomChangeImageTransform.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.TypeEvaluator;
import android.content.Context;
import android.graphics.Matrix;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.transition.Transition;
import android.transition.TransitionListenerAdapter;
import android.transition.TransitionValues;
import android.util.AttributeSet;
import android.util.Property;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.github.chrisbanes.photoview.PhotoView;
import java.util.Map;
public class CustomChangeImageTransform extends Transition implements PhotoViewTransition {
    private static final String PROPNAME_MATRIX = "android:changeImageTransform:matrix";
    private static final String PROPNAME_BOUNDS = "android:changeImageTransform:bounds";
    private static final String[] sTransitionProperties = {
            PROPNAME_MATRIX,
            PROPNAME_BOUNDS,
    };
    private static final TypeEvaluator<Matrix> NULL_MATRIX_EVALUATOR = new TypeEvaluator<Matrix>() {
        @Override
        public Matrix evaluate(float fraction, Matrix startValue, Matrix endValue) {
            return null;
        }
    };
    private static final Property<ImageView, Matrix> ANIMATED_TRANSFORM_PROPERTY =
            new Property<ImageView, Matrix>(Matrix.class, "animatedTransform") {
                @Override
                public void set(ImageView view, Matrix matrix) {
                    view.animateTransform(matrix);
                }
                @Override
                public Matrix get(ImageView object) {
                    return null;
                }
            };
    public CustomChangeImageTransform() {
    }
    public CustomChangeImageTransform(@NonNull Context context, @NonNull AttributeSet attrs) {
        super(context, attrs);
    }
    private void captureValues(TransitionValues transitionValues) {
        View view = transitionValues.view;
        if (!(view instanceof ImageView) || view.getVisibility() != View.VISIBLE) {
            return;
        }
        ImageView imageView = (ImageView) view;
        Drawable drawable = imageView.getDrawable();
        if (drawable == null) {
            return;
        }
        Map<String, Object> values = transitionValues.values;
        int left = view.getLeft();
        int top = view.getTop();
        int right = view.getRight();
        int bottom = view.getBottom();
        Rect bounds = new Rect(left, top, right, bottom);
        values.put(PROPNAME_BOUNDS, bounds);
        if (PhotoViewTransition.isPhotoView(imageView)) {
            values.put(PROPNAME_MATRIX, copyImageMatrix(imageView));
        }
    }
    @Override
    public void captureStartValues(@NonNull TransitionValues transitionValues) {
        captureValues(transitionValues);
    }
    @Override
    public void captureEndValues(@NonNull TransitionValues transitionValues) {
        captureValues(transitionValues);
    }
    @Override
    @NonNull
    public String[] getTransitionProperties() {
        return sTransitionProperties;
    }
    private static Matrix calcCenterCropMatrix(@NonNull Rect bounds, @NonNull Drawable image) {
        final int imageWidth = image.getIntrinsicWidth();
        final int imageViewWidth = bounds.width();
        final float scaleX = ((float) imageViewWidth) / imageWidth;
        final int imageHeight = image.getIntrinsicHeight();
        final int imageViewHeight = bounds.height();
        final float scaleY = ((float) imageViewHeight) / imageHeight;
        final float maxScale = Math.max(scaleX, scaleY);
        final float width = imageWidth * maxScale;
        final float height = imageHeight * maxScale;
        final int tx = Math.round((imageViewWidth - width) / 2f);
        final int ty = Math.round((imageViewHeight - height) / 2f);
        final Matrix matrix = new Matrix();
        matrix.postScale(maxScale, maxScale);
        matrix.postTranslate(tx, ty);
        return matrix;
    }
    @Nullable
    @Override
    public Animator createAnimator(@NonNull ViewGroup sceneRoot,
                                   @Nullable TransitionValues startValues,
                                   final @Nullable TransitionValues endValues) {
        if (startValues == null || endValues == null) {
            return null;
        }
        Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
        Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
        if (startBounds == null || endBounds == null) {
            return null;
        }
        final ImageView endView = (ImageView) endValues.view;
        final boolean isAnimViewPhotoView = PhotoViewTransition.isPhotoView(endView);
        final TransitionValues photoViewValues;
        if (isAnimViewPhotoView) {
            photoViewValues = endValues;
        } else {
            photoViewValues = startValues;
        }
        final PhotoView photoView = (PhotoView) photoViewValues.view;
        Matrix matrix = (Matrix) photoViewValues.values.get(PROPNAME_MATRIX);
        Matrix centerCropMatrix;
        if (isAnimViewPhotoView) {
            centerCropMatrix = calcCenterCropMatrix(startBounds, photoView.getDrawable());
        } else {
            centerCropMatrix = calcCenterCropMatrix(endBounds, photoView.getDrawable());
        }
        boolean matricesEqual = matrix != null && matrix.equals(centerCropMatrix);
        if (startBounds.equals(endBounds) && matricesEqual) {
            return null;
        }
        Drawable drawable = photoView.getDrawable();
        int drawableWidth = drawable.getIntrinsicWidth();
        int drawableHeight = drawable.getIntrinsicHeight();
        ObjectAnimator animator;
        if (drawableWidth <= 0 || drawableHeight <= 0) {
            animator = createNullAnimator(endView);
        } else {
            if (matrix == null) {
                matrix = IDENTITY_MATRIX;
            }
            if (centerCropMatrix == null) {
                centerCropMatrix = IDENTITY_MATRIX;
            }
            if (isAnimViewPhotoView) {
                ANIMATED_TRANSFORM_PROPERTY.set(endView, centerCropMatrix);
                animator = createMatrixAnimator(endView, centerCropMatrix, matrix);
            } else {
                ANIMATED_TRANSFORM_PROPERTY.set(endView, matrix);
                animator = createMatrixAnimator(endView, matrix, centerCropMatrix);
            }
            if (!isAnimViewPhotoView) {
                final MatrixAnimatorListener listener = new MatrixAnimatorListener(endView);
                animator.addListener(listener);
                addListener(new TransitionListenerAdapter() {
                    @Override
                    public void onTransitionEnd(Transition transition) {
                        listener.onAnimationEnd(animator);
                        transition.removeListener(this);
                    }
                });
                endView.setImageDrawable(photoView.getDrawable());
            }
        }
        return animator;
    }
    @NonNull
    private ObjectAnimator createNullAnimator(@NonNull ImageView imageView) {
        return ObjectAnimator.ofObject(imageView, ANIMATED_TRANSFORM_PROPERTY,
                NULL_MATRIX_EVALUATOR, IDENTITY_MATRIX, IDENTITY_MATRIX);
    }
    private ObjectAnimator createMatrixAnimator(final ImageView imageView, Matrix startMatrix,
                                                final Matrix endMatrix) {
        return ObjectAnimator.ofObject(imageView, ANIMATED_TRANSFORM_PROPERTY,
                new TransitionUtils_MatrixEvaluator(), startMatrix, endMatrix);
    }
    @NonNull
    private static Matrix copyImageMatrix(@NonNull ImageView view) {
        final Drawable image = view.getDrawable();
        if (image.getIntrinsicWidth() > 0 && image.getIntrinsicHeight() > 0) {
            switch (view.getScaleType()) {
                case FIT_XY:
                    return fitXYMatrix(view);
                case CENTER_CROP:
                    return centerCropMatrix(view);
                default:
                    return new Matrix(view.getImageMatrix());
            }
        }
        return new Matrix(view.getImageMatrix());
    }
    private static Matrix fitXYMatrix(ImageView view) {
        final Drawable image = view.getDrawable();
        final Matrix matrix = new Matrix();
        matrix.postScale(
                ((float) view.getWidth()) / image.getIntrinsicWidth(),
                ((float) view.getHeight()) / image.getIntrinsicHeight());
        return matrix;
    }
    private static Matrix centerCropMatrix(ImageView view) {
        final Drawable image = view.getDrawable();
        final int imageWidth = image.getIntrinsicWidth();
        final int imageViewWidth = view.getWidth();
        final float scaleX = ((float) imageViewWidth) / imageWidth;
        final int imageHeight = image.getIntrinsicHeight();
        final int imageViewHeight = view.getHeight();
        final float scaleY = ((float) imageViewHeight) / imageHeight;
        final float maxScale = Math.max(scaleX, scaleY);
        final float width = imageWidth * maxScale;
        final float height = imageHeight * maxScale;
        final int tx = Math.round((imageViewWidth - width) / 2f);
        final int ty = Math.round((imageViewHeight - height) / 2f);
        final Matrix matrix = new Matrix();
        matrix.postScale(maxScale, maxScale);
        matrix.postTranslate(tx, ty);
        return matrix;
    }
    static final Matrix IDENTITY_MATRIX = new Matrix() {
        void oops() {
            throw new IllegalStateException("Matrix can not be modified");
        }
        @Override
        public void set(Matrix src) {
            oops();
        }
        @Override
        public void reset() {
            oops();
        }
        @Override
        public void setTranslate(float dx, float dy) {
            oops();
        }
        @Override
        public void setScale(float sx, float sy, float px, float py) {
            oops();
        }
        @Override
        public void setScale(float sx, float sy) {
            oops();
        }
        @Override
        public void setRotate(float degrees, float px, float py) {
            oops();
        }
        @Override
        public void setRotate(float degrees) {
            oops();
        }
        @Override
        public void setSinCos(float sinValue, float cosValue, float px, float py) {
            oops();
        }
        @Override
        public void setSinCos(float sinValue, float cosValue) {
            oops();
        }
        @Override
        public void setSkew(float kx, float ky, float px, float py) {
            oops();
        }
        @Override
        public void setSkew(float kx, float ky) {
            oops();
        }
        @Override
        public boolean setConcat(Matrix a, Matrix b) {
            oops();
            return false;
        }
        @Override
        public boolean preTranslate(float dx, float dy) {
            oops();
            return false;
        }
        @Override
        public boolean preScale(float sx, float sy, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean preScale(float sx, float sy) {
            oops();
            return false;
        }
        @Override
        public boolean preRotate(float degrees, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean preRotate(float degrees) {
            oops();
            return false;
        }
        @Override
        public boolean preSkew(float kx, float ky, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean preSkew(float kx, float ky) {
            oops();
            return false;
        }
        @Override
        public boolean preConcat(Matrix other) {
            oops();
            return false;
        }
        @Override
        public boolean postTranslate(float dx, float dy) {
            oops();
            return false;
        }
        @Override
        public boolean postScale(float sx, float sy, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean postScale(float sx, float sy) {
            oops();
            return false;
        }
        @Override
        public boolean postRotate(float degrees, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean postRotate(float degrees) {
            oops();
            return false;
        }
        @Override
        public boolean postSkew(float kx, float ky, float px, float py) {
            oops();
            return false;
        }
        @Override
        public boolean postSkew(float kx, float ky) {
            oops();
            return false;
        }
        @Override
        public boolean postConcat(Matrix other) {
            oops();
            return false;
        }
        @Override
        public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf) {
            oops();
            return false;
        }
        @Override
        public boolean setPolyToPoly(float[] src, int srcIndex, float[] dst, int dstIndex,
                                     int pointCount) {
            oops();
            return false;
        }
        @Override
        public void setValues(float[] values) {
            oops();
        }
    };
    static class TransitionUtils_MatrixEvaluator implements TypeEvaluator<Matrix> {
        final float[] mTempStartValues = new float[9];
        final float[] mTempEndValues = new float[9];
        final Matrix mTempMatrix = new Matrix();
        @Override
        public Matrix evaluate(float fraction, Matrix startValue, Matrix endValue) {
            startValue.getValues(mTempStartValues);
            endValue.getValues(mTempEndValues);
            for (int i = 0; i < 9; i++) {
                float diff = mTempEndValues[i] - mTempStartValues[i];
                mTempEndValues[i] = mTempStartValues[i] + (fraction * diff);
            }
            mTempMatrix.setValues(mTempEndValues);
            return mTempMatrix;
        }
    }
    private static class MatrixAnimatorListener extends AnimatorListenerAdapter {
        private final ImageView mView;
        private final Drawable mBackup;
        private boolean mLayerTypeChanged = false;
        public MatrixAnimatorListener(ImageView view) {
            mView = view;
            mBackup = view.getDrawable();
        }
        @Override
        public void onAnimationStart(Animator animator) {
            if (mView.hasOverlappingRendering() && mView.getLayerType() == View.LAYER_TYPE_NONE) {
                mLayerTypeChanged = true;
                mView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
            }
        }
        @Override
        public void onAnimationEnd(Animator animator) {
            mView.setImageDrawable(mBackup);
            if (mLayerTypeChanged) {
                mView.setLayerType(View.LAYER_TYPE_NONE, null);
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager
import android.app.Activity
import android.content.ActivityNotFoundException
import android.content.Intent
import android.content.pm.ActivityInfo
import android.content.res.Configuration
import android.net.Uri
import android.os.Bundle
import android.transition.TransitionInflater
import android.transition.TransitionSet
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.Toast
import androidx.core.app.SharedElementCallback
import androidx.core.math.MathUtils.clamp
import androidx.core.os.bundleOf
import androidx.core.transition.doOnEnd
import androidx.core.transition.doOnStart
import androidx.core.view.get
import androidx.core.view.isVisible
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.activityViewModels
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.RecyclerView
import androidx.viewpager2.adapter.FragmentStateAdapter
import androidx.viewpager2.widget.ViewPager2
import com.github.chrisbanes.photoview.PhotoView
import com.google.android.material.carousel.CarouselLayoutManager
import com.google.android.material.carousel.CarouselSnapHelper
import com.google.android.material.carousel.CustomHeroCarouselStrategy
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ImagePagerFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ui.mediastore.images.ImagesViewModel
import me.gm.cleaner.plugin.util.MediaStoreCompat
import me.gm.cleaner.plugin.util.MediaStoreCompat.DELETE_PERMISSION_REQUEST
class ImagePagerFragment : BaseFragment() {
    private val viewModel: ImagePagerViewModel by viewModels()
    private val imagesViewModel: ImagesViewModel by activityViewModels()
    private val args: ImagePagerFragmentArgs by navArgs()
    private val lastPosition by lazy { bundleOf(KEY_POSITION to args.initialPosition) }
    private lateinit var viewPager: ViewPager2
    private lateinit var bottomBar: LinearLayout
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = ImagePagerFragmentBinding.inflate(inflater)
        viewModel.isOverlayingLiveData.observe(viewLifecycleOwner) { isOverlaying ->
            appBarLayout?.post {
                appBarLayout?.isLifted = isOverlaying
            }
        }
        bottomBar = binding.bottomBar
        binding.bottomActionBar.setOnMenuItemClickListener(::onOptionsItemSelected)
        val carouselRecyclerView = binding.carouselRecyclerView
        viewPager = binding.viewPager
        if (args.uri == null) {
            bindForMediaStoreImages(savedInstanceState, carouselRecyclerView)
        } else {
            bindForContentProviderImage(carouselRecyclerView)
        }
        findNavController().addOnExitListener { _, destination, _ ->
            restoreAppBar(destination)
            appBarLayout?.setLiftableOverrideEnabled(false)
            requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
                .setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED)
        }
        prepareSharedElementTransition()
        if (savedInstanceState == null && args.uri == null) {
            postponeEnterTransition()
        }
        return binding.root
    }
    private fun bindForMediaStoreImages(
        savedInstanceState: Bundle?, carouselRecyclerView: RecyclerView
    ) {
        val adapter = CarouselAdapter { _, position ->
            viewPager.setCurrentItem(position, true)
        }
        carouselRecyclerView.adapter = adapter
        carouselRecyclerView.layoutManager =
            CarouselLayoutManager(CustomHeroCarouselStrategy()).apply {
                carouselAlignment = CarouselLayoutManager.ALIGNMENT_CENTER
            }
        carouselRecyclerView.isNestedScrollingEnabled = false
        val enableFlingSnapHelper = CarouselSnapHelper(false)
        enableFlingSnapHelper.attachToRecyclerView(carouselRecyclerView)
        viewPager.adapter = object : FragmentStateAdapter(this) {
            val initialItemId: Long = if (savedInstanceState == null) {
                imagesViewModel.medias[args.initialPosition].id
            } else {
                0
            }
            override fun createFragment(position: Int): ImagePagerItem {
                val media = imagesViewModel.medias[position]
                return ImagePagerItem.newInstance(
                    media.contentUri, savedInstanceState == null && initialItemId == media.id
                )
            }
            override fun getItemCount(): Int = imagesViewModel.medias.size
            override fun getItemId(position: Int): Long = imagesViewModel.medias[position].id
            override fun containsItem(itemId: Long): Boolean =
                imagesViewModel.medias.any { itemId == it.id }
        }
        viewPager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                lastPosition.putInt(KEY_POSITION, position)
                viewModel.currentItemId = imagesViewModel.medias[position].id
                updateTitle(position)
                if (carouselRecyclerView.scrollState != RecyclerView.SCROLL_STATE_DRAGGING) {
                    carouselRecyclerView.smoothScrollToPosition(position)
                }
            }
        })
        carouselRecyclerView.addOnScrollListener(
            object : RecyclerView.OnScrollListener() {
                private var dragged: Boolean = false
                private fun scrollToSnapView(recyclerView: RecyclerView) {
                    val snapView = enableFlingSnapHelper.findSnapView(recyclerView.layoutManager)
                        ?: return
                    val position = recyclerView.getChildAdapterPosition(snapView)
                    viewPager.setCurrentItem(position, true)
                }
                override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
                    if (newState == RecyclerView.SCROLL_STATE_DRAGGING) {
                        dragged = true
                    } else if (dragged && newState == RecyclerView.SCROLL_STATE_IDLE) {
                        scrollToSnapView(recyclerView)
                        dragged = false
                    }
                }
                override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                    if (recyclerView.scrollState != RecyclerView.SCROLL_STATE_DRAGGING ||
                        viewPager.scrollState != ViewPager2.SCROLL_STATE_IDLE
                    ) {
                        return
                    }
                    scrollToSnapView(recyclerView)
                }
            }
        )
        lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                imagesViewModel.mediasFlow.collect { medias ->
                    if (medias.isEmpty()) {
                        findNavController().navigateUp()
                    } else {
                        var position = medias.indexOfFirst { viewModel.currentItemId == it.id }
                        if (position == -1) {
                            viewPager.adapter!!.notifyItemRemoved(viewPager.currentItem)
                            position = clamp(viewPager.currentItem, 0, medias.size - 1)
                        } else {
                            viewPager.setCurrentItem(position, false)
                        }
                        updateTitle(position)
                        adapter.submitList(medias) {
                            carouselRecyclerView.scrollToPosition(position)
                        }
                    }
                }
            }
        }
        if (savedInstanceState == null) {
            val position = args.initialPosition
            viewPager.setCurrentItem(position, false)
            viewModel.currentItemId = imagesViewModel.medias[position].id
        }
    }
    private fun bindForContentProviderImage(carouselRecyclerView: RecyclerView) {
        carouselRecyclerView.isVisible = false
        viewPager.adapter = object : FragmentStateAdapter(this) {
            override fun createFragment(position: Int): ImagePagerItem =
                ImagePagerItem.newInstance(args.uri!!, true)
            override fun getItemCount(): Int = 1
        }
        updateTitle(0)
    }
    private fun updateTitle(position: Int) {
        supportActionBar?.apply {
            if (args.uri == null) {
                title = imagesViewModel.medias[position].displayName
                subtitle = "${position + 1} / ${imagesViewModel.medias.size}"
            } else {
                lifecycleScope.launch {
                    val result = viewModel
                        .queryImageTitleAsync(args.uri!!)
                        .await()
                    title = result.getOrNull()
                }
            }
        }
    }
    private fun findPhotoViewForAdapterPosition(position: Int): PhotoView? =
        (viewPager[0] as RecyclerView)
            .findViewHolderForAdapterPosition(position)
            ?.itemView
            ?.findViewById(R.id.photo_view)
    private fun prepareSharedElementTransition() {
        setFragmentResult(ImagePagerFragment::class.java.name, lastPosition)
        sharedElementEnterTransition = (TransitionInflater.from(requireContext())
            .inflateTransition(R.transition.grid_pager_transition) as TransitionSet)
            .addTransition(CustomChangeImageTransform())
            .apply {
                doOnStart {
                    viewPager.isUserInputEnabled = false
                }
                doOnEnd {
                    viewPager.isUserInputEnabled = true
                }
            }
        enterTransition = TransitionInflater.from(requireContext())
            .inflateTransition(R.transition.pager_enter_transition)
        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val photoView = findPhotoViewForAdapterPosition(viewPager.currentItem) ?: return
                if (names.isNotEmpty()) {
                    sharedElements[names[0]] = photoView
                }
            }
        })
    }
    private fun getCurrentImageUri(): Uri = if (args.uri == null) {
        imagesViewModel.medias[viewPager.currentItem].contentUri
    } else {
        args.uri!!
    }
    private fun deleteCurrentImage() {
        lifecycleScope.launch {
            try {
                val isSuccessfullyDeleted =
                    MediaStoreCompat.delete(this@ImagePagerFragment, getCurrentImageUri())
                if (isSuccessfullyDeleted && args.uri != null) {
                    activity?.finish()
                }
            } catch (e: Throwable) {
                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
            }
        }
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (resultCode == Activity.RESULT_OK && requestCode == DELETE_PERMISSION_REQUEST) {
            deleteCurrentImage()
        }
    }
    override fun toggleAppBar(show: Boolean) {
        super.toggleAppBar(show)
        bottomBar.isVisible = show
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        inflater.inflate(R.menu.image_pager_toolbar, menu)
    }
    override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
        R.id.menu_screen_rotation -> {
            requireActivity().requestedOrientation = when (resources.configuration.orientation) {
                Configuration.ORIENTATION_PORTRAIT -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                Configuration.ORIENTATION_LANDSCAPE -> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                else -> throw IllegalArgumentException()
            }
            true
        }
        R.id.menu_info -> {
            lifecycleScope.launch {
                val result = viewModel
                    .queryImageInfoAsync(getCurrentImageUri())
                    .await()
                TextSelectableInfoDialog
                    .newInstance(result.getOrElse { it.stackTraceToString() })
                    .show(childFragmentManager, null)
            }
            true
        }
        R.id.menu_share -> {
            val sendIntent = Intent(Intent.ACTION_SEND)
                .setType("image/*")
                .putExtra(Intent.EXTRA_STREAM, getCurrentImageUri())
            val shareIntent = Intent.createChooser(sendIntent, null)
            try {
                startActivity(shareIntent)
            } catch (e: ActivityNotFoundException) {
                Toast.makeText(requireContext(), e.message, Toast.LENGTH_SHORT).show()
            }
            true
        }
        R.id.menu_delete -> {
            deleteCurrentImage()
            true
        }
        else -> super.onOptionsItemSelected(item)
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putCharSequence(SAVED_TITLE, supportActionBar?.title)
        outState.putCharSequence(SAVED_SUBTITLE, supportActionBar?.subtitle)
        outState.putBoolean(SAVED_SHOWS_APPBAR, supportActionBar?.isShowing ?: true)
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        appBarLayout?.setLiftableOverrideEnabled(true)
        savedInstanceState?.run {
            supportActionBar?.apply {
                title = getCharSequence(SAVED_TITLE)
                subtitle = getCharSequence(SAVED_SUBTITLE)
            }
            toggleAppBar(getBoolean(SAVED_SHOWS_APPBAR))
        }
        requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
            .setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)
    }
    companion object {
        const val KEY_POSITION = "me.gm.cleaner.plugin.key.position"
        private const val SAVED_TITLE = "android:title"
        private const val SAVED_SUBTITLE = "android:subtitle"
        private const val SAVED_SHOWS_APPBAR = "android:showsAppBar"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerItem.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager
import android.graphics.Matrix
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Bundle
import android.transition.TransitionSet
import android.view.GestureDetector
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.core.graphics.values
import androidx.core.os.BundleCompat
import androidx.core.os.bundleOf
import androidx.core.transition.doOnEnd
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.target.Target
import com.github.chrisbanes.photoview.PhotoView
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ImagePagerItemBinding
import kotlin.math.max
class ImagePagerItem : BaseFragment() {
    private val viewModel: ImagePagerViewModel by viewModels({ requireParentFragment() })
    private val uri: Uri by lazy {
        BundleCompat.getParcelable(requireArguments(), KEY_IMAGE_URI, Uri::class.java)!!
    }
    private val parentFragment: ImagePagerFragment by lazy {
        requireParentFragment() as ImagePagerFragment
    }
    private lateinit var photoView: PhotoView
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = ImagePagerItemBinding.inflate(inflater)
        photoView = binding.photoView
        photoView.transitionName = uri.toString()
        photoView.setOnScaleChangeListener { _, _, _ ->
            parentFragment.toggleAppBar(false)
            viewModel.isOverlaying(photoView.displayRect)
        }
        photoView.setOnDoubleTapListener(object : GestureDetector.SimpleOnGestureListener() {
            override fun onSingleTapConfirmed(e: MotionEvent): Boolean {
                parentFragment.toggleAppBar(supportActionBar?.isShowing == false)
                viewModel.isOverlaying(photoView.displayRect)
                return true
            }
            override fun onDoubleTap(e: MotionEvent): Boolean {
                try {
                    val scale = photoView.scale
                    val x = e.x
                    val y = e.y
                    if (scale < photoView.mediumScale) {
                        photoView.setScale(photoView.mediumScale, x, y, true)
                    } else {
                        photoView.setScale(photoView.minimumScale, x, y, true)
                    }
                } catch (e: ArrayIndexOutOfBoundsException) {
                }
                return true
            }
        })
        Glide.with(this)
            .load(uri)
            .listener(object : RequestListener<Drawable?> {
                override fun onLoadFailed(
                    e: GlideException?, model: Any?, target: Target<Drawable?>,
                    isFirstResource: Boolean
                ): Boolean {
                    Toast
                        .makeText(requireContext(), e?.message.toString(), Toast.LENGTH_SHORT)
                        .show()
                    parentFragment.startPostponedEnterTransition()
                    return false
                }
                override fun onResourceReady(
                    resource: Drawable, model: Any, target: Target<Drawable?>,
                    dataSource: DataSource, isFirstResource: Boolean
                ): Boolean {
                    photoView.post {
                        val displayRect = photoView.displayRect
                        var midScale = max(
                            photoView.width / displayRect.width(),
                            photoView.height / displayRect.height()
                        )
                        if (midScale == 1F) {
                            midScale = 3F
                        }
                        val maxScale = max(3 * midScale, 9F)
                        photoView.setScaleLevels(1F, midScale, maxScale)
                        if (savedInstanceState != null) {
                            val matrix = Matrix()
                            matrix.setValues(savedInstanceState.getFloatArray(KEY_MATRIX))
                            photoView.setSuppMatrix(matrix)
                        }
                        parentFragment.startPostponedEnterTransition()
                    }
                    if (resource is BitmapDrawable) {
                        val initialEntry = requireArguments().getBoolean(KEY_INITIAL_ENTRY)
                        if (savedInstanceState == null && initialEntry &&
                            findNavController().previousBackStackEntry?.destination?.id == R.id.images_fragment
                        ) {
                            (parentFragment.sharedElementEnterTransition as TransitionSet).doOnEnd {
                                setupTilesProvider()
                            }
                        } else {
                            setupTilesProvider()
                        }
                    }
                    return false
                }
            })
            .into(photoView)
        return binding.root
    }
    private fun setupTilesProvider() {
        lifecycleScope.launch(Dispatchers.IO) {
            runCatching {
                requireContext().contentResolver.openFileDescriptor(uri, "r").use { pfd ->
                    photoView.setupTilesProvider(pfd)
                }
            }
        }
    }
    override fun onResume() {
        super.onResume()
        viewModel.isOverlaying(photoView.displayRect)
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        if (::photoView.isInitialized) {
            val matrix = Matrix()
            photoView.getSuppMatrix(matrix)
            outState.putFloatArray(KEY_MATRIX, matrix.values())
        }
    }
    companion object {
        private const val KEY_IMAGE_URI: String = "me.gm.cleaner.plugin.key.imageUri"
        private const val KEY_INITIAL_ENTRY: String = "me.gm.cleaner.plugin.key.initialEntry"
        private const val KEY_MATRIX: String = "me.gm.cleaner.plugin.key.matrix"
        fun newInstance(uri: Uri, initialEntry: Boolean): ImagePagerItem = ImagePagerItem().apply {
            arguments = bundleOf(
                KEY_IMAGE_URI to uri,
                KEY_INITIAL_ENTRY to initialEntry
            )
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/ImagePagerViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager
import android.app.Application
import android.graphics.RectF
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import android.text.format.DateUtils
import android.text.format.Formatter
import androidx.core.os.bundleOf
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.R
import java.io.FileNotFoundException
class ImagePagerViewModel(application: Application, state: SavedStateHandle) :
    AndroidViewModel(application) {
    init {
        state.setSavedStateProvider(::currentItemId.name) {
            bundleOf(::currentItemId.name to currentItemId)
        }
    }
    private val _isOverlayingLiveData: MutableLiveData<Boolean> = MutableLiveData(false)
    val isOverlayingLiveData: LiveData<Boolean>
        get() = _isOverlayingLiveData
    private val top: Int by lazy {
        val res = getApplication<Application>().resources
        val actionBarSize =
            res.getDimensionPixelSize(com.google.android.material.R.dimen.m3_appbar_size_compact)
        val resourceId = res.getIdentifier("status_bar_height", "dimen", "android")
        res.getDimensionPixelSize(resourceId) + actionBarSize
    }
    var currentItemId: Long = state.get<Bundle>(::currentItemId.name).let { bundle ->
        bundle?.getLong(::currentItemId.name) ?: 0L
    }
    fun isOverlaying(displayRect: RectF?): Boolean {
        displayRect ?: return false
        val isOverlaying = displayRect.top < top
        _isOverlayingLiveData.postValue(isOverlaying)
        return isOverlaying
    }
    fun queryImageInfoAsync(uri: Uri) = viewModelScope.async {
        queryImageInfo(uri)
    }
    private suspend fun queryImageInfo(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(
            MediaStore.Images.Media.DATA,
            MediaStore.Images.Media.DATE_TAKEN,
            MediaStore.Images.Media.SIZE,
            MediaStore.Images.Media.WIDTH,
            MediaStore.Images.Media.HEIGHT,
        )
        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->
            val dataColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATA)
            val dateTakenColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN)
            val sizeColumn = cursor.getColumnIndex(MediaStore.Images.Media.SIZE)
            val widthColumn = cursor.getColumnIndex(MediaStore.Images.Media.WIDTH)
            val heightColumn = cursor.getColumnIndex(MediaStore.Images.Media.HEIGHT)
            if (cursor.moveToNext()) {
                val nameStrIdToValue = mutableListOf<Pair<Int, String>>()
                if (dataColumn != -1) {
                    val data = cursor.getString(dataColumn)
                    nameStrIdToValue += R.string.menu_sort_by_path_title to data
                }
                if (dateTakenColumn != -1) {
                    val dateTaken = cursor.getLong(dateTakenColumn)
                    nameStrIdToValue += R.string.menu_sort_by_date_taken_title to
                            DateUtils.formatDateTime(
                                context, dateTaken,
                                DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                                        DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_YEAR or
                                        DateUtils.FORMAT_SHOW_DATE or DateUtils.FORMAT_SHOW_TIME
                            )
                }
                if (sizeColumn != -1) {
                    val size = cursor.getLong(sizeColumn)
                    nameStrIdToValue += R.string.menu_sort_by_size_title to
                            Formatter.formatFileSize(context, size)
                }
                if (widthColumn != -1 && heightColumn != -1) {
                    val width = cursor.getLong(widthColumn)
                    val height = cursor.getLong(heightColumn)
                    val resolution = "$width x $height"
                    nameStrIdToValue += R.string.resolution to resolution
                }
                val info = nameStrIdToValue.map { (nameStrId, value) ->
                    context.getString(
                        R.string.info_item, context.getString(nameStrId), value
                    )
                }
                return@withContext Result.success(info.joinToString("\n"))
            }
        }
        Result.failure(FileNotFoundException())
    }
    fun queryImageTitleAsync(uri: Uri) = viewModelScope.async {
        queryImageTitle(uri)
    }
    private suspend fun queryImageTitle(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(MediaStore.Images.Media.DISPLAY_NAME)
        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->
            val displayNameColumn =
                cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
            if (cursor.moveToNext()) {
                val displayName = cursor.getString(displayNameColumn)
                return@withContext Result.success(displayName)
            }
        }
        Result.failure(FileNotFoundException())
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/PhotoViewTransition.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager;
import android.view.View;
import androidx.annotation.NonNull;
import com.github.chrisbanes.photoview.PhotoView;
public interface PhotoViewTransition {
    static boolean isPhotoView(@NonNull View view) {
        return view instanceof PhotoView;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/imagepager/TextSelectableInfoDialog.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.imagepager
import android.os.Bundle
import android.view.View
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatDialogFragment
import androidx.core.os.bundleOf
import com.google.android.material.dialog.MaterialAlertDialogBuilder
class TextSelectableInfoDialog : AppCompatDialogFragment() {
    override fun onCreateDialog(savedInstanceState: Bundle?): AlertDialog =
        MaterialAlertDialogBuilder(requireContext(), theme)
            .setMessage(requireArguments().getString(KEY_MESSAGE))
            .setPositiveButton(android.R.string.ok, null)
            .create().apply {
                setOnShowListener {
                    window?.findViewById<TextView>(android.R.id.message)?.apply {
                        textAlignment = View.TEXT_ALIGNMENT_VIEW_START
                        setTextIsSelectable(true)
                    }
                }
            }
    companion object {
        private const val KEY_MESSAGE: String = "me.gm.cleaner.key.message"
        fun newInstance(message: String): TextSelectableInfoDialog =
            TextSelectableInfoDialog().apply { arguments = bundleOf(KEY_MESSAGE to message) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images
import android.graphics.drawable.Drawable
import android.transition.TransitionInflater
import android.transition.TransitionSet
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.ViewGroup
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.selection.ItemDetailsLookup.ItemDetails
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.target.Target
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.ImagesItemBinding
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
class ImagesAdapter(private val fragment: ImagesFragment) : MediaStoreAdapter(fragment) {
    override fun getItemViewType(position: Int): Int = when (getItem(position)) {
        is MediaStoreImage -> R.layout.images_item
        else -> super.getItemViewType(position)
    }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        when (viewType) {
            R.layout.images_item -> ItemViewHolder(
                ImagesItemBinding.inflate(LayoutInflater.from(parent.context))
            )
            else -> super.onCreateViewHolder(parent, viewType)
        }
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position)
                Glide.with(fragment)
                    .load(item.contentUri)
                    .listener(object : RequestListener<Drawable?> {
                        override fun onLoadFailed(
                            e: GlideException?, model: Any?, target: Target<Drawable?>,
                            isFirstResource: Boolean
                        ): Boolean {
                            if (fragment.lastPosition == getUriPositionForAdapterPosition(holder.bindingAdapterPosition)) {
                                fragment.startPostponedEnterTransition()
                            }
                            return false
                        }
                        override fun onResourceReady(
                            resource: Drawable, model: Any, target: Target<Drawable?>,
                            dataSource: DataSource, isFirstResource: Boolean
                        ): Boolean {
                            if (fragment.lastPosition == getUriPositionForAdapterPosition(holder.bindingAdapterPosition)) {
                                fragment.startPostponedEnterTransition()
                            }
                            return false
                        }
                    })
                    .centerCrop()
                    .into(binding.image)
                binding.image.transitionName = item.contentUri.toString()
                binding.card.setOnClickListener {
                    val uriPosition = getUriPositionForAdapterPosition(
                        holder.bindingAdapterPosition
                    )
                    fragment.lastPosition = uriPosition
                    val exitTransition = TransitionInflater.from(fragment.requireContext())
                        .inflateTransition(R.transition.grid_exit_transition)
                    (exitTransition as TransitionSet).excludeTarget(binding.card, true)
                    fragment.exitTransition = exitTransition
                    val direction = ImagesFragmentDirections.actionImagesToImagePager(
                        initialPosition = uriPosition,
                        uri = null
                    )
                    val extras = FragmentNavigatorExtras(
                        binding.image to binding.image.transitionName
                    )
                    fragment.findNavController().navigate(direction, extras)
                }
                holder.details = object : ItemDetails<Long>() {
                    override fun getPosition(): Int = holder.bindingAdapterPosition
                    override fun getSelectionKey(): Long = item.id
                    override fun inSelectionHotspot(e: MotionEvent): Boolean = false
                    override fun inDragRegion(e: MotionEvent): Boolean = true
                }
                if (selectionTrackerInitialized) {
                    binding.card.isChecked = selectionTracker.isSelected(item.id)
                }
            }
            else -> super.onBindViewHolder(holder, position)
        }
    }
    class ItemViewHolder(val binding: ImagesItemBinding) : ViewHolder(binding.root)
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images
import android.Manifest
import android.os.Build
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.widget.ImageView
import androidx.core.app.SharedElementCallback
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.activityViewModels
import androidx.fragment.app.setFragmentResultListener
import androidx.recyclerview.widget.GridLayoutManager.SpanSizeLookup
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.databinding.MediaStoreFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreAdapter
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreHeader
import me.gm.cleaner.plugin.ui.mediastore.imagepager.ImagePagerFragment
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import me.zhanghai.android.fastscroll.PopupStyle
class ImagesFragment : MediaStoreFragment() {
    override val viewModel: ImagesViewModel by activityViewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        ImagesPermissionsRequesterFragment::class.java
    var lastPosition: Int = 0
    override fun onCreateAdapter(): MediaStoreAdapter = ImagesAdapter(this)
    override fun onBindView(
        binding: MediaStoreFragmentBinding,
        list: RecyclerView,
        adapter: MediaStoreAdapter
    ) {
        val layoutManager =
            ProgressionGridLayoutManager(
                requireContext(),
                RootPreferences.spanCountFlowable.value
            ).apply {
                spanSizeLookup = object : SpanSizeLookup() {
                    override fun getSpanSize(position: Int): Int =
                        if (adapter.currentList[position] is MediaStoreHeader) {
                            spanCount
                        } else {
                            1
                        }
                }
            }
        list.layoutManager = layoutManager
        val viewHelper = MediaStoreRecyclerViewHelper(list) { adapter.currentList }
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .setPopupStyle(PopupStyle.MD3)
            .setViewHelper(viewHelper)
            .build()
        list.fitsSystemWindowInsets(fastScroller)
        list.addOnItemTouchListener(
            ScaleGestureListener(requireContext(), layoutManager, viewHelper)
        )
        prepareTransitions(list, adapter)
        setFragmentResultListener(ImagePagerFragment::class.java.name) { _, bundle ->
            lastPosition = bundle.getInt(ImagePagerFragment.KEY_POSITION)
            postponeEnterTransition()
            list.post {
                val lastUriPosition = adapter.getHolderPositionForUriPosition(lastPosition)
                if (lastUriPosition != null) {
                    scrollToPosition(list, lastUriPosition)
                } else {
                    startPostponedEnterTransition()
                }
            }
        }
    }
    private fun prepareTransitions(list: RecyclerView, adapter: MediaStoreAdapter) {
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val lastUriPosition = adapter.getHolderPositionForUriPosition(lastPosition)
                    ?: return
                val selectedViewHolder = list.findViewHolderForAdapterPosition(lastUriPosition)
                    ?: return
                val image = selectedViewHolder.itemView.findViewById<ImageView>(R.id.image)
                    ?: return
                sharedElements[names[0]] = image
            }
        })
    }
    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }
    class ImagesPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_IMAGES)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (selectionTracker.hasSelection()) {
            return
        }
        inflater.inflate(R.menu.images_toolbar, menu)
        when (RootPreferences.sortMediaByFlowable.value) {
            SORT_BY_PATH ->
                menu.findItem(R.id.menu_sort_by_path).isChecked = true
            SORT_BY_DATE_TAKEN, SORT_BY_SIZE ->
                menu.findItem(R.id.menu_sort_by_date_taken).isChecked = true
        }
        arrayOf(menu.findItem(R.id.menu_header_sort)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_path -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_PATH
            }
            R.id.menu_sort_by_date_taken -> {
                item.isChecked = true
                RootPreferences.sortMediaByFlowable.value = SORT_BY_DATE_TAKEN
            }
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ImagesViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images
import android.app.Application
import android.content.ContentProvider
import android.content.ContentResolver
import android.content.ContentUris
import android.database.Cursor
import android.net.Uri
import android.provider.MediaStore
import android.util.Log
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_DATE_TAKEN
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_PATH
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_SIZE
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreViewModel
import me.gm.cleaner.plugin.util.fileNameComparator
class ImagesViewModel(application: Application) :
    MediaStoreViewModel<MediaStoreImage>(application) {
    private val uri: Uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI
    override suspend fun queryMedias(uri: Uri, sortMediaBy: Int): List<MediaStoreImage> {
        uriToLoad = uri
        val images = mutableListOf<MediaStoreImage>()
        withContext(Dispatchers.IO) {
            val projection = arrayOf(
                MediaStore.MediaColumns._ID,
                MediaStore.MediaColumns.DISPLAY_NAME,
                MediaStore.MediaColumns.RELATIVE_PATH,
                MediaStore.MediaColumns.DATA,
                MediaStore.MediaColumns.DATE_TAKEN,
            )
            val selection = "${MediaStore.MediaColumns.DATE_TAKEN} >= ?"
            val selectionArgs = arrayOf(
                dateToTimestamp(day = 1, month = 1, year = 1970).toString()
            )
            val sortOrder = when (sortMediaBy) {
                SORT_BY_PATH -> MediaStore.MediaColumns.RELATIVE_PATH + ", " +
                        MediaStore.MediaColumns.DISPLAY_NAME
                SORT_BY_DATE_TAKEN, SORT_BY_SIZE -> "${MediaStore.MediaColumns.DATE_TAKEN} DESC"
                else -> throw IllegalArgumentException()
            }
            getApplication<Application>().contentResolver.query(
                uri,
                projection,
                null,
                null,
                sortOrder
            )?.use { cursor ->
                val idColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID)
                val displayNameColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DISPLAY_NAME)
                val relativePathColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.RELATIVE_PATH)
                val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA)
                val dateTakenColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATE_TAKEN)
                Log.i(TAG, "Found ${cursor.count} images")
                while (cursor.moveToNext()) {
                    val id = cursor.getLong(idColumn)
                    val displayName = cursor.getString(displayNameColumn)
                    val relativePath = cursor.getString(relativePathColumn)
                    val data = cursor.getString(dataColumn)
                    val dateTaken = cursor.getLong(dateTakenColumn)
                    val contentUri = ContentUris.withAppendedId(
                        uri,
                        id
                    )
                    val image = MediaStoreImage(
                        id, contentUri, displayName, relativePath, data, dateTaken
                    )
                    images += image
                    Log.v(TAG, "Added image: $image")
                }
            }
        }
        if (sortMediaBy == SORT_BY_PATH) {
            images.sortWith(fileNameComparator { it.displayName })
            images.sortWith(fileNameComparator { it.relativePath })
        }
        Log.v(TAG, "Found ${images.size} images")
        return images
    }
    init {
        viewModelScope.launch {
            RootPreferences.sortMediaByFlowable.asFlow().collect { sortMediaBy ->
                _mediasFlow.value = queryMedias(uri, sortMediaBy)
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/MediaStoreImage.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images
import android.net.Uri
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreModel
data class MediaStoreImage(
    override val id: Long,
    override val contentUri: Uri,
    override val displayName: String,
    override val relativePath: String,
    override val data: String,
    override val dateTaken: Long,
) : MediaStoreModel(id, contentUri, displayName, relativePath, data, dateTaken)

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ProgressionGridLayoutManager.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images;
import android.animation.TimeInterpolator;
import android.content.Context;
import android.graphics.Rect;
import android.util.SparseArray;
import android.view.View;
import android.view.animation.LinearInterpolator;
import androidx.annotation.FloatRange;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.interpolator.view.animation.FastOutSlowInInterpolator;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import java.util.function.Consumer;
public class ProgressionGridLayoutManager extends GridLayoutManager {
    private static final boolean DEBUG = false;
    private static final String TAG = "ProgressionGridLayoutManager";
    int mLastSpanCount;
    boolean mLayoutInfoStale = false;
    SparseArray<Rect> mLastLayoutInfo = new SparseArray<>();
    SparseArray<Rect> mCurLayoutInfo = new SparseArray<>();
    @FloatRange(from = 0F, to = 1F)
    float mProgress = 1F;
    @NonNull
    TimeInterpolator mInterpolator = new FastOutSlowInInterpolator();
    public ProgressionGridLayoutManager(Context context, int spanCount) {
        super(context, spanCount);
    }
    public ProgressionGridLayoutManager(Context context, int spanCount,
                                        @RecyclerView.Orientation int orientation,
                                        boolean reverseLayout) {
        super(context, spanCount, orientation, reverseLayout);
    }
    private static class VisibleChild {
        final int index;
        final View child;
        private VisibleChild(int index, View child) {
            this.index = index;
            this.child = child;
        }
    }
    private void forEachIndexed(Consumer<VisibleChild> action) {
        final int fromIndex = findFirstVisibleItemPosition();
        if (fromIndex == RecyclerView.NO_POSITION) {
            return;
        }
        final int toIndex = findLastVisibleItemPosition();
        for (int i = fromIndex; i <= toIndex; i++) {
            final View child = findViewByPosition(i);
            assert child != null;
            action.accept(new VisibleChild(i, child));
        }
    }
    void layoutInfoSnapshot(SparseArray<Rect> layoutInfo) {
        layoutInfo.clear();
        forEachIndexed(visibleChild -> {
            final int i = visibleChild.index;
            final View child = visibleChild.child;
            final Rect rect = new Rect();
            child.getHitRect(rect);
            layoutInfo.put(i, rect);
        });
    }
    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (mLayoutInfoStale) {
            layoutInfoSnapshot(mLastLayoutInfo);
        }
        super.onLayoutChildren(recycler, state);
    }
    @Override
    public void onLayoutCompleted(RecyclerView.State state) {
        super.onLayoutCompleted(state);
        if (mLayoutInfoStale) {
            layoutInfoSnapshot(mCurLayoutInfo);
            mLayoutInfoStale = false;
            if (mLastSpanCount != DEFAULT_SPAN_COUNT) {
                setProgress(0F);
            }
        }
    }
    @Override
    public boolean canScrollVertically() {
        return getProgress() == 1F && super.canScrollVertically();
    }
    private float getInterpolatedProgress() {
        return mInterpolator.getInterpolation(getProgress());
    }
    void mockLayout(@NonNull View child, int left, int top, int right, int bottom,
                    int lastLeft, int lastTop, int lastRight, int lastBottom) {
        final float progress = getInterpolatedProgress();
        final int lastWidth = lastRight - lastLeft;
        final int lastHeight = lastBottom - lastTop;
        final int width = right - left;
        final int height = bottom - top;
        child.setScaleX((lastWidth + (width - lastWidth) * progress) / width);
        child.setScaleY((lastHeight + (height - lastHeight) * progress) / height);
        final float lastHorizontalCenter = (lastRight + lastLeft) >> 1;
        final float lastVerticalCenter = (lastBottom + lastTop) >> 1;
        final float horizontalCenter = (right + left) >> 1;
        final float verticalCenter = (bottom + top) >> 1;
        child.setTranslationX((lastHorizontalCenter - horizontalCenter) * (1 - progress));
        child.setTranslationY((lastVerticalCenter - verticalCenter) * (1 - progress));
    }
    @Override
    public void setSpanCount(int spanCount) {
        if (spanCount == getSpanCount()) {
            return;
        }
        if (getProgress() != 1F &&
                getSpanCount() != DEFAULT_SPAN_COUNT) {
            throw new IllegalStateException(
                    "Must finish the previous animation first before setting a new span count");
        }
        mLastSpanCount = getSpanCount();
        mLayoutInfoStale = true;
        super.setSpanCount(spanCount);
    }
    public float getProgress() {
        return mProgress;
    }
    public void setProgress(@FloatRange(from = 0F, to = 1F) float progress) {
        if (progress == mProgress) {
            return;
        }
        if (mLayoutInfoStale) {
            return;
        }
        mProgress = progress;
        final boolean setAlphaNeeded = mLastSpanCount < getSpanCount();
        forEachIndexed(visibleChild -> {
            final int i = visibleChild.index;
            final View child = visibleChild.child;
            final Rect last = mLastLayoutInfo.get(i);
            if (last != null) {
                final Rect cur = mCurLayoutInfo.get(i);
                if (cur == null) {
                    throw new IllegalStateException("Are you scrolling?");
                }
                mockLayout(child, cur.left, cur.top, cur.right, cur.bottom,
                        last.left, last.top, last.right, last.bottom
                );
            } else if (setAlphaNeeded) {
                final float interpolatedProgress = getInterpolatedProgress();
                child.setAlpha(interpolatedProgress);
            }
        });
    }
    public TimeInterpolator getInterpolator() {
        return mInterpolator;
    }
    public void setInterpolator(@Nullable TimeInterpolator i) {
        mInterpolator = i != null ? i : new LinearInterpolator();
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/images/ScaleGestureListener.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.images
import android.animation.Animator
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.content.Context
import android.view.MotionEvent
import android.view.ScaleGestureDetector
import androidx.core.animation.doOnEnd
import androidx.core.math.MathUtils.clamp
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.animation.AnimationUtils
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ui.mediastore.MediaStoreFragment
import kotlin.math.abs
class ScaleGestureListener(
    private val context: Context,
    private val layoutManager: ProgressionGridLayoutManager,
    private val viewHelper: MediaStoreFragment.MediaStoreRecyclerViewHelper
) : RecyclerView.SimpleOnItemTouchListener() {
    private var scaleEndAnimator: ValueAnimator? = null
    private val gestureDetector: ScaleGestureDetector by lazy {
        ScaleGestureDetector(context, object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
            private var prevProgress = 0F
            private var isNewSpanCountSet = false
            override fun onScale(detector: ScaleGestureDetector): Boolean {
                val scaleFactor = detector.scaleFactor
                if (!isNewSpanCountSet && layoutManager.progress == 1F) {
                    layoutManager.spanCount = when {
                        scaleFactor > 1F -> {
                            if (layoutManager.spanCount - spanCountInterval < minSpanCount ||
                                layoutManager.spanCount == minSpanCount && layoutManager.progress == 1F
                            ) {
                                return true
                            }
                            layoutManager.spanCount - spanCountInterval
                        }
                        scaleFactor < 1F -> {
                            if (layoutManager.spanCount + spanCountInterval > maxSpanCount ||
                                layoutManager.spanCount == maxSpanCount && layoutManager.progress == 1F
                            ) {
                                return true
                            }
                            layoutManager.spanCount + spanCountInterval
                        }
                        else -> return false
                    }
                    isNewSpanCountSet = true
                }
                val newProgress = when {
                    scaleFactor > 1F -> abs(1F - scaleFactor) / SCALE_FACTOR
                    scaleFactor < 1F -> abs(1F - 1 / scaleFactor) / SCALE_FACTOR
                    else -> 0F
                }
                if (layoutManager.progress == 1F) {
                    prevProgress = newProgress
                    isNewSpanCountSet = false
                }
                layoutManager.progress = clamp(newProgress - prevProgress, 0F, 1F)
                return false
            }
            override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
                if (scaleEndAnimator?.isRunning == true) {
                    return false
                }
                prevProgress = 0F
                isNewSpanCountSet = false
                return true
            }
            override fun onScaleEnd(detector: ScaleGestureDetector) {
                animateProgress(layoutManager.progress, 1F) {
                    RootPreferences.spanCountFlowable.value = layoutManager.spanCount
                    viewHelper.observer.onChanged()
                }
            }
        })
    }
    @SuppressLint("RestrictedApi")
    private fun animateProgress(
        from: Float, to: Float, doOnEnd: ((animator: Animator) -> Unit)? = null
    ) {
        scaleEndAnimator?.cancel()
        scaleEndAnimator = ValueAnimator.ofFloat(from, to).apply {
            duration = (context.mediumAnimTime * abs(to - from)).toLong()
            interpolator = AnimationUtils.LINEAR_INTERPOLATOR
            addUpdateListener { valueAnimator ->
                layoutManager.progress = valueAnimator.animatedValue as Float
            }
            doOnEnd {
                doOnEnd?.invoke(it)
            }
            start()
        }
    }
    override fun onInterceptTouchEvent(rv: RecyclerView, e: MotionEvent): Boolean {
        if (scaleEndAnimator?.isRunning == true) {
            return true
        } else {
            scaleEndAnimator = null
        }
        return e.pointerCount >= 2
    }
    override fun onTouchEvent(rv: RecyclerView, e: MotionEvent) {
        val scaleEndAnimator = scaleEndAnimator
        when {
            scaleEndAnimator == null -> {
                gestureDetector.onTouchEvent(e)
            }
            scaleEndAnimator.isRunning -> {
                rv.requestDisallowInterceptTouchEvent(true)
            }
            !scaleEndAnimator.isRunning -> {
            }
        }
    }
    companion object {
        const val SCALE_FACTOR: Float = 1F
        const val minSpanCount: Int = 1
        const val maxSpanCount: Int = 5
        const val spanCountInterval: Int = 1
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ui.mediastore.files.FilesAdapter
import me.gm.cleaner.plugin.ui.mediastore.files.MediaStoreFiles
class VideoAdapter(private val fragment: VideoFragment) : FilesAdapter(fragment) {
    private val viewModel: VideoViewModel by fragment.viewModels()
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        super.onBindViewHolder(holder, position)
        when (holder) {
            is ItemViewHolder -> {
                val binding = holder.binding
                val item = getItem(position) as MediaStoreFiles
                binding.card.setOnClickListener {
                    val navController = fragment.findNavController()
                    if (navController.currentDestination?.id != R.id.video_fragment) {
                        return@setOnClickListener
                    }
                    val direction = VideoFragmentDirections.actionVideoToVideoPlayer(
                        uris = arrayOf(item.contentUri),
                    )
                    navController.navigate(direction)
                }
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video
import android.Manifest
import android.os.Build
import androidx.fragment.app.viewModels
import me.gm.cleaner.plugin.ui.mediastore.files.FilesFragment
class VideoFragment : FilesFragment() {
    override val viewModel: VideoViewModel by viewModels()
    override val requesterFragmentClass: Class<out MediaPermissionsRequesterFragment> =
        FilesPermissionsRequesterFragment::class.java
    override fun onCreateAdapter(): VideoAdapter = VideoAdapter(this)
    class VideoPermissionsRequesterFragment : MediaPermissionsRequesterFragment() {
        override val requiredPermissions: Array<String> =
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                arrayOf(Manifest.permission.READ_MEDIA_VIDEO)
            } else {
                arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoPlayerFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video
import android.content.pm.ActivityInfo
import android.content.res.Configuration
import android.os.Bundle
import android.view.LayoutInflater
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.Toolbar
import androidx.drawerlayout.widget.DrawerLayout
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.AudioAttributes
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.common.VideoSize
import androidx.media3.common.util.UnstableApi
import androidx.media3.exoplayer.DefaultRenderersFactory
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.exoplayer.SeekParameters
import androidx.media3.exoplayer.trackselection.DefaultTrackSelector
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import androidx.media3.ui.TimeBar
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.VideoPlayerFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomOnHorizontalScrubListener
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomOnVerticalScrubListener
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.CustomTimeBar
import me.gm.cleaner.plugin.ui.mediastore.video.customexo.VideoGestureDetector
import kotlin.math.max
@UnstableApi
class VideoPlayerFragment : BaseFragment() {
    private val viewModel: VideoPlayerViewModel by viewModels()
    private val args: VideoPlayerFragmentArgs by navArgs()
    private lateinit var trackSelectionParameters: DefaultTrackSelector.Parameters
    private var startItemIndex: Int = 0
    private var startPosition: Long = 0L
    private var isPlaying: Boolean = true
    private var playbackSpeed: Float = RootPreferences.playbackSpeedFlowable.value
    private lateinit var trackSelector: DefaultTrackSelector
    private var player: ExoPlayer? = null
    private var playerView: PlayerView? = null
    private lateinit var topBar: Toolbar
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = VideoPlayerFragmentBinding.inflate(inflater)
        playerView = binding.playerView
        customizePlayerViewBehavior(playerView!!, binding.gestureView)
        viewModel.screenOrientationLiveData.observe(viewLifecycleOwner) { orientation ->
            requireActivity().requestedOrientation = orientation
        }
        if (savedInstanceState != null) {
            trackSelectionParameters = DefaultTrackSelector.Parameters.CREATOR.fromBundle(
                savedInstanceState.getBundle(KEY_TRACK_SELECTION_PARAMETERS)!!
            )
            startItemIndex = savedInstanceState.getInt(KEY_ITEM_INDEX)
            startPosition = savedInstanceState.getLong(KEY_POSITION)
            isPlaying = savedInstanceState.getBoolean(KEY_IS_PLAYING, isPlaying)
            playbackSpeed = RootPreferences.playbackSpeedFlowable.value
        } else {
            trackSelectionParameters = DefaultTrackSelector
                .ParametersBuilder(requireContext())
                .build()
        }
        findNavController().addOnExitListener { _, destination, _ ->
            restoreAppBar(destination)
            requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
                .setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED)
        }
        return binding.root
    }
    private fun customizePlayerViewBehavior(playerView: PlayerView, gestureView: View) {
        playerView.controllerAutoShow = false
        playerView.isClickable = false
        val controller =
            playerView.findViewById<PlayerControlView>(androidx.media3.ui.R.id.exo_controller)!!
        val controlViewLayoutManager = PlayerControlViewLayoutManagerAccessor(controller)
        val timeBar = controller.findViewById<CustomTimeBar>(androidx.media3.ui.R.id.exo_progress)
        timeBar.addListener(timeBar)
        timeBar.addListener(object : CustomOnHorizontalScrubListener(
            playerView, controller, controlViewLayoutManager
        ) {
            override fun onScrubStart(timeBar: TimeBar, position: Long) {
                (playerView.player as? ExoPlayer)?.setSeekParameters(SeekParameters.CLOSEST_SYNC)
                super.onScrubStart(timeBar, position)
            }
            override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
                (playerView.player as? ExoPlayer)?.setSeekParameters(null)
                super.onScrubStop(timeBar, position, canceled)
            }
        })
        topBar = controller.findViewById(R.id.top_bar)
        topBar.setNavigationOnClickListener { findNavController().navigateUp() }
        topBar.setNavigationIcon(R.drawable.ic_outline_arrow_back_24)
        if (resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT) {
            topBar.fitsSystemWindowInsets()
        }
        val horizontalScrubListeners = arrayOf(timeBar, object : CustomOnHorizontalScrubListener(
            playerView, controller, controlViewLayoutManager
        ) {
        })
        val verticalScrubListener = CustomOnVerticalScrubListener(
            requireActivity().window, playerView, controller, controlViewLayoutManager
        )
        val detector = VideoGestureDetector(requireContext(), object :
            VideoGestureDetector.OnVideoGestureListener {
            private val density: Float = resources.displayMetrics.density
            override fun onHorizontalScrubStart(
                initialMotionX: Float, initialMotionY: Float
            ) {
                val player = player ?: return
                for (listener in horizontalScrubListeners) {
                    listener.onScrubStart(timeBar, player.currentPosition)
                }
            }
            override fun onHorizontalScrubMove(dx: Float): Boolean {
                val player = player ?: return false
                val newPositionMs =
                    player.currentPosition + (SCRUB_FACTOR * dx / density).toLong()
                for (listener in horizontalScrubListeners) {
                    listener.onScrubMove(timeBar, newPositionMs)
                }
                return true
            }
            override fun onHorizontalScrubEnd() {
                val player = player ?: return
                for (listener in horizontalScrubListeners) {
                    listener.onScrubStop(timeBar, player.currentPosition, false)
                }
            }
            override fun onVerticalScrubStart(initialMotionX: Float, initialMotionY: Float) {
                verticalScrubListener.onScrubStart(initialMotionX, initialMotionY)
            }
            override fun onVerticalScrubMove(dy: Float): Boolean {
                verticalScrubListener.onScrubMove(dy)
                return true
            }
            override fun onVerticalScrubEnd() {
                verticalScrubListener.onScrubStop()
            }
            override fun onSingleTapConfirmed(ev: MotionEvent): Boolean {
                if (controller.isFullyVisible) {
                    controlViewLayoutManager.hide()
                } else {
                    controlViewLayoutManager.show()
                }
                return true
            }
            override fun onDoubleTap(ev: MotionEvent): Boolean {
                val player = player ?: return false
                player.playWhenReady = !player.playWhenReady
                if (player.playWhenReady) {
                    controlViewLayoutManager.hide()
                }
                return true
            }
        }
        )
        gestureView.setOnTouchListener { _, event ->
            detector.onTouchEvent(event)
            true
        }
    }
    inner class PlayerEventListener : Player.Listener {
        override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {
            super.onMediaItemTransition(mediaItem, reason)
            lifecycleScope.launch {
                val result = viewModel
                    .queryVideoTitleAsync(mediaItem!!.localConfiguration!!.uri)
                    .await()
                topBar.title = result.getOrNull()
            }
        }
        override fun onVideoSizeChanged(videoSize: VideoSize) {
            super.onVideoSizeChanged(videoSize)
            if (videoSize != VideoSize.UNKNOWN) {
                viewModel.screenOrientation = if (videoSize.width > videoSize.height) {
                    ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                } else {
                    ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                }
            }
        }
    }
    private fun initializePlayer() {
        if (player != null) {
            return
        }
        val context = requireContext().applicationContext
        val renderersFactory = DefaultRenderersFactory(context)
            .setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
        trackSelector = DefaultTrackSelector(context)
        player = ExoPlayer.Builder(context)
            .setRenderersFactory(renderersFactory)
            .setTrackSelector(trackSelector)
            .setDeviceVolumeControlEnabled(true)
            .build().also { player ->
                player.addListener(PlayerEventListener())
                player.seekTo(startItemIndex, startPosition)
                player.setAudioAttributes(AudioAttributes.DEFAULT, true)
                player.setPlaybackSpeed(playbackSpeed)
                player.playWhenReady = isPlaying
                player.trackSelectionParameters = trackSelectionParameters
                val mediaItems = args.uris.map { MediaItem.fromUri(it) }
                player.setMediaItems(mediaItems, false)
                player.prepare()
            }
        playerView?.player = player
    }
    private fun updatePlayerState() {
        player?.let { player ->
            trackSelectionParameters =
                player.trackSelectionParameters as DefaultTrackSelector.Parameters
            startItemIndex = player.currentMediaItemIndex
            startPosition = max(0, player.contentPosition)
            isPlaying = player.playWhenReady
            playbackSpeed = player.playbackParameters.speed
        }
    }
    private fun releasePlayer() {
        updatePlayerState()
        player?.release()
        player = null
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        toggleAppBar(false)
        requireActivity().findViewById<DrawerLayout>(R.id.drawer_layout)
            .setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)
    }
    override fun onResume() {
        super.onResume()
        initializePlayer()
        playerView?.onResume()
    }
    override fun onStart() {
        super.onStart()
        initializePlayer()
        playerView?.onResume()
    }
    override fun onPause() {
        super.onPause()
        playerView?.onPause()
        releasePlayer()
    }
    override fun onStop() {
        super.onStop()
        playerView?.onPause()
        releasePlayer()
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        updatePlayerState()
        outState.putBundle(KEY_TRACK_SELECTION_PARAMETERS, trackSelectionParameters.toBundle())
        outState.putInt(KEY_ITEM_INDEX, startItemIndex)
        outState.putLong(KEY_POSITION, startPosition)
        outState.putBoolean(KEY_IS_PLAYING, isPlaying)
        RootPreferences.playbackSpeedFlowable.value = playbackSpeed
    }
    companion object {
        private const val SCRUB_FACTOR: Int = 125
        private const val KEY_TRACK_SELECTION_PARAMETERS: String = "track_selection_parameters"
        private const val KEY_ITEM_INDEX: String = "item_index"
        private const val KEY_POSITION: String = "position"
        private const val KEY_IS_PLAYING: String = "is_playing"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoPlayerViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video
import android.app.Application
import android.content.pm.ActivityInfo
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.withContext
import java.io.FileNotFoundException
class VideoPlayerViewModel(application: Application) : AndroidViewModel(application) {
    private val _screenOrientationFlow: MutableStateFlow<Int> =
        MutableStateFlow(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
    val screenOrientationLiveData: LiveData<Int>
        get() = _screenOrientationFlow.asLiveData()
    var screenOrientation: Int
        get() = _screenOrientationFlow.value
        set(value) {
            _screenOrientationFlow.tryEmit(value)
        }
    fun queryVideoTitleAsync(uri: Uri) = viewModelScope.async {
        queryVideoTitle(uri)
    }
    private suspend fun queryVideoTitle(uri: Uri) = withContext(Dispatchers.IO) {
        val projection = arrayOf(MediaStore.Video.Media.DISPLAY_NAME)
        val context = getApplication<Application>()
        context.contentResolver.query(
            uri,
            projection,
            null,
            null,
            null
        )?.use { cursor ->
            val displayNameColumn =
                cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)
            if (cursor.moveToNext()) {
                val displayName = cursor.getString(displayNameColumn)
                return@withContext Result.success(displayName)
            }
        }
        Result.failure(FileNotFoundException())
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/VideoViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video
import android.app.Application
import android.net.Uri
import android.provider.MediaStore
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ui.mediastore.files.FilesViewModel
class VideoViewModel(application: Application) : FilesViewModel(application) {
    private val uri: Uri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    init {
        viewModelScope.launch {
            combine(
                _isSearchingFlow, _queryTextFlow, RootPreferences.sortMediaByFlowable.asFlow()
            ) { isSearching, queryText, sortMediaBy ->
                queryMedias(uri, sortMediaBy)
            }.collect {
                _mediasFlow.value = it
            }
        }
        application.contentResolver.registerContentObserver(
            uri, true, contentObserver
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomOnHorizontalScrubListener.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video.customexo
import android.view.View
import android.view.ViewGroup
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.widget.Toolbar
import androidx.core.view.isVisible
import androidx.media3.common.util.UnstableApi
import androidx.media3.common.util.Util
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import androidx.media3.ui.TimeBar
import me.gm.cleaner.plugin.R
import java.lang.reflect.Field
import java.util.Formatter
import java.util.Locale
@UnstableApi
open class CustomOnHorizontalScrubListener(
    private val playerView: PlayerView,
    private val controller: PlayerControlView,
    private val controlViewLayoutManager: PlayerControlViewLayoutManagerAccessor
) : TimeBar.OnScrubListener {
    private val scrubbingField: Field = PlayerControlView::class.java
        .getDeclaredField("scrubbing")
        .apply { isAccessible = true }
    private lateinit var controlsBackground: View
    private lateinit var centerControls: LinearLayout
    private lateinit var centerText: TextView
    private lateinit var topBar: Toolbar
    private lateinit var bottomBar: ViewGroup
    private lateinit var timeBar: View
    private var playingOnScrubStart: Boolean = true
    private var controllerVisibleOnScrubStart: Boolean = false
    private var startingPosition: Long = 0L
    private val formatBuilder: StringBuilder = StringBuilder()
    private val formatter: Formatter = Formatter(formatBuilder, Locale.getDefault())
    private fun prepareViews() {
        if (::controlsBackground.isInitialized) {
            return
        }
        controlsBackground =
            controller.findViewById(androidx.media3.ui.R.id.exo_controls_background)
        centerControls = controller.findViewById(androidx.media3.ui.R.id.exo_center_controls)
        centerText = controller.findViewById(R.id.center_text)
        topBar = controller.findViewById(R.id.top_bar)
        bottomBar = controller.findViewById(androidx.media3.ui.R.id.exo_bottom_bar)
        timeBar = controller.findViewById(androidx.media3.ui.R.id.exo_progress)
    }
    private fun getDeltaString(timeMs: Long): String {
        val prefix = if (timeMs > 0) "+" else ""
        return prefix + Util.getStringForTime(formatBuilder, formatter, timeMs)
    }
    override fun onScrubStart(timeBar: TimeBar, position: Long) {
        prepareViews()
        scrubbingField[controller] = true
        playingOnScrubStart = playerView.player?.playWhenReady == true
        controllerVisibleOnScrubStart = controller.isFullyVisible
        controlsBackground.isVisible = false
        centerControls.isVisible = false
        centerText.isVisible = true
        topBar.isVisible = false
        bottomBar.translationY = 0F
        this.timeBar.translationY = 0F
        controlViewLayoutManager.showImmediately()
        controlViewLayoutManager.removeHideCallbacks()
        playerView.player?.pause()
        startingPosition = playerView.player?.currentPosition ?: 0L
        playerView.player?.seekTo(position)
        centerText.text = getDeltaString(position - startingPosition)
    }
    override fun onScrubMove(timeBar: TimeBar, position: Long) {
        playerView.player?.seekTo(position)
        centerText.text = getDeltaString(position - startingPosition)
    }
    override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
        scrubbingField[controller] = false
        controlsBackground.isVisible = true
        centerControls.isVisible = true
        centerText.isVisible = false
        topBar.isVisible = true
        if (controllerVisibleOnScrubStart) {
            controlViewLayoutManager.resetHideCallbacks()
        } else {
            controlViewLayoutManager.hideImmediately()
        }
        playerView.player?.seekTo(position)
        if (playingOnScrubStart) {
            playerView.player?.play()
        }
    }
    val isScrubbing: Boolean
        get() = scrubbingField[controller] as Boolean
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomOnVerticalScrubListener.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video.customexo
import android.provider.Settings
import android.view.Window
import android.view.WindowManager
import android.widget.TextView
import androidx.core.math.MathUtils.clamp
import androidx.core.view.children
import androidx.core.view.isVisible
import androidx.media3.common.DeviceInfo
import androidx.media3.common.util.UnstableApi
import androidx.media3.ui.PlayerControlView
import androidx.media3.ui.PlayerControlViewLayoutManagerAccessor
import androidx.media3.ui.PlayerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.isRtl
import kotlin.math.roundToInt
@UnstableApi
open class CustomOnVerticalScrubListener(
    private val window: Window,
    private val playerView: PlayerView,
    private val controller: PlayerControlView,
    private val controlViewLayoutManager: PlayerControlViewLayoutManagerAccessor
) {
    private lateinit var centerText: TextView
    private lateinit var deviceInfo: DeviceInfo
    private val density: Float = playerView.resources.displayMetrics.density * 2
    private val isRtl: Boolean = playerView.resources.configuration.isRtl
    private var atLeftHalfScreen: Boolean = true
    private var screenBrightness: Float = window.attributes.screenBrightness
    private var currentVolume: Float = 0F
    private fun prepare() {
        if (::centerText.isInitialized) {
            return
        }
        centerText = playerView.findViewById(R.id.center_text)
        deviceInfo = playerView.player!!.deviceInfo
    }
    private fun getBrightnessString(brightness: Float): String = "${(100 * brightness).toInt()} %"
    private fun getVolumeString(deviceVolume: Int): String {
        val fraction =
            100 * (deviceVolume - deviceInfo.minVolume) / (deviceInfo.maxVolume - deviceInfo.minVolume)
        return "$fraction %"
    }
    fun onScrubStart(initialMotionX: Float, initialMotionY: Float) {
        val player = playerView.player ?: return
        prepare()
        controller.children.forEach { child ->
            child.isVisible = child === centerText
        }
        controlViewLayoutManager.showImmediately()
        controlViewLayoutManager.removeHideCallbacks()
        atLeftHalfScreen = initialMotionX < playerView.width / 2
        if (screenBrightness == WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE) {
            val SCREEN_BRIGHTNESS_FLOAT = "screen_brightness_float"
            screenBrightness = Settings.System.getFloat(
                playerView.context.contentResolver, SCREEN_BRIGHTNESS_FLOAT
            )
        }
        currentVolume = player.deviceVolume.toFloat()
    }
    fun onScrubMove(dy: Float) {
        val player = playerView.player ?: return
        if (!isRtl && atLeftHalfScreen || isRtl && !atLeftHalfScreen) {
            screenBrightness = clamp(
                screenBrightness - dy / density / (deviceInfo.maxVolume - deviceInfo.minVolume),
                0F,
                1F
            )
            centerText.text = getBrightnessString(screenBrightness)
            val attributes = window.attributes
            attributes.screenBrightness = screenBrightness
            window.attributes = attributes
        } else {
            currentVolume = clamp(
                currentVolume - dy / density,
                deviceInfo.minVolume.toFloat(),
                deviceInfo.maxVolume.toFloat()
            )
            val currentVolumeInt = currentVolume.roundToInt()
            centerText.text = getVolumeString(currentVolumeInt)
            player.setDeviceVolume(currentVolumeInt, 0)
        }
    }
    fun onScrubStop() {
        controller.children.forEach { child ->
            child.isVisible = child !== centerText
        }
        controlViewLayoutManager.hideImmediately()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/CustomTimeBar.kt
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video.customexo
import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ValueAnimator
import android.annotation.SuppressLint
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import androidx.core.math.MathUtils.clamp
import androidx.core.view.ViewCompat
import androidx.media3.common.util.UnstableApi
import androidx.media3.common.util.Util
import androidx.media3.ui.TimeBar
import com.google.android.material.R
import com.google.android.material.animation.AnimationUtils
import com.google.android.material.internal.DescendantOffsetUtils
import com.google.android.material.internal.ViewUtils
import com.google.android.material.tooltip.TooltipDrawable
import me.gm.cleaner.plugin.ktx.isRtl
import me.gm.cleaner.plugin.ktx.shortAnimTime
import kotlin.math.max
@UnstableApi
@SuppressLint("RestrictedApi")
class CustomTimeBar @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0,
    timebarAttrs: AttributeSet? = null, defStyleRes: Int = 0
) : DefaultTimeBar(context, attrs, defStyleAttr, timebarAttrs, defStyleRes),
    TimeBar.OnScrubListener {
    private val label = context.obtainStyledAttributes(
        attrs, R.styleable.Slider, defStyleAttr, R.style.Widget_Material3_Slider
    ).use {
        TooltipDrawable.createFromAttributes(
            context, null, 0, it.getResourceId(
                R.styleable.Slider_labelStyle, R.style.Widget_Material3_Tooltip
            )
        )
    }
    private var labelAreAnimatedIn = false
    private var labelInAnimator: ValueAnimator? = null
    private var labelOutAnimator: ValueAnimator? = null
    private val widgetHeight = resources.getDimensionPixelOffset(R.dimen.mtrl_slider_widget_height)
    private val thumbRadius = dpToPx(density, DEFAULT_BAR_HEIGHT_DP) / 2
    private val labelPadding = resources.getDimensionPixelSize(R.dimen.mtrl_slider_label_padding)
    private var trackWidth = 0
    override fun onScrubStart(timeBar: TimeBar, position: Long) {
        label.text = Util.getStringForTime(formatBuilder, formatter, position)
        ensureLabelAdded()
    }
    override fun onScrubMove(timeBar: TimeBar, position: Long) {
        scrubPosition = position
        label.text = Util.getStringForTime(formatBuilder, formatter, position)
        ensureLabelAdded()
    }
    override fun onScrubStop(timeBar: TimeBar, position: Long, canceled: Boolean) {
        ensureLabelRemoved()
    }
    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        updateTrackWidth(w)
    }
    private fun updateTrackWidth(width: Int) {
        trackWidth = max(width, 0)
    }
    override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        attachLabelToContentView(label)
    }
    private fun attachLabelToContentView(label: TooltipDrawable) {
        label.setRelativeToView(ViewUtils.getContentView(this))
    }
    override fun onDetachedFromWindow() {
        labelAreAnimatedIn = false
        detachLabelFromContentView(label)
        super.onDetachedFromWindow()
    }
    private fun detachLabelFromContentView(label: TooltipDrawable) {
        overlay.remove(label)
        label.detachView(ViewUtils.getContentView(this))
    }
    private fun getAnimatorCurrentValueOrDefault(
        animator: ValueAnimator?, defaultValue: Float
    ): Float {
        if (animator != null && animator.isRunning) {
            val value = animator.animatedValue as Float
            animator.cancel()
            return value
        }
        return defaultValue
    }
    private fun createLabelAnimator(enter: Boolean): ValueAnimator? {
        var startFraction = if (enter) 0f else 1f
        startFraction = getAnimatorCurrentValueOrDefault(
            if (enter) labelOutAnimator else labelInAnimator, startFraction
        )
        val endFraction = if (enter) 1f else 0f
        val animator = ValueAnimator.ofFloat(startFraction, endFraction)
        animator.duration = context.shortAnimTime
        animator.interpolator =
            if (enter) AnimationUtils.DECELERATE_INTERPOLATOR else AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR
        animator.addUpdateListener { animation ->
            val fraction = animation.animatedValue as Float
            label.setRevealFraction(fraction)
            ViewCompat.postInvalidateOnAnimation(this)
        }
        return animator
    }
    private fun ensureLabelAdded() {
        if (!labelAreAnimatedIn) {
            labelAreAnimatedIn = true
            labelInAnimator = createLabelAnimator(true)
            labelOutAnimator = null
            labelInAnimator?.start()
        }
        val value = scrubPosition.toFloat() / duration.toFloat()
        setValueForLabel(label, value)
    }
    private fun ensureLabelRemoved() {
        if (labelAreAnimatedIn) {
            labelAreAnimatedIn = false
            labelOutAnimator = createLabelAnimator(false)
            labelInAnimator = null
            labelOutAnimator?.addListener(
                object : AnimatorListenerAdapter() {
                    override fun onAnimationEnd(animation: Animator) {
                        super.onAnimationEnd(animation)
                        overlay.remove(label)
                    }
                })
            labelOutAnimator?.start()
        }
    }
    private fun normalizeValue(value: Float): Float {
        val normalized = (value - valueFrom) / (valueTo - valueFrom)
        return if (context.resources.configuration.isRtl) 1 - normalized else normalized
    }
    private fun setValueForLabel(label: TooltipDrawable, value: Float) {
        var left =
            (scrubberPadding + normalizeValue(value) * (trackWidth - 2 * scrubberPadding)).toInt() - label.intrinsicWidth / 2
        left = clamp(
            left,
            2 * scrubberPadding - label.intrinsicWidth / 2,
            trackWidth - 2 * scrubberPadding - label.intrinsicWidth / 2
        )
        val top = widgetHeight / 2 - (labelPadding + thumbRadius)
        label.setBounds(left, top - label.intrinsicHeight, left + label.intrinsicWidth, top)
        val rect = Rect(label.bounds)
        DescendantOffsetUtils.offsetDescendantRect(ViewUtils.getContentView(this)!!, this, rect)
        label.bounds = rect
        ViewUtils.getContentViewOverlay(this)?.add(label)
    }
    companion object {
        const val valueFrom = 0F
        const val valueTo = 1F
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/DefaultTimeBar.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video.customexo;
import android.animation.ValueAnimator;
import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
import androidx.annotation.ColorInt;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.media3.common.C;
import androidx.media3.common.util.Assertions;
import androidx.media3.common.util.UnstableApi;
import androidx.media3.common.util.Util;
import androidx.media3.ui.R;
import androidx.media3.ui.TimeBar;
import java.util.Collections;
import java.util.Formatter;
import java.util.Locale;
import java.util.concurrent.CopyOnWriteArraySet;
@UnstableApi
public class DefaultTimeBar extends View implements TimeBar {
  public static final int DEFAULT_BAR_HEIGHT_DP = 4;
  public static final int DEFAULT_TOUCH_TARGET_HEIGHT_DP = 26;
  public static final int DEFAULT_AD_MARKER_WIDTH_DP = 4;
  public static final int DEFAULT_SCRUBBER_ENABLED_SIZE_DP = 12;
  public static final int DEFAULT_SCRUBBER_DISABLED_SIZE_DP = 0;
  public static final int DEFAULT_SCRUBBER_DRAGGED_SIZE_DP = 16;
  public static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
  public static final int DEFAULT_UNPLAYED_COLOR = 0x33FFFFFF;
  public static final int DEFAULT_BUFFERED_COLOR = 0xCCFFFFFF;
  public static final int DEFAULT_SCRUBBER_COLOR = 0xFFFFFFFF;
  public static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
  public static final int DEFAULT_PLAYED_AD_MARKER_COLOR = 0x33FFFF00;
  public static final int BAR_GRAVITY_CENTER = 0;
  public static final int BAR_GRAVITY_BOTTOM = 1;
  protected static final int FINE_SCRUB_Y_THRESHOLD_DP = -50;
  protected static final int FINE_SCRUB_RATIO = 3;
  protected static final long STOP_SCRUBBING_TIMEOUT_MS = 1000;
  protected static final int DEFAULT_INCREMENT_COUNT = 20;
  protected static final float SHOWN_SCRUBBER_SCALE = 1.0f;
  protected static final float HIDDEN_SCRUBBER_SCALE = 0.0f;
  protected static final String ACCESSIBILITY_CLASS_NAME = "android.widget.SeekBar";
  protected final Rect seekBounds;
  protected final Rect progressBar;
  protected final Rect bufferedBar;
  protected final Rect scrubberBar;
  protected final Paint playedPaint;
  protected final Paint bufferedPaint;
  protected final Paint unplayedPaint;
  protected final Paint adMarkerPaint;
  protected final Paint playedAdMarkerPaint;
  protected final Paint scrubberPaint;
  @Nullable
  protected final Drawable scrubberDrawable;
  protected final int barHeight;
  protected final int touchTargetHeight;
  protected final int barGravity;
  protected final int adMarkerWidth;
  protected final int scrubberEnabledSize;
  protected final int scrubberDisabledSize;
  protected final int scrubberDraggedSize;
  protected final int scrubberPadding;
  protected final int fineScrubYThreshold;
  protected final StringBuilder formatBuilder;
  protected final Formatter formatter;
  protected final Runnable stopScrubbingRunnable;
  protected final CopyOnWriteArraySet<OnScrubListener> listeners;
  protected final Point touchPosition;
  protected final float density;
  protected int keyCountIncrement;
  protected long keyTimeIncrement;
  protected int lastCoarseScrubXPosition;
  protected Rect lastExclusionRectangle;
  protected ValueAnimator scrubberScalingAnimator;
  protected float scrubberScale;
  protected boolean scrubberPaddingDisabled;
  protected boolean scrubbing;
  protected long scrubPosition;
  protected long duration;
  protected long position;
  protected long bufferedPosition;
  protected int adGroupCount;
  @Nullable
  protected long[] adGroupTimesMs;
  @Nullable
  protected boolean[] playedAdGroups;
  public DefaultTimeBar(Context context) {
    this(context, null);
  }
  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs) {
    this(context, attrs, 0);
  }
  public DefaultTimeBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    this(context, attrs, defStyleAttr, attrs);
  }
  public DefaultTimeBar(
          Context context,
          @Nullable AttributeSet attrs,
          int defStyleAttr,
          @Nullable AttributeSet timebarAttrs) {
    this(context, attrs, defStyleAttr, timebarAttrs, 0);
  }
  @SuppressWarnings("nullness:method.invocation")
  public DefaultTimeBar(
          Context context,
          @Nullable AttributeSet attrs,
          int defStyleAttr,
          @Nullable AttributeSet timebarAttrs,
          int defStyleRes) {
    super(context, attrs, defStyleAttr);
    seekBounds = new Rect();
    progressBar = new Rect();
    bufferedBar = new Rect();
    scrubberBar = new Rect();
    playedPaint = new Paint();
    bufferedPaint = new Paint();
    unplayedPaint = new Paint();
    adMarkerPaint = new Paint();
    playedAdMarkerPaint = new Paint();
    scrubberPaint = new Paint();
    scrubberPaint.setAntiAlias(true);
    listeners = new CopyOnWriteArraySet<>();
    touchPosition = new Point();
    Resources res = context.getResources();
    DisplayMetrics displayMetrics = res.getDisplayMetrics();
    density = displayMetrics.density;
    fineScrubYThreshold = dpToPx(density, FINE_SCRUB_Y_THRESHOLD_DP);
    int defaultBarHeight = dpToPx(density, DEFAULT_BAR_HEIGHT_DP);
    int defaultTouchTargetHeight = dpToPx(density, DEFAULT_TOUCH_TARGET_HEIGHT_DP);
    int defaultAdMarkerWidth = dpToPx(density, DEFAULT_AD_MARKER_WIDTH_DP);
    int defaultScrubberEnabledSize = dpToPx(density, DEFAULT_SCRUBBER_ENABLED_SIZE_DP);
    int defaultScrubberDisabledSize = dpToPx(density, DEFAULT_SCRUBBER_DISABLED_SIZE_DP);
    int defaultScrubberDraggedSize = dpToPx(density, DEFAULT_SCRUBBER_DRAGGED_SIZE_DP);
    if (timebarAttrs != null) {
      TypedArray a =
              context
                      .getTheme()
                      .obtainStyledAttributes(
                              timebarAttrs, R.styleable.DefaultTimeBar, defStyleAttr, defStyleRes);
      try {
        scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
        if (scrubberDrawable != null) {
          setDrawableLayoutDirection(scrubberDrawable);
          defaultTouchTargetHeight =
                  Math.max(scrubberDrawable.getMinimumHeight(), defaultTouchTargetHeight);
        }
        barHeight =
                a.getDimensionPixelSize(R.styleable.DefaultTimeBar_bar_height, defaultBarHeight);
        touchTargetHeight =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_touch_target_height, defaultTouchTargetHeight);
        barGravity = a.getInt(R.styleable.DefaultTimeBar_bar_gravity, BAR_GRAVITY_CENTER);
        adMarkerWidth =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_ad_marker_width, defaultAdMarkerWidth);
        scrubberEnabledSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_enabled_size, defaultScrubberEnabledSize);
        scrubberDisabledSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_disabled_size, defaultScrubberDisabledSize);
        scrubberDraggedSize =
                a.getDimensionPixelSize(
                        R.styleable.DefaultTimeBar_scrubber_dragged_size, defaultScrubberDraggedSize);
        int playedColor = a.getInt(R.styleable.DefaultTimeBar_played_color, DEFAULT_PLAYED_COLOR);
        int scrubberColor =
                a.getInt(R.styleable.DefaultTimeBar_scrubber_color, DEFAULT_SCRUBBER_COLOR);
        int bufferedColor =
                a.getInt(R.styleable.DefaultTimeBar_buffered_color, DEFAULT_BUFFERED_COLOR);
        int unplayedColor =
                a.getInt(R.styleable.DefaultTimeBar_unplayed_color, DEFAULT_UNPLAYED_COLOR);
        int adMarkerColor =
                a.getInt(R.styleable.DefaultTimeBar_ad_marker_color, DEFAULT_AD_MARKER_COLOR);
        int playedAdMarkerColor =
                a.getInt(
                        R.styleable.DefaultTimeBar_played_ad_marker_color, DEFAULT_PLAYED_AD_MARKER_COLOR);
        playedPaint.setColor(playedColor);
        scrubberPaint.setColor(scrubberColor);
        bufferedPaint.setColor(bufferedColor);
        unplayedPaint.setColor(unplayedColor);
        adMarkerPaint.setColor(adMarkerColor);
        playedAdMarkerPaint.setColor(playedAdMarkerColor);
      } finally {
        a.recycle();
      }
    } else {
      barHeight = defaultBarHeight;
      touchTargetHeight = defaultTouchTargetHeight;
      barGravity = BAR_GRAVITY_CENTER;
      adMarkerWidth = defaultAdMarkerWidth;
      scrubberEnabledSize = defaultScrubberEnabledSize;
      scrubberDisabledSize = defaultScrubberDisabledSize;
      scrubberDraggedSize = defaultScrubberDraggedSize;
      playedPaint.setColor(DEFAULT_PLAYED_COLOR);
      scrubberPaint.setColor(DEFAULT_SCRUBBER_COLOR);
      bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
      unplayedPaint.setColor(DEFAULT_UNPLAYED_COLOR);
      adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
      playedAdMarkerPaint.setColor(DEFAULT_PLAYED_AD_MARKER_COLOR);
      scrubberDrawable = null;
    }
    formatBuilder = new StringBuilder();
    formatter = new Formatter(formatBuilder, Locale.getDefault());
    stopScrubbingRunnable = () -> stopScrubbing( false);
    if (scrubberDrawable != null) {
      scrubberPadding = (scrubberDrawable.getMinimumWidth() + 1) / 2;
    } else {
      scrubberPadding =
              (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)
                      / 2;
    }
    scrubberScale = 1.0f;
    scrubberScalingAnimator = new ValueAnimator();
    scrubberScalingAnimator.addUpdateListener(
            animation -> {
              scrubberScale = (float) animation.getAnimatedValue();
              invalidate(seekBounds);
            });
    duration = C.TIME_UNSET;
    keyTimeIncrement = C.TIME_UNSET;
    keyCountIncrement = DEFAULT_INCREMENT_COUNT;
    setFocusable(true);
    if (getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
      setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
  }
  public void showScrubber() {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = false;
    scrubberScale = 1;
    invalidate(seekBounds);
  }
  public void showScrubber(long showAnimationDurationMs) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = false;
    scrubberScalingAnimator.setFloatValues(scrubberScale, SHOWN_SCRUBBER_SCALE);
    scrubberScalingAnimator.setDuration(showAnimationDurationMs);
    scrubberScalingAnimator.start();
  }
  public void hideScrubber(boolean disableScrubberPadding) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberPaddingDisabled = disableScrubberPadding;
    scrubberScale = 0;
    invalidate(seekBounds);
  }
  public void hideScrubber(long hideAnimationDurationMs) {
    if (scrubberScalingAnimator.isStarted()) {
      scrubberScalingAnimator.cancel();
    }
    scrubberScalingAnimator.setFloatValues(scrubberScale, HIDDEN_SCRUBBER_SCALE);
    scrubberScalingAnimator.setDuration(hideAnimationDurationMs);
    scrubberScalingAnimator.start();
  }
  public void setPlayedColor(@ColorInt int playedColor) {
    playedPaint.setColor(playedColor);
    invalidate(seekBounds);
  }
  public void setScrubberColor(@ColorInt int scrubberColor) {
    scrubberPaint.setColor(scrubberColor);
    invalidate(seekBounds);
  }
  public void setBufferedColor(@ColorInt int bufferedColor) {
    bufferedPaint.setColor(bufferedColor);
    invalidate(seekBounds);
  }
  public void setUnplayedColor(@ColorInt int unplayedColor) {
    unplayedPaint.setColor(unplayedColor);
    invalidate(seekBounds);
  }
  public void setAdMarkerColor(@ColorInt int adMarkerColor) {
    adMarkerPaint.setColor(adMarkerColor);
    invalidate(seekBounds);
  }
  public void setPlayedAdMarkerColor(@ColorInt int playedAdMarkerColor) {
    playedAdMarkerPaint.setColor(playedAdMarkerColor);
    invalidate(seekBounds);
  }
  @Override
  public void addListener(OnScrubListener listener) {
    Assertions.checkNotNull(listener);
    listeners.add(listener);
  }
  @Override
  public void removeListener(OnScrubListener listener) {
    listeners.remove(listener);
  }
  @Override
  public void setKeyTimeIncrement(long time) {
    Assertions.checkArgument(time > 0);
    keyCountIncrement = C.INDEX_UNSET;
    keyTimeIncrement = time;
  }
  @Override
  public void setKeyCountIncrement(int count) {
    Assertions.checkArgument(count > 0);
    keyCountIncrement = count;
    keyTimeIncrement = C.TIME_UNSET;
  }
  @Override
  public void setPosition(long position) {
    if (this.position == position) {
      return;
    }
    this.position = position;
    setContentDescription(getProgressText());
    update();
  }
  @Override
  public void setBufferedPosition(long bufferedPosition) {
    if (this.bufferedPosition == bufferedPosition) {
      return;
    }
    this.bufferedPosition = bufferedPosition;
    update();
  }
  @Override
  public void setDuration(long duration) {
    if (this.duration == duration) {
      return;
    }
    this.duration = duration;
    if (scrubbing && duration == C.TIME_UNSET) {
      stopScrubbing( true);
    }
    update();
  }
  @Override
  public long getPreferredUpdateDelay() {
    int timeBarWidthDp = pxToDp(density, progressBar.width());
    return timeBarWidthDp == 0 || duration == 0 || duration == C.TIME_UNSET
            ? Long.MAX_VALUE
            : duration / timeBarWidthDp;
  }
  @Override
  public void setAdGroupTimesMs(
          @Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups, int adGroupCount) {
    Assertions.checkArgument(
            adGroupCount == 0 || (adGroupTimesMs != null && playedAdGroups != null));
    this.adGroupCount = adGroupCount;
    this.adGroupTimesMs = adGroupTimesMs;
    this.playedAdGroups = playedAdGroups;
    update();
  }
  @Override
  public void setEnabled(boolean enabled) {
    super.setEnabled(enabled);
    if (scrubbing && !enabled) {
      stopScrubbing( true);
    }
  }
  @Override
  public void onDraw(Canvas canvas) {
    canvas.save();
    drawTimeBar(canvas);
    drawPlayhead(canvas);
    canvas.restore();
  }
  @Override
  public boolean onTouchEvent(MotionEvent event) {
    if (!isEnabled() || duration <= 0) {
      return false;
    }
    Point touchPosition = resolveRelativeTouchPosition(event);
    int x = touchPosition.x;
    int y = touchPosition.y;
    switch (event.getAction()) {
      case MotionEvent.ACTION_DOWN:
        if (isInSeekBar(x, y)) {
          positionScrubber(x);
          startScrubbing(getScrubberPosition());
          update();
          invalidate();
          return true;
        }
        break;
      case MotionEvent.ACTION_MOVE:
        if (scrubbing) {
          if (y < fineScrubYThreshold) {
            int relativeX = x - lastCoarseScrubXPosition;
            positionScrubber(lastCoarseScrubXPosition + relativeX / FINE_SCRUB_RATIO);
          } else {
            lastCoarseScrubXPosition = x;
            positionScrubber(x);
          }
          updateScrubbing(getScrubberPosition());
          update();
          invalidate();
          return true;
        }
        break;
      case MotionEvent.ACTION_UP:
      case MotionEvent.ACTION_CANCEL:
        if (scrubbing) {
          stopScrubbing( event.getAction() == MotionEvent.ACTION_CANCEL);
          return true;
        }
        break;
      default:
    }
    return false;
  }
  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (isEnabled()) {
      long positionIncrement = getPositionIncrement();
      switch (keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
          positionIncrement = -positionIncrement;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
          if (scrubIncrementally(positionIncrement)) {
            removeCallbacks(stopScrubbingRunnable);
            postDelayed(stopScrubbingRunnable, STOP_SCRUBBING_TIMEOUT_MS);
            return true;
          }
          break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
          if (scrubbing) {
            stopScrubbing( false);
            return true;
          }
          break;
        default:
      }
    }
    return super.onKeyDown(keyCode, event);
  }
  @Override
  protected void onFocusChanged(
          boolean gainFocus, int direction, @Nullable Rect previouslyFocusedRect) {
    super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
    if (scrubbing && !gainFocus) {
      stopScrubbing( false);
    }
  }
  @Override
  protected void drawableStateChanged() {
    super.drawableStateChanged();
    updateDrawableState();
  }
  @Override
  public void jumpDrawablesToCurrentState() {
    super.jumpDrawablesToCurrentState();
    if (scrubberDrawable != null) {
      scrubberDrawable.jumpToCurrentState();
    }
  }
  @Override
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int height =
            heightMode == MeasureSpec.UNSPECIFIED
                    ? touchTargetHeight
                    : heightMode == MeasureSpec.EXACTLY
                    ? heightSize
                    : Math.min(touchTargetHeight, heightSize);
    setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
    updateDrawableState();
  }
  @Override
  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    int width = right - left;
    int height = bottom - top;
    int seekLeft = getPaddingLeft();
    int seekRight = width - getPaddingRight();
    int seekBoundsY;
    int progressBarY;
    int scrubberPadding = scrubberPaddingDisabled ? 0 : this.scrubberPadding;
    if (barGravity == BAR_GRAVITY_BOTTOM) {
      seekBoundsY = height - getPaddingBottom() - touchTargetHeight;
      progressBarY =
              height - getPaddingBottom() - barHeight - Math.max(scrubberPadding - (barHeight / 2), 0);
    } else {
      seekBoundsY = (height - touchTargetHeight) / 2;
      progressBarY = (height - barHeight) / 2;
    }
    seekBounds.set(seekLeft, seekBoundsY, seekRight, seekBoundsY + touchTargetHeight);
    progressBar.set(
            seekBounds.left + scrubberPadding,
            progressBarY,
            seekBounds.right - scrubberPadding,
            progressBarY + barHeight);
    if (Util.SDK_INT >= 29) {
      setSystemGestureExclusionRectsV29(width, height);
    }
    update();
  }
  @Override
  public void onRtlPropertiesChanged(int layoutDirection) {
    if (scrubberDrawable != null && setDrawableLayoutDirection(scrubberDrawable, layoutDirection)) {
      invalidate();
    }
  }
  @Override
  public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
    super.onInitializeAccessibilityEvent(event);
    if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SELECTED) {
      event.getText().add(getProgressText());
    }
    event.setClassName(ACCESSIBILITY_CLASS_NAME);
  }
  @Override
  public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
    super.onInitializeAccessibilityNodeInfo(info);
    info.setClassName(ACCESSIBILITY_CLASS_NAME);
    info.setContentDescription(getProgressText());
    if (duration <= 0) {
      return;
    }
    if (Util.SDK_INT >= 21) {
      info.addAction(AccessibilityAction.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityAction.ACTION_SCROLL_BACKWARD);
    } else {
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
    }
  }
  @Override
  public boolean performAccessibilityAction(int action, @Nullable Bundle args) {
    if (super.performAccessibilityAction(action, args)) {
      return true;
    }
    if (duration <= 0) {
      return false;
    }
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
      if (scrubIncrementally(-getPositionIncrement())) {
        stopScrubbing( false);
      }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
      if (scrubIncrementally(getPositionIncrement())) {
        stopScrubbing( false);
      }
    } else {
      return false;
    }
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    return true;
  }
  protected void startScrubbing(long scrubPosition) {
    this.scrubPosition = scrubPosition;
    scrubbing = true;
    setPressed(true);
    ViewParent parent = getParent();
    if (parent != null) {
      parent.requestDisallowInterceptTouchEvent(true);
    }
    for (OnScrubListener listener : listeners) {
      listener.onScrubStart(this, scrubPosition);
    }
  }
  protected void updateScrubbing(long scrubPosition) {
    if (this.scrubPosition == scrubPosition) {
      return;
    }
    this.scrubPosition = scrubPosition;
    for (OnScrubListener listener : listeners) {
      listener.onScrubMove(this, scrubPosition);
    }
  }
  protected void stopScrubbing(boolean canceled) {
    removeCallbacks(stopScrubbingRunnable);
    scrubbing = false;
    setPressed(false);
    ViewParent parent = getParent();
    if (parent != null) {
      parent.requestDisallowInterceptTouchEvent(false);
    }
    invalidate();
    for (OnScrubListener listener : listeners) {
      listener.onScrubStop(this, scrubPosition, canceled);
    }
  }
  protected boolean scrubIncrementally(long positionChange) {
    if (duration <= 0) {
      return false;
    }
    long previousPosition = scrubbing ? scrubPosition : position;
    long scrubPosition = Util.constrainValue(previousPosition + positionChange, 0, duration);
    if (scrubPosition == previousPosition) {
      return false;
    }
    if (!scrubbing) {
      startScrubbing(scrubPosition);
    } else {
      updateScrubbing(scrubPosition);
    }
    update();
    return true;
  }
  protected void update() {
    bufferedBar.set(progressBar);
    scrubberBar.set(progressBar);
    long newScrubberTime = scrubbing ? scrubPosition : position;
    if (duration > 0) {
      int bufferedPixelWidth = (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right);
      int scrubberPixelPosition = (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right);
    } else {
      bufferedBar.right = progressBar.left;
      scrubberBar.right = progressBar.left;
    }
    invalidate(seekBounds);
  }
  protected void positionScrubber(float xPosition) {
    scrubberBar.right = Util.constrainValue((int) xPosition, progressBar.left, progressBar.right);
  }
  protected Point resolveRelativeTouchPosition(MotionEvent motionEvent) {
    touchPosition.set((int) motionEvent.getX(), (int) motionEvent.getY());
    return touchPosition;
  }
  protected long getScrubberPosition() {
    if (progressBar.width() <= 0 || duration == C.TIME_UNSET) {
      return 0;
    }
    return (scrubberBar.width() * duration) / progressBar.width();
  }
  protected boolean isInSeekBar(float x, float y) {
    return seekBounds.contains((int) x, (int) y);
  }
  protected void drawTimeBar(Canvas canvas) {
    int progressBarHeight = progressBar.height();
    int barTop = progressBar.centerY() - progressBarHeight / 2;
    int barBottom = barTop + progressBarHeight;
    if (duration <= 0) {
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, unplayedPaint);
      return;
    }
    int bufferedLeft = bufferedBar.left;
    int bufferedRight = bufferedBar.right;
    int progressLeft = Math.max(Math.max(progressBar.left, bufferedRight), scrubberBar.right);
    if (progressLeft < progressBar.right) {
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, unplayedPaint);
    }
    bufferedLeft = Math.max(bufferedLeft, scrubberBar.right);
    if (bufferedRight > bufferedLeft) {
      canvas.drawRect(bufferedLeft, barTop, bufferedRight, barBottom, bufferedPaint);
    }
    if (scrubberBar.width() > 0) {
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
    }
    if (adGroupCount == 0) {
      return;
    }
    long[] adGroupTimesMs = Assertions.checkNotNull(this.adGroupTimesMs);
    boolean[] playedAdGroups = Assertions.checkNotNull(this.playedAdGroups);
    int adMarkerOffset = adMarkerWidth / 2;
    for (int i = 0; i < adGroupCount; i++) {
      long adGroupTimeMs = Util.constrainValue(adGroupTimesMs[i], 0, duration);
      int markerPositionOffset =
              (int) (progressBar.width() * adGroupTimeMs / duration) - adMarkerOffset;
      int markerLeft =
              progressBar.left
                      + Math.min(progressBar.width() - adMarkerWidth, Math.max(0, markerPositionOffset));
      Paint paint = playedAdGroups[i] ? playedAdMarkerPaint : adMarkerPaint;
      canvas.drawRect(markerLeft, barTop, markerLeft + adMarkerWidth, barBottom, paint);
    }
  }
  protected void drawPlayhead(Canvas canvas) {
    if (duration <= 0) {
      return;
    }
    int playheadX = Util.constrainValue(scrubberBar.right, scrubberBar.left, progressBar.right);
    int playheadY = scrubberBar.centerY();
    if (scrubberDrawable == null) {
      int scrubberSize =
              (scrubbing || isFocused())
                      ? scrubberDraggedSize
                      : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
      int playheadRadius = (int) ((scrubberSize * scrubberScale) / 2);
      canvas.drawCircle(playheadX, playheadY, playheadRadius, scrubberPaint);
    } else {
      int scrubberDrawableWidth = (int) (scrubberDrawable.getIntrinsicWidth() * scrubberScale);
      int scrubberDrawableHeight = (int) (scrubberDrawable.getIntrinsicHeight() * scrubberScale);
      scrubberDrawable.setBounds(
              playheadX - scrubberDrawableWidth / 2,
              playheadY - scrubberDrawableHeight / 2,
              playheadX + scrubberDrawableWidth / 2,
              playheadY + scrubberDrawableHeight / 2);
      scrubberDrawable.draw(canvas);
    }
  }
  protected void updateDrawableState() {
    if (scrubberDrawable != null
            && scrubberDrawable.isStateful()
            && scrubberDrawable.setState(getDrawableState())) {
      invalidate();
    }
  }
  @RequiresApi(29)
  protected void setSystemGestureExclusionRectsV29(int width, int height) {
    if (lastExclusionRectangle != null
            && lastExclusionRectangle.width() == width
            && lastExclusionRectangle.height() == height) {
      return;
    }
    lastExclusionRectangle = new Rect( 0,  0, width, height);
    setSystemGestureExclusionRects(Collections.singletonList(lastExclusionRectangle));
  }
  protected String getProgressText() {
    return Util.getStringForTime(formatBuilder, formatter, position);
  }
  protected long getPositionIncrement() {
    return keyTimeIncrement == C.TIME_UNSET
            ? (duration == C.TIME_UNSET ? 0 : (duration / keyCountIncrement))
            : keyTimeIncrement;
  }
  protected boolean setDrawableLayoutDirection(Drawable drawable) {
    return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, getLayoutDirection());
  }
  protected static boolean setDrawableLayoutDirection(Drawable drawable, int layoutDirection) {
    return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection);
  }
  protected static int dpToPx(float density, int dps) {
    return (int) (dps * density + 0.5f);
  }
  protected static int pxToDp(float density, int px) {
    return (int) (px / density);
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/mediastore/video/customexo/VideoGestureDetector.java
================================================
```
package me.gm.cleaner.plugin.ui.mediastore.video.customexo;
import android.content.Context;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ViewConfiguration;
import androidx.annotation.NonNull;
public class VideoGestureDetector {
    private final OnVideoGestureListener mListener;
    private final GestureDetector mDetector;
    private boolean mIsHorizontallyScrubbing;
    private boolean mIsVerticallyScrubbing;
    private final float mTouchSlop;
    private float mLastMotionX;
    private float mLastMotionY;
    private float mInitialMotionX;
    private float mInitialMotionY;
    private int mActivePointerId = INVALID_POINTER;
    private static final int INVALID_POINTER = -1;
    public VideoGestureDetector(@NonNull Context context,
                                @NonNull OnVideoGestureListener listener) {
        final ViewConfiguration configuration = ViewConfiguration.get(context);
        mTouchSlop = configuration.getScaledTouchSlop();
        mListener = listener;
        final GestureDetector.SimpleOnGestureListener onDoubleTapListener
                = new GestureDetector.SimpleOnGestureListener() {
            @Override
            public boolean onSingleTapConfirmed(@NonNull MotionEvent e) {
                return mListener.onSingleTapConfirmed(e);
            }
            @Override
            public boolean onDoubleTap(@NonNull MotionEvent ev) {
                return mListener.onDoubleTap(ev);
            }
        };
        mDetector = new GestureDetector(context, onDoubleTapListener);
    }
    private void resetTouch() {
        mActivePointerId = INVALID_POINTER;
        mIsHorizontallyScrubbing = false;
        mIsVerticallyScrubbing = false;
    }
    private boolean onTouchEventInternal(@NonNull MotionEvent ev) {
        boolean handled = false;
        switch (ev.getActionMasked()) {
            case MotionEvent.ACTION_DOWN: {
                mLastMotionX = mInitialMotionX = ev.getX();
                mLastMotionY = mInitialMotionY = ev.getY();
                mActivePointerId = ev.getPointerId(0);
                break;
            }
            case MotionEvent.ACTION_MOVE: {
                if (!mIsHorizontallyScrubbing && !mIsVerticallyScrubbing) {
                    final int pointerIndex = ev.findPointerIndex(mActivePointerId);
                    if (pointerIndex == -1) {
                        resetTouch();
                        break;
                    }
                    final float x = ev.getX(pointerIndex);
                    final float xDiff = Math.abs(x - mLastMotionX);
                    final float y = ev.getY(pointerIndex);
                    final float yDiff = Math.abs(y - mLastMotionY);
                    if (xDiff > mTouchSlop && xDiff > yDiff) {
                        mLastMotionX = x - mInitialMotionX > 0 ? mInitialMotionX + mTouchSlop :
                                mInitialMotionX - mTouchSlop;
                        mIsHorizontallyScrubbing = true;
                        mListener.onHorizontalScrubStart(mInitialMotionX, mInitialMotionY);
                    } else if (yDiff > mTouchSlop && yDiff > xDiff) {
                        mLastMotionY = y - mInitialMotionY > 0 ? mInitialMotionY + mTouchSlop :
                                mInitialMotionY - mTouchSlop;
                        mIsVerticallyScrubbing = true;
                        mListener.onVerticalScrubStart(mInitialMotionX, mInitialMotionY);
                    }
                }
                if (mIsHorizontallyScrubbing) {
                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                    final float x = ev.getX(activePointerIndex);
                    final float y = ev.getY(activePointerIndex);
                    handled |= mListener.onHorizontalScrubMove(x - mLastMotionX);
                    mLastMotionX = x;
                    mLastMotionY = y;
                }
                if (mIsVerticallyScrubbing) {
                    final int activePointerIndex = ev.findPointerIndex(mActivePointerId);
                    final float x = ev.getX(activePointerIndex);
                    final float y = ev.getY(activePointerIndex);
                    handled |= mListener.onVerticalScrubMove(y - mLastMotionY);
                    mLastMotionX = x;
                    mLastMotionY = y;
                }
                break;
            }
            case MotionEvent.ACTION_POINTER_DOWN: {
                final int index = ev.getActionIndex();
                final float x = ev.getX(index);
                mLastMotionX = x;
                final float y = ev.getY(index);
                mLastMotionY = y;
                mActivePointerId = ev.getPointerId(index);
                break;
            }
            case MotionEvent.ACTION_POINTER_UP: {
                final int pointerIndex = ev.getActionIndex();
                final int pointerId = ev.getPointerId(pointerIndex);
                if (pointerId == mActivePointerId) {
                    final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
                    mLastMotionX = ev.getX(newPointerIndex);
                    mLastMotionY = ev.getY(newPointerIndex);
                    mActivePointerId = ev.getPointerId(newPointerIndex);
                }
                break;
            }
            case MotionEvent.ACTION_CANCEL:
            case MotionEvent.ACTION_UP: {
                if (mIsHorizontallyScrubbing) {
                    handled = true;
                    mListener.onHorizontalScrubEnd();
                }
                if (mIsVerticallyScrubbing) {
                    handled = true;
                    mListener.onVerticalScrubEnd();
                }
                resetTouch();
                break;
            }
        }
        return handled;
    }
    public boolean onTouchEvent(@NonNull MotionEvent ev) {
        mDetector.onTouchEvent(ev);
        return onTouchEventInternal(ev);
    }
    public interface OnVideoGestureListener {
        void onHorizontalScrubStart(float initialMotionX, float initialMotionY);
        boolean onHorizontalScrubMove(float dx);
        void onHorizontalScrubEnd();
        void onVerticalScrubStart(float initialMotionX, float initialMotionY);
        boolean onVerticalScrubMove(float dy);
        void onVerticalScrubEnd();
        boolean onSingleTapConfirmed(@NonNull MotionEvent ev);
        boolean onDoubleTap(@NonNull MotionEvent ev);
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/BinderViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.module
import android.content.pm.PackageInfo
import android.os.IBinder
import android.os.Process
import android.util.SparseArray
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import me.gm.cleaner.plugin.IManagerService
import me.gm.cleaner.plugin.IMediaChangeObserver
import javax.inject.Inject
@HiltViewModel
class BinderViewModel @Inject constructor(private val binder: IBinder?) : ViewModel() {
    private var service: IManagerService? = IManagerService.Stub.asInterface(binder)
    private val _remoteSpCacheLiveData = MutableLiveData(SparseArray<String>())
    val remoteSpCacheLiveData: LiveData<SparseArray<String>>
        get() = _remoteSpCacheLiveData
    val remoteSpCache: SparseArray<String>
        get() = _remoteSpCacheLiveData.value!!
    fun notifyRemoteSpChanged() {
        _remoteSpCacheLiveData.postValue(remoteSpCache)
    }
    fun pingBinder() = binder?.pingBinder() == true
    val moduleVersion: Int
        get() = service!!.moduleVersion
    fun getInstalledPackages(flags: Int): List<PackageInfo> =
        service!!.getInstalledPackages(Process.myUid() / AID_USER_OFFSET, flags).list
    fun getPackageInfo(packageName: String): PackageInfo? =
        service!!.getPackageInfo(packageName, 0, Process.myUid() / AID_USER_OFFSET)
    fun readSp(who: Int): String? =
        remoteSpCache[who, service!!.readSp(who).also { remoteSpCache.put(who, it) }]
    fun writeSp(who: Int, what: String) {
        if (remoteSpCache[who] != what) {
            service!!.writeSp(who, what)
            remoteSpCache.put(who, what)
            notifyRemoteSpChanged()
        }
    }
    fun clearAllTables() {
        service!!.clearAllTables()
    }
    fun packageUsageTimes(operation: Int, packageNames: List<String>): Int =
        service!!.packageUsageTimes(operation, packageNames)
    fun registerMediaChangeObserver(observer: IMediaChangeObserver) {
        service!!.registerMediaChangeObserver(observer)
    }
    fun unregisterMediaChangeObserver(observer: IMediaChangeObserver) {
        service!!.unregisterMediaChangeObserver(observer)
    }
    companion object {
        const val AID_USER_OFFSET = 100000
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/ModuleFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import me.gm.cleaner.plugin.app.BaseFragment
import me.gm.cleaner.plugin.databinding.ModuleFragmentBinding
abstract class ModuleFragment : BaseFragment() {
    val binderViewModel: BinderViewModel by activityViewModels()
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        check(!binderViewModel.pingBinder())
        val binding = ModuleFragmentBinding.inflate(layoutInflater)
        return binding.root
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppAdapters.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.annotation.SuppressLint
import android.content.Intent
import android.net.Uri
import android.provider.Settings
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.forEach
import androidx.core.view.isVisible
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.transition.platform.Hold
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.databinding.AppHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesItemBinding
import me.gm.cleaner.plugin.ktx.DividerViewHolder
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.settings.CreateTemplateFragment
class AppHeaderAdapter(private val fragment: AppFragment) :
    RecyclerView.Adapter<AppHeaderAdapter.ViewHolder>() {
    private val args: AppFragmentArgs by fragment.navArgs()
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(AppHeaderBinding.inflate(LayoutInflater.from(parent.context)))
    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        Glide.with(fragment)
            .load(args.packageInfo)
            .into(binding.icon)
        binding.labelVersion.text = "${args.label} ${args.packageInfo.versionName}"
        binding.packageName.text = args.packageInfo.packageName
        binding.sdk.text = "SDK ${args.packageInfo.applicationInfo.targetSdkVersion}"
        binding.sdk.setOnClickListener {
            val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = Uri.fromParts("package", args.packageInfo.packageName, null)
            }
            fragment.startActivity(intent)
        }
        val usageTimes = arrayOf(
            OP_QUERY to R.string.query_times,
            OP_INSERT to R.string.insert_times,
            OP_DELETE to R.string.delete_times,
        ).mapNotNull { (op, resId) ->
            val packageUsageTimes = fragment.binderViewModel.packageUsageTimes(
                op, listOf(args.packageInfo.packageName)
            )
            if (packageUsageTimes == 0) {
                null
            } else {
                fragment.getString(resId, packageUsageTimes)
            }
        }
        if (usageTimes.isNotEmpty()) {
            binding.usageTimes.isVisible = true
            binding.usageTimes.text = usageTimes.joinToString(
                fragment.getString(R.string.delimiter)
            )
        }
    }
    override fun getItemCount(): Int = 1
    class ViewHolder(val binding: AppHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedBelow = true
        }
    }
}
class TemplatesAdapter(private val fragment: AppFragment) :
    ListAdapter<Template, TemplatesAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesItemBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = templateName
        binding.summary.text = fragment.getString(
            R.string.applied_app_count, item.applyToApp?.size ?: 0
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.app_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = templateName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)
            val direction = AppFragmentDirections.actionAppToCreateTemplate(templateName)
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            activity.menuInflater.inflate(R.menu.app_item, menu)
            menu.setHeaderTitle(templateName)
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    when (item.itemId) {
                        R.id.menu_remove_from_template -> {
                            val modified =
                                Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                    .values.toMutableList()
                            val oldTemplateIndex =
                                modified.indexOfFirst { it.templateName == templateName }
                            val oldTemplate = modified[oldTemplateIndex]
                            modified[oldTemplateIndex] = oldTemplate.copy(
                                applyToApp = (oldTemplate.applyToApp ?: emptyList()) -
                                        fragment.args.packageInfo.packageName
                            )
                            fragment.binderViewModel.writeSp(
                                R.xml.template_preferences, Gson().toJson(modified)
                            )
                            true
                        }
                        R.id.menu_delete -> {
                            val modified =
                                Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                    .values.filterNot { it.templateName == templateName }
                            fragment.binderViewModel.writeSp(
                                R.xml.template_preferences, Gson().toJson(modified)
                            )
                            true
                        }
                        else -> {
                            false
                        }
                    }
                }
            }
        }
        holder.isDividerAllowedBelow = position == itemCount - 1
        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }
    class ViewHolder(val binding: TemplatesItemBinding) : DividerViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName
            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}
class CreateTemplateAdapter(private val fragment: AppFragment) :
    RecyclerView.Adapter<CreateTemplateAdapter.ViewHolder>() {
    private val args: AppFragmentArgs by fragment.navArgs()
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        binding.root.transitionName = args.label
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.app_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = args.label
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)
            val direction = AppFragmentDirections.actionAppToCreateTemplate(
                templateName = args.label,
                packageNames = arrayOf(args.packageInfo.packageName),
            )
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        if (fragment.lastTemplateName == CreateTemplateFragment.NULL_TEMPLATE_NAME) {
            fragment.startPostponedEnterTransition()
        }
    }
    override fun getItemCount(): Int = 1
    class ViewHolder(val binding: TemplatesHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedAbove = true
        }
    }
}
class AddToExistingTemplateAdapter(private val fragment: AppFragment) :
    ListAdapter<Template, AddToExistingTemplateAdapter.ViewHolder>(CALLBACK) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = fragment.getString(
            R.string.add_to_existing_template_title, templateName
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val modified = Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                .values.toMutableList()
            val oldTemplateIndex = modified.indexOfFirst { it.templateName == templateName }
            val oldTemplate = modified[oldTemplateIndex]
            modified[oldTemplateIndex] = oldTemplate.copy(
                applyToApp = mutableListOf(fragment.args.packageInfo.packageName) +
                        (oldTemplate.applyToApp ?: emptyList())
            )
            fragment.binderViewModel.writeSp(
                R.xml.template_preferences, Gson().toJson(modified)
            )
        }
        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }
    class ViewHolder(val binding: TemplatesHeaderBinding) : RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName
            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.app.SharedElementCallback
import androidx.core.os.bundleOf
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.setFragmentResultListener
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs
import androidx.recyclerview.widget.ConcatAdapter
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.MaterialContainerTransform
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.AppFragmentBinding
import me.gm.cleaner.plugin.ktx.DividerDecoration
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.isItemCompletelyInvisible
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.ui.module.settings.CreateTemplateFragment
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
class AppFragment : ModuleFragment() {
    val args: AppFragmentArgs by navArgs()
    var lastTemplateName: String? = null
    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = AppFragmentBinding.inflate(layoutInflater)
        val templatesAdapter = TemplatesAdapter(this)
        val createTemplateAdapter = CreateTemplateAdapter(this)
        val addToExistingTemplateAdapter = AddToExistingTemplateAdapter(this)
        val adapters = ConcatAdapter(
            AppHeaderAdapter(this),
            templatesAdapter,
            createTemplateAdapter,
            addToExistingTemplateAdapter
        )
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapters
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                super.onScrolled(recyclerView, dx, dy)
                supportActionBar?.title = if (recyclerView.isItemCompletelyInvisible(0)) {
                    args.label
                } else {
                    findNavController().currentDestination?.label
                }
            }
        })
        binding.root.fitsSystemWindowInsets()
        list.setOnApplyWindowInsetsListener { view, insets ->
            view.setPadding(
                view.paddingLeft, view.paddingTop,
                view.paddingRight, view.paddingBottom + insets.systemWindowInsetBottom
            )
            insets
        }
        list.addItemDecoration(DividerDecoration(list).apply {
            setDivider(resources.getDrawable(R.drawable.list_divider_material, null))
            setAllowDividerAfterLastItem(false)
        })
        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            val currentList = prepareCurrentList()
            templatesAdapter.submitList(currentList.first)
            addToExistingTemplateAdapter.submitList(currentList.second)
            if (currentList.first.any { it.templateName == args.label }) {
                adapters.removeAdapter(createTemplateAdapter)
            } else {
                adapters.addAdapter(
                    adapters.adapters.indexOfFirst { it is TemplatesAdapter } + 1,
                    createTemplateAdapter
                )
            }
        }
        prepareSharedElementTransition(list)
        setFragmentResultListener(CreateTemplateFragment::class.java.name) { _, bundle ->
            lastTemplateName = bundle.getString(CreateTemplateFragment.KEY_TEMPLATE_NAME)
            val currentList = prepareCurrentList()
            var position = 1 +
                    currentList.first.indexOfFirst { it.templateName == lastTemplateName }
            if (position == 0) {
                position = 1 + currentList.first.size + 1 +
                        currentList.second.indexOfFirst { it.templateName == lastTemplateName }
            }
            prepareTransitions(list, position)
            postponeEnterTransition()
            scrollToPosition(list, position)
        }
        return binding.root
    }
    private fun prepareCurrentList(): Pair<List<Template>, List<Template>> =
        Templates(binderViewModel.readSp(R.xml.template_preferences)).values
            .sortedWith(collatorComparator { it.templateName })
            .partition { it.applyToApp?.contains(args.packageInfo.packageName) == true }
    private fun prepareTransitions(list: RecyclerView, position: Int) {
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val selectedViewHolder = list.findViewHolderForAdapterPosition(position) ?: return
                sharedElements[names[0]] = selectedViewHolder.itemView
            }
        })
    }
    private fun prepareSharedElementTransition(list: RecyclerView) {
        setFragmentResult(
            AppFragment::class.java.name, bundleOf(KEY_PACKAGENAME to args.packageInfo.packageName)
        )
        list.transitionName = args.packageInfo.packageName
        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }
        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    sharedElements[names[0]] = list
                }
            }
        })
    }
    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }
    companion object {
        const val KEY_PACKAGENAME = "me.gm.cleaner.plugin.key.packageName"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.ApplistItemBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.mediumAnimTime
class AppListAdapter(private val fragment: AppListFragment) :
    ListAdapter<AppListModel, AppListAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(ApplistItemBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val model = getItem(position)
        Glide.with(fragment)
            .load(model.packageInfo)
            .into(binding.icon)
        binding.title.text = model.label
        binding.summary.text = if (model.ruleCount > 0) {
            activity.buildSpannableString(
                fragment.getString(R.string.enabled_rule_count, model.ruleCount)
            )
        } else {
            model.packageInfo.packageName
        }
        binding.root.transitionName = model.packageInfo.packageName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.applist_fragment) {
                return@setOnClickListener
            }
            fragment.enterPackageName = model.packageInfo.packageName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            val direction = AppListFragmentDirections.actionApplistToApp(
                packageInfo = model.packageInfo,
                label = model.label,
            )
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        if (fragment.enterPackageName == model.packageInfo.packageName) {
            fragment.startPostponedEnterTransition()
        }
    }
    class ViewHolder(val binding: ApplistItemBinding) : RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<AppListModel>() {
            override fun areItemsTheSame(oldItem: AppListModel, newItem: AppListModel): Boolean =
                oldItem.packageInfo.packageName == newItem.packageInfo.packageName
            override fun areContentsTheSame(oldItem: AppListModel, newItem: AppListModel): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.app.Application
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.setFragmentResultListener
import androidx.fragment.app.viewModels
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.repeatOnLifecycle
import androidx.recyclerview.widget.GridLayoutManager
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_APP_NAME
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_UPDATE_TIME
import me.gm.cleaner.plugin.databinding.ApplistFragmentBinding
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.submitListKeepPosition
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.widget.FixQueryChangeSearchView
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
class AppListFragment : ModuleFragment() {
    private val viewModel: AppListViewModel by viewModels(
        factoryProducer = {
            AppListViewModel.provideFactory(
                requireContext().applicationContext as Application,
                binderViewModel
            )
        }
    )
    var enterPackageName: String? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        if (!binderViewModel.pingBinder()) {
            return super.onCreateView(inflater, container, savedInstanceState)
        }
        val binding = ApplistFragmentBinding.inflate(layoutInflater)
        val adapter = AppListAdapter(this)
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .build()
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets(fastScroller)
        binding.listContainer.setOnRefreshListener {
            viewModel.load(null)
        }
        lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.appsFlow.collect { apps ->
                    when (apps) {
                        is AppListState.Loading -> binding.progress.progress = apps.progress
                        is AppListState.Done -> adapter.submitListKeepPosition(apps.list, list) {
                            binding.progress.hide()
                            binding.listContainer.isRefreshing = false
                        }
                    }
                }
            }
        }
        setFragmentResultListener(AppFragment::class.java.name) { _, bundle ->
            enterPackageName = bundle.getString(AppFragment.KEY_PACKAGENAME)
            postponeEnterTransition()
        }
        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            viewModel.update()
        }
        return binding.root
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (!binderViewModel.pingBinder()) {
            return
        }
        inflater.inflate(R.menu.applist_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                viewModel.queryText = ""
                return true
            }
            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as FixQueryChangeSearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }
            override fun onQueryTextChange(newText: String): Boolean {
                if (!searchView.shouldIgnoreQueryChange) {
                    viewModel.queryText = newText
                }
                return false
            }
        })
        when (RootPreferences.sortByFlowable.value) {
            SORT_BY_APP_NAME ->
                menu.findItem(R.id.menu_sort_by_app_name).isChecked = true
            SORT_BY_UPDATE_TIME ->
                menu.findItem(R.id.menu_sort_by_update_time).isChecked = true
        }
        menu.findItem(R.id.menu_rule_count).isChecked = RootPreferences.ruleCountFlowable.value
        menu.findItem(R.id.menu_hide_system_app).isChecked =
            RootPreferences.isHideSystemAppFlowable.value
        arrayOf(
            menu.findItem(R.id.menu_header_sort), menu.findItem(R.id.menu_header_hide)
        ).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_sort_by_app_name -> {
                item.isChecked = true
                RootPreferences.sortByFlowable.value = SORT_BY_APP_NAME
            }
            R.id.menu_sort_by_update_time -> {
                item.isChecked = true
                RootPreferences.sortByFlowable.value = SORT_BY_UPDATE_TIME
            }
            R.id.menu_rule_count -> {
                val ruleCount = !item.isChecked
                item.isChecked = ruleCount
                RootPreferences.ruleCountFlowable.value = ruleCount
            }
            R.id.menu_hide_system_app -> {
                val isHideSystemApp = !item.isChecked
                item.isChecked = isHideSystemApp
                RootPreferences.isHideSystemAppFlowable.value = isHideSystemApp
            }
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListLoader.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.content.pm.PackageManager
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ensureActive
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import java.util.concurrent.atomic.AtomicInteger
class AppListLoader(private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default) {
    private fun fetchRuleCount(templates: Templates): Map<String, Int> {
        val map = mutableMapOf<String, Int>()
        templates.values.forEach { templateName ->
            templateName.applyToApp?.forEach { packageName ->
                map[packageName] = map.getOrDefault(packageName, 0) + 1
            }
        }
        return map
    }
    suspend fun load(
        binderViewModel: BinderViewModel, pm: PackageManager, l: ProgressListener?
    ) = withContext(defaultDispatcher) {
        val packageNameToRuleCount =
            fetchRuleCount(Templates(binderViewModel.readSp(R.xml.template_preferences)))
        val installedPackages = binderViewModel.getInstalledPackages(PackageManager.GET_PERMISSIONS)
        val size = installedPackages.size
        val count = AtomicInteger(0)
        installedPackages.map { pi ->
            ensureActive()
            l?.onProgress(100 * count.incrementAndGet() / size)
            AppListModel(
                pi,
                pm.getApplicationLabel(pi.applicationInfo).toString(),
                packageNameToRuleCount.getOrDefault(pi.packageName, 0),
            )
        }
    }
    suspend fun update(old: List<AppListModel>, binderViewModel: BinderViewModel) =
        withContext(defaultDispatcher) {
            val packageNameToRuleCount =
                fetchRuleCount(Templates(binderViewModel.readSp(R.xml.template_preferences)))
            old.map {
                it.copy(
                    ruleCount = packageNameToRuleCount.getOrDefault(it.packageInfo.packageName, 0)
                )
            }
        }
    interface ProgressListener {
        fun onProgress(progress: Int)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.content.pm.PackageInfo
data class AppListModel(
    val packageInfo: PackageInfo,
    val label: String,
    val ruleCount: Int,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false
        other as AppListModel
        if (label != other.label) return false
        if (ruleCount != other.ruleCount) return false
        return true
    }
    override fun hashCode(): Int {
        var result = label.hashCode()
        result = 31 * result + ruleCount
        return result
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/appmanagement/AppListViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.appmanagement
import android.app.Application
import android.content.pm.ApplicationInfo
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_APP_NAME
import me.gm.cleaner.plugin.dao.RootPreferences.SORT_BY_UPDATE_TIME
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import me.gm.cleaner.plugin.util.collatorComparator
class AppListViewModel(
    application: Application,
    private val binderViewModel: BinderViewModel
) : AndroidViewModel(application) {
    private val _isSearchingFlow = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    private val _queryTextFlow = MutableStateFlow("")
    var queryText: String by _queryTextFlow
    val isLoading: Boolean
        get() = _appsFlow.value is AppListState.Loading
    private val _appsFlow = MutableStateFlow<AppListState>(AppListState.Loading(0))
    val appsFlow =
        combine(
            _appsFlow,
            _isSearchingFlow,
            _queryTextFlow,
            RootPreferences.isHideSystemAppFlowable.asFlow(),
            RootPreferences.sortByFlowable.asFlow(),
            RootPreferences.ruleCountFlowable.asFlow(),
        ) { apps, isSearching, queryText, isHideSystemApp, sortBy, ruleCount ->
            when (apps) {
                is AppListState.Loading -> AppListState.Loading(apps.progress)
                is AppListState.Done -> {
                    var sequence = apps.list.asSequence()
                    if (isHideSystemApp) {
                        sequence = sequence.filter {
                            it.packageInfo.applicationInfo.flags and ApplicationInfo.FLAG_SYSTEM == 0
                        }
                    }
                    if (isSearching) {
                        sequence = sequence.filter {
                            it.label.contains(queryText, true) ||
                                    it.packageInfo.packageName.contains(queryText, true)
                        }
                    }
                    sequence = when (sortBy) {
                        SORT_BY_APP_NAME -> {
                            sequence.sortedWith(collatorComparator { it.label })
                        }
                        SORT_BY_UPDATE_TIME -> sequence.sortedBy {
                            -it.packageInfo.lastUpdateTime
                        }
                        else -> throw IllegalArgumentException()
                    }
                    if (ruleCount) {
                        sequence = sequence.sortedBy { -it.ruleCount }
                    }
                    AppListState.Done(sequence.toList())
                }
            }
        }
    fun load(
        l: AppListLoader.ProgressListener? = object : AppListLoader.ProgressListener {
            override fun onProgress(progress: Int) {
                _appsFlow.value = AppListState.Loading(progress)
            }
        }
    ) {
        viewModelScope.launch {
            _appsFlow.value = AppListState.Loading(0)
            val list = AppListLoader().load(
                binderViewModel, getApplication<Application>().packageManager, l
            )
            _appsFlow.value = AppListState.Done(list)
        }
    }
    fun update() {
        viewModelScope.launch {
            if (!isLoading) {
                val list = AppListLoader().update(
                    (_appsFlow.value as AppListState.Done).list, binderViewModel
                )
                _appsFlow.value = AppListState.Loading(0)
                _appsFlow.value = AppListState.Done(list)
            }
        }
    }
    init {
        load()
    }
    companion object {
        fun provideFactory(
            application: Application, binderViewModel: BinderViewModel
        ): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            @Suppress("UNCHECKED_CAST")
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                return AppListViewModel(application, binderViewModel) as T
            }
        }
    }
}
sealed class AppListState {
    data class Loading(val progress: Int) : AppListState()
    data class Done(val list: List<AppListModel>) : AppListState()
}
fun <T1, T2, T3, T4, T5, T6, R> combine(
    flow: Flow<T1>, flow2: Flow<T2>, flow3: Flow<T3>, flow4: Flow<T4>, flow5: Flow<T5>,
    flow6: Flow<T6>, transform: suspend (T1, T2, T3, T4, T5, T6) -> R
): Flow<R> = combine(flow, flow2, flow3, flow4, flow5, flow6) { args: Array<*> ->
    transform(
        args[0] as T1, args[1] as T2, args[2] as T3, args[3] as T4, args[4] as T5, args[5] as T6
    )
}
fun <T1, T2, T3, T4, T5, T6, T7, R> combine(
    flow: Flow<T1>, flow2: Flow<T2>, flow3: Flow<T3>, flow4: Flow<T4>, flow5: Flow<T5>,
    flow6: Flow<T6>, flow7: Flow<T7>, transform: suspend (T1, T2, T3, T4, T5, T6, T7) -> R
): Flow<R> = combine(flow, flow2, flow3, flow4, flow5, flow6, flow7) { args: Array<*> ->
    transform(
        args[0] as T1, args[1] as T2, args[2] as T3, args[3] as T4, args[4] as T5, args[5] as T6,
        args[6] as T7
    )
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/AbsSettingsFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.fragment.app.activityViewModels
import androidx.preference.Preference
import androidx.preference.PreferenceFragmentCompat
import androidx.preference.PreferenceGroupAdapter
import androidx.preference.PreferenceManager
import androidx.preference.PreferenceScreen
import androidx.preference.PreferenceViewHolder
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.appbar.AppBarLayout
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ktx.setObjectField
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import rikka.recyclerview.fixEdgeEffect
@SuppressLint("RestrictedApi")
abstract class AbsSettingsFragment : PreferenceFragmentCompat() {
    protected val binderViewModel: BinderViewModel by activityViewModels()
    abstract val who: Int
    protected val remoteSp by lazy { BinderSpImpl(binderViewModel, who) }
    open fun onCreatePreferenceManager(savedInstanceState: Bundle?) =
        object : PreferenceManager(requireContext()) {
            override fun getSharedPreferences() = remoteSp
        }
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setObjectField(
            onCreatePreferenceManager(savedInstanceState), PreferenceFragmentCompat::class.java
        )
    }
    override fun onCreateRecyclerView(
        inflater: LayoutInflater, parent: ViewGroup, savedInstanceState: Bundle?
    ): RecyclerView {
        val list = super.onCreateRecyclerView(inflater, parent, savedInstanceState)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        return list
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        requireActivity()
            .findViewById<AppBarLayout>(R.id.toolbar_container)
            .setLiftOnScrollTargetView(listView)
    }
    override fun onCreateAdapter(preferenceScreen: PreferenceScreen): RecyclerView.Adapter<*> {
        return object : PreferenceGroupAdapter(preferenceScreen) {
            override fun onBindViewHolder(holder: PreferenceViewHolder, position: Int) {
                val preference = getItem(position)!!
                preference.onBindViewHolder(holder)
                onBindPreferencesViewHolder(holder, preference)
            }
        }
    }
    open fun onBindPreferencesViewHolder(holder: PreferenceViewHolder, preference: Preference) {}
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/BinderSpImpl.java
================================================
```
package me.gm.cleaner.plugin.ui.module.settings;
import org.json.JSONException;
import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl;
import me.gm.cleaner.plugin.ui.module.BinderViewModel;
public final class BinderSpImpl extends JsonSharedPreferencesImpl {
    public final int who;
    private final BinderViewModel mBinderViewModel;
    public BinderSpImpl(BinderViewModel binderViewModel, int who) throws JSONException {
        super(binderViewModel.readSp(who));
        mBinderViewModel = binderViewModel;
        this.who = who;
    }
    @Override
    public JsonEditorImpl edit() {
        return new JsonEditorImpl(jsonObject -> {
            mBinderViewModel.writeSp(who, jsonObject.toString());
            return true;
        });
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/CreateTemplateFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.SharedElementCallback
import androidx.core.content.edit
import androidx.core.os.bundleOf
import androidx.fragment.app.setFragmentResult
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.navigation.fragment.navArgs
import androidx.preference.EditTextPreference
import androidx.preference.MultiSelectListPreference
import androidx.preference.Preference
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.snackbar.Snackbar
import com.google.android.material.transition.platform.MaterialContainerTransform
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.settings.preference.AppListMultiSelectListPreference
import me.gm.cleaner.plugin.ui.module.settings.preference.MaterialEditTextPreferenceDialogFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.MaterialMultiSelectListPreferenceDialogFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreference
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreferenceFragmentCompat
import me.gm.cleaner.plugin.ui.module.settings.preference.RefinedMultiSelectListPreference
import kotlin.collections.set
class CreateTemplateFragment : AbsSettingsFragment() {
    override val who: Int
        get() = R.xml.template_preferences
    private val args: CreateTemplateFragmentArgs by navArgs()
    private val lastTemplateName by lazy { bundleOf(KEY_TEMPLATE_NAME to currentTemplateName) }
    private lateinit var tempSp: JsonSharedPreferencesImpl
    private val currentTemplateName: String
        get() = tempSp.getString(getString(R.string.template_name_key), NULL_TEMPLATE_NAME)!!
    @SuppressLint("RestrictedApi")
    override fun onCreatePreferenceManager(savedInstanceState: Bundle?) =
        object : PreferenceManager(requireContext()) {
            override fun getSharedPreferences(): SharedPreferences {
                if (!::tempSp.isInitialized) {
                    tempSp = try {
                        JsonSharedPreferencesImpl(
                            Gson().toJson(
                                Templates(binderViewModel.readSp(R.xml.template_preferences)).values.first {
                                    it.templateName == if (savedInstanceState == null) args.templateName
                                    else savedInstanceState.getString(KEY_TEMPLATE_NAME)
                                }
                            )
                        )
                    } catch (e: NoSuchElementException) {
                        JsonSharedPreferencesImpl()
                    }.apply {
                        if (savedInstanceState == null) {
                            edit {
                                putString(getString(R.string.template_name_key), args.templateName)
                            }
                        }
                    }
                }
                return tempSp
            }
        }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString(KEY_TEMPLATE_NAME, currentTemplateName)
    }
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        super.onCreatePreferences(savedInstanceState, rootKey)
        setPreferencesFromResource(R.xml.template_preferences, rootKey)
        val templateName = getString(R.string.template_name_key)
        findPreference<EditTextPreference>(templateName)?.onPreferenceChangeListener =
            Preference.OnPreferenceChangeListener { _, newValue ->
                when {
                    args.templateName == newValue as String -> false
                    Templates(binderViewModel.readSp(R.xml.template_preferences)).values
                        .any { it.templateName == newValue } -> {
                        Snackbar.make(
                            requireView(), R.string.template_name_not_unique, Snackbar.LENGTH_SHORT
                        ).show()
                        false
                    }
                    else -> {
                        lastTemplateName.putString(KEY_TEMPLATE_NAME, newValue)
                        true
                    }
                }
            }
        args.hookOperation?.let {
            val hookOperation = getString(R.string.hook_operation_key)
            findPreference<RefinedMultiSelectListPreference>(hookOperation)
                ?.values = it.toSet()
        }
        val applyToApp = getString(R.string.apply_to_app_key)
        findPreference<AppListMultiSelectListPreference>(applyToApp)
            ?.loadApps { binderViewModel.getInstalledPackages(0) }
            ?.setOnAppsLoadedListener { preference ->
                args.packageNames?.let {
                    preference.values = preference.values + it
                }
            }
        args.permittedMediaTypes?.let {
            val permittedMediaTypes = getString(R.string.permitted_media_types_key)
            findPreference<RefinedMultiSelectListPreference>(permittedMediaTypes)
                ?.values = it.toSet()
        }
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ) = super.onCreateView(inflater, container, savedInstanceState)
        .apply { prepareSharedElementTransition(listView) }
    private fun prepareSharedElementTransition(list: RecyclerView) {
        setFragmentResult(CreateTemplateFragment::class.java.name, lastTemplateName)
        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }
        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    list.transitionName = currentTemplateName
                    sharedElements[names[0]] = list
                }
            }
        })
    }
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        if (args.templateName != null && args.packageNames == null) {
            (requireActivity() as AppCompatActivity).supportActionBar?.setTitle(R.string.edit_template_title)
        }
    }
    override fun onDisplayPreferenceDialog(preference: Preference) {
        val f = when (preference) {
            is EditTextPreference -> MaterialEditTextPreferenceDialogFragmentCompat
                .newInstance(preference.key)
            is MultiSelectListPreference -> MaterialMultiSelectListPreferenceDialogFragmentCompat
                .newInstance(preference.key)
            is PathListPreference -> PathListPreferenceFragmentCompat.newInstance(preference.key)
            else -> {
                super.onDisplayPreferenceDialog(preference)
                return
            }
        }
        f.setTargetFragment(this, 0)
        f.show(parentFragmentManager, DIALOG_FRAGMENT_TAG)
    }
    override fun onStop() {
        super.onStop()
        save()
    }
    private fun save(): Boolean {
        val templateName = tempSp.getString(getString(R.string.template_name_key), null)
        val hookOperationValues =
            findPreference<MultiSelectListPreference>(getString(R.string.hook_operation_key))?.values
        if (!templateName.isNullOrEmpty() && hookOperationValues?.isNotEmpty() == true) {
            val template = Gson().fromJson(tempSp.delegate.toString(), Template::class.java)
            val json = Gson().toJson(
                Templates(binderViewModel.readSp(R.xml.template_preferences)).values.filterNot {
                    it.templateName == templateName || it.templateName == args.templateName
                } + template
            )
            binderViewModel.writeSp(who, json)
        }
        return true
    }
    companion object {
        const val KEY_TEMPLATE_NAME = "me.gm.cleaner.plugin.key.templateName"
        const val NULL_TEMPLATE_NAME = "@null"
        private const val DIALOG_FRAGMENT_TAG = "androidx.preference.PreferenceFragment.DIALOG"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/SettingsFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.setFragmentResultListener
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.preference.Preference
import androidx.preference.PreferenceViewHolder
import androidx.preference.SwitchPreferenceCompat
import com.google.android.material.transition.platform.Hold
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.mediumAnimTime
class SettingsFragment : AbsSettingsFragment() {
    override val who: Int
        get() = R.xml.root_preferences
    var enterKey: String? = null
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        super.onCreatePreferences(savedInstanceState, rootKey)
        setPreferencesFromResource(R.xml.root_preferences, rootKey)
        val usageRecord = getString(R.string.usage_record_key)
        findPreference<SwitchPreferenceCompat>(usageRecord)?.isChecked =
            remoteSp.getBoolean(usageRecord, true)
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View = super.onCreateView(inflater, container, savedInstanceState).also {
        parentFragment?.setFragmentResultListener(TemplatesFragment::class.java.name) { _, bundle ->
            enterKey = bundle.getString(TemplatesFragment.KEY)
            parentFragment?.postponeEnterTransition()
        }
    }
    override fun onBindPreferencesViewHolder(holder: PreferenceViewHolder, preference: Preference) {
        val itemView = holder.itemView
        when (preference.key) {
            getString(R.string.template_management_key) -> {
                itemView.transitionName = preference.key
                itemView.setOnClickListener {
                    val navController = findNavController()
                    if (navController.currentDestination?.id != R.id.settings_fragment) {
                        return@setOnClickListener
                    }
                    enterKey = preference.key
                    parentFragment?.exitTransition = Hold().apply {
                        duration = requireContext().mediumAnimTime
                    }
                    val direction = SettingsFragmentStubDirections.actionSettingsToTemplates()
                    val extras = FragmentNavigatorExtras(it to it.transitionName)
                    navController.navigate(direction, extras)
                }
                parentFragment?.startPostponedEnterTransition()
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/SettingsFragmentStub.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.os.Bundle
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.fragment.app.commit
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.SettingsFragmentStubBinding
import me.gm.cleaner.plugin.ui.module.ModuleFragment
class SettingsFragmentStub : ModuleFragment() {
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ) = if (!binderViewModel.pingBinder()) {
        super.onCreateView(inflater, container, savedInstanceState)
    } else {
        SettingsFragmentStubBinding.inflate(layoutInflater).root.also {
            savedInstanceState ?: childFragmentManager.commit {
                replace(R.id.settings, SettingsFragment())
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/TemplatesAdapters.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.forEach
import androidx.navigation.fragment.FragmentNavigatorExtras
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.Hold
import com.google.gson.Gson
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.TemplatesHeaderBinding
import me.gm.cleaner.plugin.databinding.TemplatesItemBinding
import me.gm.cleaner.plugin.ktx.DividerViewHolder
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
class TemplatesHeaderAdapter(private val fragment: TemplatesFragment) :
    RecyclerView.Adapter<TemplatesHeaderAdapter.ViewHolder>() {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesHeaderBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        binding.root.transitionName = CreateTemplateFragment.NULL_TEMPLATE_NAME
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.templates_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = CreateTemplateFragment.NULL_TEMPLATE_NAME
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)
            val direction = TemplatesFragmentDirections.actionTemplatesToCreateTemplate()
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        if (fragment.lastTemplateName == CreateTemplateFragment.NULL_TEMPLATE_NAME) {
            fragment.startPostponedEnterTransition()
        }
    }
    override fun getItemCount() = 1
    class ViewHolder(val binding: TemplatesHeaderBinding) : DividerViewHolder(binding.root) {
        init {
            isDividerAllowedBelow = true
        }
    }
}
class TemplatesAdapter(private val fragment: TemplatesFragment) :
    ListAdapter<Template, TemplatesAdapter.ViewHolder>(CALLBACK) {
    private val activity = fragment.requireActivity() as AppCompatActivity
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(TemplatesItemBinding.inflate(LayoutInflater.from(parent.context)))
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val item = getItem(position)
        val templateName = item.templateName
        binding.title.text = templateName
        binding.summary.text = fragment.getString(
            R.string.applied_app_count, item.applyToApp?.size ?: 0
        )
        binding.root.transitionName = templateName
        binding.root.setOnClickListener {
            val navController = fragment.findNavController()
            if (navController.currentDestination?.id != R.id.templates_fragment) {
                return@setOnClickListener
            }
            fragment.lastTemplateName = templateName
            fragment.exitTransition = Hold().apply {
                duration = fragment.requireContext().mediumAnimTime
            }
            fragment.setExitSharedElementCallback(null)
            val direction =
                TemplatesFragmentDirections.actionTemplatesToCreateTemplate(templateName)
            val extras = FragmentNavigatorExtras(it to it.transitionName)
            navController.navigate(direction, extras)
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            activity.menuInflater.inflate(R.menu.item_delete, menu)
            menu.setHeaderTitle(templateName)
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    if (item.itemId == R.id.menu_delete) {
                        val modified =
                            Templates(fragment.binderViewModel.readSp(R.xml.template_preferences))
                                .values.filterNot { it.templateName == templateName }
                        fragment.binderViewModel.writeSp(
                            R.xml.template_preferences, Gson().toJson(modified)
                        )
                        true
                    } else {
                        false
                    }
                }
            }
        }
        if (fragment.lastTemplateName == templateName) {
            fragment.startPostponedEnterTransition()
        }
    }
    class ViewHolder(val binding: TemplatesItemBinding) : RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<Template>() {
            override fun areItemsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem.templateName == newItem.templateName
            override fun areContentsTheSame(oldItem: Template, newItem: Template): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/TemplatesFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings
import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.core.app.SharedElementCallback
import androidx.core.os.bundleOf
import androidx.core.view.doOnPreDraw
import androidx.fragment.app.setFragmentResult
import androidx.fragment.app.setFragmentResultListener
import androidx.interpolator.view.animation.FastOutSlowInInterpolator
import androidx.recyclerview.widget.ConcatAdapter
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.transition.platform.MaterialContainerTransform
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.TemplatesFragmentBinding
import me.gm.cleaner.plugin.ktx.DividerDecoration
import me.gm.cleaner.plugin.ktx.colorSurface
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.mediumAnimTime
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.model.Template
import me.gm.cleaner.plugin.model.Templates
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import kotlin.collections.set
class TemplatesFragment : ModuleFragment() {
    var lastTemplateName: String? = null
    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val binding = TemplatesFragmentBinding.inflate(layoutInflater)
        val templatesAdapter = TemplatesAdapter(this)
        val adapters = ConcatAdapter(TemplatesHeaderAdapter(this), templatesAdapter)
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapters
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets()
        list.addItemDecoration(DividerDecoration(list).apply {
            setDivider(resources.getDrawable(R.drawable.list_divider_material, null))
            setAllowDividerAfterLastItem(false)
        })
        binderViewModel.remoteSpCacheLiveData.observe(viewLifecycleOwner) {
            templatesAdapter.submitList(prepareCurrentList())
        }
        prepareSharedElementTransition(list)
        setFragmentResultListener(CreateTemplateFragment::class.java.name) { _, bundle ->
            lastTemplateName = bundle.getString(CreateTemplateFragment.KEY_TEMPLATE_NAME)
            var position = prepareCurrentList().indexOfFirst { it.templateName == lastTemplateName }
            if (position != -1) {
                position++
            } else {
                position = 0
                lastTemplateName = CreateTemplateFragment.NULL_TEMPLATE_NAME
            }
            prepareTransitions(list, position)
            postponeEnterTransition()
            scrollToPosition(list, position)
        }
        return binding.root
    }
    private fun prepareCurrentList(): List<Template> =
        Templates(binderViewModel.readSp(R.xml.template_preferences)).values
            .sortedWith(collatorComparator { it.templateName })
    private fun prepareTransitions(list: RecyclerView, position: Int) {
        setExitSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                val selectedViewHolder = list.findViewHolderForAdapterPosition(position) ?: return
                sharedElements[names[0]] = selectedViewHolder.itemView
            }
        })
    }
    private fun prepareSharedElementTransition(list: RecyclerView) {
        val key = getString(R.string.template_management_key) 
        setFragmentResult(TemplatesFragment::class.java.name, bundleOf(KEY to key))
        list.transitionName = key
        sharedElementEnterTransition = MaterialContainerTransform().apply {
            drawingViewId = R.id.nav_host
            setAllContainerColors(requireContext().colorSurface)
            interpolator = FastOutSlowInInterpolator()
            fadeMode = MaterialContainerTransform.FADE_MODE_CROSS
            duration = requireContext().mediumAnimTime
        }
        setEnterSharedElementCallback(object : SharedElementCallback() {
            override fun onMapSharedElements(
                names: List<String>, sharedElements: MutableMap<String, View>
            ) {
                if (names.isNotEmpty()) {
                    sharedElements[names[0]] = list
                }
            }
        })
    }
    private fun scrollToPosition(list: RecyclerView, position: Int) {
        list.doOnPreDraw {
            val layoutManager = list.layoutManager as? LinearLayoutManager ?: return@doOnPreDraw
            val viewAtPosition = layoutManager.findViewByPosition(position)
            if (viewAtPosition == null ||
                layoutManager.isViewPartiallyVisible(viewAtPosition, false, true)
            ) {
                val lastPosition = layoutManager.findLastCompletelyVisibleItemPosition()
                if (position >= lastPosition && lastPosition - layoutManager.findFirstCompletelyVisibleItemPosition() > 0) {
                    layoutManager.scrollToPosition(position)
                } else {
                    layoutManager.scrollToPositionWithOffset(position, list.paddingTop)
                }
            }
        }
    }
    companion object {
        const val KEY = "me.gm.cleaner.plugin.key"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/AppListMultiSelectListPreference.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.content.Context
import android.content.pm.PackageInfo
import android.icu.text.ListFormatter
import android.util.AttributeSet
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.res.TypedArrayUtils
import androidx.lifecycle.lifecycleScope
import androidx.preference.MultiSelectListPreference
import androidx.preference.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.util.collatorComparator
import java.util.Arrays
import java.util.function.Consumer
import java.util.function.Supplier
@SuppressLint("RestrictedApi", "PrivateResource")
class AppListMultiSelectListPreference @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = TypedArrayUtils.getAttr(
        context, R.attr.dialogPreferenceStyle, android.R.attr.dialogPreferenceStyle
    ), defStyleRes: Int = 0
) : MultiSelectListPreference(context, attrs, defStyleAttr, defStyleRes) {
    private val lifecycleScope = (context as AppCompatActivity).lifecycleScope
    private lateinit var packageNameToLabel: List<Pair<String, CharSequence>>
    private var onAppsLoadedListener: Consumer<AppListMultiSelectListPreference>? = null
    private val mutex = Mutex()
    fun loadApps(applistSupplier: Supplier<List<PackageInfo>>): AppListMultiSelectListPreference {
        lifecycleScope.launch {
            mutex.withLock {
                val pm = context.packageManager
                packageNameToLabel = withContext(Dispatchers.Default) {
                    applistSupplier.get()
                        .map { it.packageName to pm.getApplicationLabel(it.applicationInfo) }
                        .sortedWith(collatorComparator { it.second.toString() })
                }
                liftSelected()
            }
            summaryProvider = instance
        }
        return this
    }
    fun setOnAppsLoadedListener(l: Consumer<AppListMultiSelectListPreference>): AppListMultiSelectListPreference {
        onAppsLoadedListener = l
        return this
    }
    override fun setValues(values: Set<String>) {
        super.setValues(values)
        liftSelected()
    }
    private fun liftSelected() {
        if (!::packageNameToLabel.isInitialized) {
            return
        }
        val list = packageNameToLabel
            .sortedWith(Comparator.comparing { it.first !in values })
            .unzip()
        entries = list.second.toTypedArray()
        entryValues = list.first.toTypedArray()
        val l = onAppsLoadedListener
        onAppsLoadedListener = null
        l?.accept(this)
    }
    override fun onClick() {
        lifecycleScope.launch {
            mutex.withLock {
                super.onClick()
            }
        }
    }
    class SimpleSummaryProvider : SummaryProvider<AppListMultiSelectListPreference> {
        override fun provideSummary(preference: AppListMultiSelectListPreference): CharSequence =
            if (preference.values.isEmpty()) {
                preference.context.getString(R.string.not_set)
            } else {
                val values = Arrays.stream(preference.entryValues)
                    .filter { preference.values.contains(it) }
                    .map { preference.entries[preference.entryValues.indexOf(it)] }
                    .toArray()
                ListFormatter.getInstance().format(*values)
            }
    }
    companion object {
        val instance by lazy { SimpleSummaryProvider() }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/DocumentsContract.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.content.Context
import android.net.Uri
import android.os.storage.StorageManager
import android.provider.DocumentsContract
import androidx.core.provider.DocumentsContractCompat
import java.io.File
private const val EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID = "primary"
fun treeUriToFile(result: Uri, context: Context): File? {
    require(DocumentsContractCompat.isTreeUri(result))
    val docId = DocumentsContract.getTreeDocumentId(result)
    val splitIndex = docId.indexOf(':', 1)
    val sm = context.getSystemService(Context.STORAGE_SERVICE) as StorageManager
    val roots = sm.storageVolumes.associateBy { volume ->
        val rootId = if (volume.isPrimary) EXTERNAL_STORAGE_PRIMARY_EMULATED_ROOT_ID
        else volume.uuid
        rootId
    }
    val tag = docId.substring(0, splitIndex)
    val root = roots[tag] ?: return null
    val path = docId.substring(splitIndex + 1)
    val target = File(root.javaClass.getMethod("getPathFile").invoke(root) as File, path)
    return target
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/MaterialEditTextPreferenceDialogFragmentCompat.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.app.Dialog
import android.os.Bundle
import androidx.core.view.ViewCompat
import androidx.preference.EditTextPreferenceDialogFragmentCompat
import com.google.android.material.dialog.InsetDialogOnTouchListener
import com.google.android.material.dialog.MaterialDialogs
import me.gm.cleaner.plugin.ktx.createMaterialAlertDialogThemedContext
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundDrawable
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundInsets
class MaterialEditTextPreferenceDialogFragmentCompat : EditTextPreferenceDialogFragmentCompat() {
    @SuppressLint("RestrictedApi")
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val alertDialog = super.onCreateDialog(savedInstanceState)
        val window = alertDialog.window!!
        val decorView = window.decorView
        val context = requireContext().createMaterialAlertDialogThemedContext()
        val background = context.materialDialogBackgroundDrawable()
        background.elevation = ViewCompat.getElevation(decorView)
        val backgroundInsets = context.materialDialogBackgroundInsets()
        val insetDrawable = MaterialDialogs.insetDrawable(background, backgroundInsets)
        window.setBackgroundDrawable(insetDrawable)
        decorView.setOnTouchListener(InsetDialogOnTouchListener(alertDialog, backgroundInsets))
        return alertDialog
    }
    companion object {
        fun newInstance(key: String?): MaterialEditTextPreferenceDialogFragmentCompat {
            val fragment = MaterialEditTextPreferenceDialogFragmentCompat()
            val b = Bundle(1)
            b.putString(ARG_KEY, key)
            fragment.arguments = b
            return fragment
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/MaterialMultiSelectListPreferenceDialogFragmentCompat.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.app.Dialog
import android.os.Bundle
import androidx.core.view.ViewCompat
import androidx.preference.MultiSelectListPreferenceDialogFragmentCompat
import com.google.android.material.dialog.InsetDialogOnTouchListener
import com.google.android.material.dialog.MaterialDialogs
import me.gm.cleaner.plugin.ktx.createMaterialAlertDialogThemedContext
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundDrawable
import me.gm.cleaner.plugin.ktx.materialDialogBackgroundInsets
class MaterialMultiSelectListPreferenceDialogFragmentCompat :
    MultiSelectListPreferenceDialogFragmentCompat() {
    @SuppressLint("RestrictedApi")
    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val alertDialog = super.onCreateDialog(savedInstanceState)
        val window = alertDialog.window!!
        val decorView = window.decorView
        val context = requireContext().createMaterialAlertDialogThemedContext()
        val background = context.materialDialogBackgroundDrawable()
        background.elevation = ViewCompat.getElevation(decorView)
        val backgroundInsets = context.materialDialogBackgroundInsets()
        val insetDrawable = MaterialDialogs.insetDrawable(background, backgroundInsets)
        window.setBackgroundDrawable(insetDrawable)
        decorView.setOnTouchListener(InsetDialogOnTouchListener(alertDialog, backgroundInsets))
        return alertDialog
    }
    companion object {
        fun newInstance(key: String?): MaterialMultiSelectListPreferenceDialogFragmentCompat {
            val fragment = MaterialMultiSelectListPreferenceDialogFragmentCompat()
            val b = Bundle(1)
            b.putString(ARG_KEY, key)
            fragment.arguments = b
            return fragment
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreference.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.content.Context
import android.content.res.TypedArray
import android.icu.text.ListFormatter
import android.os.Parcel
import android.os.Parcelable
import android.util.AttributeSet
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes
import androidx.core.content.res.TypedArrayUtils
import androidx.preference.DialogPreference
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.util.collatorComparator
class PathListPreference @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null,
    @SuppressLint("RestrictedApi") @AttrRes defStyleAttr: Int = TypedArrayUtils.getAttr(
        context, androidx.preference.R.attr.dialogPreferenceStyle,
        android.R.attr.dialogPreferenceStyle
    ), @StyleRes defStyleRes: Int = 0
) : DialogPreference(context, attrs, defStyleAttr, defStyleRes) {
    private val _values = mutableSetOf<String>()
    var values: Set<String>
        get() = _values
        set(value) {
            _values.clear()
            _values.addAll(value)
            persistStringSet(value)
            notifyChanged()
        }
    init {
        summaryProvider = instance
    }
    override fun getDialogLayoutResource(): Int = R.layout.path_list_dialog
    override fun onGetDefaultValue(a: TypedArray, index: Int): Any {
        val defaultValues = a.getTextArray(index)
        val result = mutableSetOf<String>()
        for (defaultValue in defaultValues) {
            result.add(defaultValue.toString())
        }
        return result
    }
    override fun onSetInitialValue(defaultValue: Any?) {
        values = getPersistedStringSet(defaultValue as Set<String>?)
    }
    override fun onSaveInstanceState(): Parcelable? {
        val superState = super.onSaveInstanceState()
        if (isPersistent) {
            return superState
        }
        val myState = SavedState(superState)
        myState.mValues = values
        return myState
    }
    override fun onRestoreInstanceState(state: Parcelable?) {
        if (state == null || state.javaClass != SavedState::class.java) {
            super.onRestoreInstanceState(state)
            return
        }
        val myState = state as SavedState
        super.onRestoreInstanceState(myState.superState)
        values = myState.mValues
    }
    private class SavedState : BaseSavedState {
        var mValues = emptySet<String>()
        constructor(source: Parcel) : super(source) {
            val size = source.readInt()
            val strings = arrayOfNulls<String>(size)
            source.readStringArray(strings)
            mValues = strings.mapNotNullTo(mutableSetOf()) { it!! }
        }
        constructor(superState: Parcelable?) : super(superState)
        override fun writeToParcel(dest: Parcel, flags: Int) {
            super.writeToParcel(dest, flags)
            dest.writeInt(mValues.size)
            dest.writeStringArray(mValues.toTypedArray())
        }
        companion object CREATOR : Parcelable.Creator<SavedState> {
            override fun createFromParcel(`in`: Parcel) = SavedState(`in`)
            override fun newArray(size: Int): Array<SavedState?> = arrayOfNulls(size)
        }
    }
    class SimpleSummaryProvider : SummaryProvider<PathListPreference> {
        override fun provideSummary(preference: PathListPreference): String =
            if (preference.values.isEmpty()) {
                preference.context.getString(androidx.preference.R.string.not_set)
            } else {
                ListFormatter.getInstance().format(
                    preference.values.sortedWith(collatorComparator { it })
                )
            }
    }
    companion object {
        val instance by lazy { SimpleSummaryProvider() }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreferenceAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.view.LayoutInflater
import android.view.ViewGroup
import androidx.core.view.forEach
import androidx.preference.EditTextPreference
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.databinding.PathListItemBinding
import me.gm.cleaner.plugin.ui.module.settings.preference.PathListPreferenceFragmentCompat.Companion.TEXT_EDITOR
import java.io.File
class PathListPreferenceAdapter(
    private val fragment: PathListPreferenceFragmentCompat
) : ListAdapter<String, PathListPreferenceAdapter.ViewHolder>(CALLBACK) {
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(PathListItemBinding.inflate(LayoutInflater.from(parent.context)))
    @SuppressLint("RestrictedApi")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val path = getItem(position)!!
        binding.title.text = path
        binding.root.setOnClickListener {
            val preference = fragment.findPreference<EditTextPreference>(TEXT_EDITOR)
            preference?.text = path
            preference?.setOnPreferenceChangeListener { _, newValue ->
                fragment.newValues = fragment.newValues - path + newValue as String
                false
            }
            preference?.performClick()
        }
        binding.root.setOnCreateContextMenuListener { menu, _, _ ->
            fragment.requireActivity().menuInflater.inflate(R.menu.item_delete, menu)
            menu.setHeaderTitle(path.substring(path.lastIndexOf(File.separator) + 1))
            menu.forEach {
                it.setOnMenuItemClickListener { item ->
                    if (item.itemId == R.id.menu_delete) {
                        fragment.newValues -= path
                        true
                    } else {
                        false
                    }
                }
            }
        }
    }
    class ViewHolder(val binding: PathListItemBinding) : RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<String>() {
            override fun areItemsTheSame(oldItem: String, newItem: String): Boolean =
                oldItem == newItem
            override fun areContentsTheSame(oldItem: String, newItem: String): Boolean =
                oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/PathListPreferenceFragmentCompat.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference
import android.annotation.SuppressLint
import android.app.Dialog
import android.content.DialogInterface
import android.net.Uri
import android.os.Bundle
import android.view.View
import android.view.ViewGroup
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.view.SupportMenuInflater
import androidx.appcompat.widget.Toolbar
import androidx.core.os.bundleOf
import androidx.preference.DialogPreference
import androidx.preference.EditTextPreference
import androidx.preference.ListPreference
import androidx.preference.ListPreferenceDialogFragmentCompat
import androidx.preference.MultiSelectListPreference
import androidx.preference.Preference
import androidx.preference.PreferenceDialogFragmentCompat
import androidx.preference.PreferenceManager
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.appbar.AppBarLayout
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import com.google.android.material.floatingactionbutton.FloatingActionButton
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.util.collatorComparator
import rikka.recyclerview.fixEdgeEffect
class PathListPreferenceFragmentCompat : PreferenceDialogFragmentCompat(),
    PreferenceManager.OnDisplayPreferenceDialogListener, DialogPreference.TargetFragment {
    private val pathListPreference by lazy { preference as PathListPreference }
    private lateinit var adapter: PathListPreferenceAdapter
    var newValues = emptyList<String>()
        set(value) {
            field = value.distinct().sortedWith(collatorComparator { it })
            adapter.submitList(field)
        }
    private val preferenceChanged
        get() = pathListPreference.values != newValues.toSet()
    var ignorePreferenceChanged = false
    private val dialog by lazy {
        MaterialAlertDialogBuilder(requireContext())
            .setMessage(R.string.quit_without_save)
            .setPositiveButton(android.R.string.ok) { _, _ ->
                ignorePreferenceChanged = true
                onDismiss(requireDialog())
            }
            .setNegativeButton(android.R.string.cancel, null)
            .create()
    }
    val openDocumentTreeLauncher = registerForActivityResult(
        ActivityResultContracts.OpenDocumentTree(), this::onFragmentResult
    )
    private val preferences = mutableListOf<Preference>()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NORMAL, R.style.AppTheme_FullScreenDialog)
        adapter = PathListPreferenceAdapter(this)
        newValues = if (savedInstanceState == null) {
            pathListPreference.values.toList()
        } else {
            if (savedInstanceState.getBoolean(SAVED_SHOWS_ALERT_DIALOG, false)) {
                dialog.show()
            }
            savedInstanceState.getStringArrayList(SAVE_STATE_VALUES)!!
        }
    }
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean(SAVED_SHOWS_ALERT_DIALOG, dialog.isShowing)
        outState.putStringArrayList(SAVE_STATE_VALUES, ArrayList(newValues))
    }
    override fun onCreateDialog(savedInstanceState: Bundle?) =
        object : Dialog(requireContext(), theme) {
            override fun onBackPressed() {
                onDismiss(requireDialog())
            }
        }.apply {
            val contentView = onCreateDialogView(context)
            if (contentView != null) {
                onBindDialogView(contentView)
                setContentView(contentView)
            }
            window?.setLayout(
                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT
            )
        }
    @SuppressLint("RestrictedApi")
    override fun onBindDialogView(view: View) {
        super.onBindDialogView(view)
        val appBarLayout = view.findViewById<AppBarLayout>(R.id.toolbar_container)
        view.findViewById<Toolbar>(R.id.toolbar).apply {
            setNavigationOnClickListener { onDismiss(requireDialog()) }
            setNavigationIcon(R.drawable.ic_outline_close_24)
            SupportMenuInflater(context).inflate(R.menu.toolbar_save, menu)
            setOnMenuItemClickListener { item ->
                when (item.itemId) {
                    R.id.menu_save -> {
                        val dialog = requireDialog()
                        onClick(dialog, DialogInterface.BUTTON_POSITIVE)
                        ignorePreferenceChanged = true
                        onDismiss(requireDialog())
                    }
                    else -> return@setOnMenuItemClickListener false
                }
                true
            }
            title = pathListPreference.dialogTitle
        }
        val list = view.findViewById<RecyclerView>(R.id.list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        val preference = object : EditTextPreference(requireContext()) {
            override fun getPreferenceManager() = object : PreferenceManager(requireContext()) {
                init {
                    onDisplayPreferenceDialogListener = this@PathListPreferenceFragmentCompat
                }
            }
        }.apply {
            key = TEXT_EDITOR
            dialogTitle = pathListPreference.dialogTitle
        }
        preferences.add(preference)
        view.findViewById<FloatingActionButton>(R.id.fab).setOnClickListener {
            openDocumentTreeLauncher.launch(null)
        }
    }
    override fun onDisplayPreferenceDialog(preference: Preference) {
        val f = when (preference) {
            is EditTextPreference ->
                MaterialEditTextPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            is ListPreference ->
                ListPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            is MultiSelectListPreference ->
                MaterialMultiSelectListPreferenceDialogFragmentCompat.newInstance(preference.getKey())
            else -> throw IllegalArgumentException(
                "Cannot display dialog for an unknown Preference type: "
                        + preference.javaClass.simpleName
                        + ". Make sure to implement onPreferenceDisplayDialog() to handle "
                        + "displaying a custom dialog for this Preference."
            )
        }
        f.setTargetFragment(this, 0)
        f.show(parentFragmentManager, null)
    }
    @Suppress("UNCHECKED_CAST")
    override fun <T : Preference?> findPreference(key: CharSequence): T? {
        for (preference in preferences) {
            val curKey = preference.key
            if (curKey == key) {
                return preference as T
            }
        }
        return null
    }
    fun onFragmentResult(result: Uri?) {
        result ?: return
        val target = treeUriToFile(result, requireContext()) ?: return
        newValues += target.path
    }
    override fun onDestroyView() {
        super.onDestroyView()
        if (dialog.isShowing) {
            dialog.dismiss()
        }
    }
    override fun onDismiss(dialog: DialogInterface) {
        if (preferenceChanged && !ignorePreferenceChanged) {
            this.dialog.show()
        } else {
            super.onDismiss(dialog)
        }
    }
    override fun onDialogClosed(positiveResult: Boolean) {
        if (positiveResult && preferenceChanged) {
            val newValues = newValues.toSet()
            if (pathListPreference.callChangeListener(newValues)) {
                pathListPreference.values = newValues
            }
        }
    }
    companion object {
        private const val SAVE_STATE_VALUES = "PathListPreferenceFragmentCompat.values"
        private const val SAVED_SHOWS_ALERT_DIALOG = "android:showsAlertDialog"
        const val TEXT_EDITOR = "android:textEditor"
        fun newInstance(key: String?) =
            PathListPreferenceFragmentCompat().apply { arguments = bundleOf(ARG_KEY to key) }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/settings/preference/RefinedMultiSelectListPreference.java
================================================
```
package me.gm.cleaner.plugin.ui.module.settings.preference;
import android.annotation.SuppressLint;
import android.content.Context;
import android.icu.text.ListFormatter;
import android.util.AttributeSet;
import androidx.core.content.res.TypedArrayUtils;
import androidx.preference.MultiSelectListPreference;
import androidx.preference.R;
import java.util.Arrays;
import java.util.Set;
@SuppressLint({"RestrictedApi", "PrivateResource"})
public class RefinedMultiSelectListPreference extends MultiSelectListPreference {
    public RefinedMultiSelectListPreference(
            Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        setSummaryProvider(SimpleSummaryProvider.getInstance());
    }
    public RefinedMultiSelectListPreference(Context context, AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, 0);
    }
    public RefinedMultiSelectListPreference(Context context, AttributeSet attrs) {
        this(context, attrs, TypedArrayUtils.getAttr(context, R.attr.dialogPreferenceStyle,
                android.R.attr.dialogPreferenceStyle));
    }
    public RefinedMultiSelectListPreference(Context context) {
        this(context, null);
    }
    @Override
    public void setValues(Set<String> values) {
        super.setValues(values);
        notifyDependencyChange(shouldDisableDependents());
    }
    @Override
    public boolean shouldDisableDependents() {
        return getValues().isEmpty() || super.shouldDisableDependents();
    }
    public static final class SimpleSummaryProvider
            implements SummaryProvider<RefinedMultiSelectListPreference> {
        private static SimpleSummaryProvider sSimpleSummaryProvider;
        private SimpleSummaryProvider() {
        }
        public static SimpleSummaryProvider getInstance() {
            if (sSimpleSummaryProvider == null) {
                sSimpleSummaryProvider = new SimpleSummaryProvider();
            }
            return sSimpleSummaryProvider;
        }
        @Override
        public CharSequence provideSummary(RefinedMultiSelectListPreference preference) {
            if (preference.getValues().isEmpty()) {
                return preference.getContext().getString(R.string.not_set);
            } else {
                var entryValues = Arrays.asList(preference.getEntryValues());
                var values = Arrays.stream(preference.getEntryValues())
                        .filter(it -> preference.getValues().contains(it))
                        .map(it -> preference.getEntries()[entryValues.indexOf(it)])
                        .toArray();
                return ListFormatter.getInstance().format(values);
            }
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordAdapter.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.usagerecord
import android.annotation.SuppressLint
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.text.format.DateUtils
import android.view.LayoutInflater
import android.view.ViewGroup
import android.widget.ArrayAdapter
import androidx.appcompat.widget.ListPopupWindow
import androidx.core.text.buildSpannedString
import androidx.core.text.strikeThrough
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide
import com.google.android.material.snackbar.Snackbar
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.databinding.UsagerecordItemBinding
class UsageRecordAdapter(private val fragment: UsageRecordFragment) :
    ListAdapter<MediaProviderRecord, UsageRecordAdapter.ViewHolder>(CALLBACK) {
    private val context = fragment.requireContext()
    private val clipboardManager by lazy { context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager }
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) =
        ViewHolder(UsagerecordItemBinding.inflate(LayoutInflater.from(parent.context)))
    @SuppressLint("SetTextI18n")
    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        val binding = holder.binding
        val record = getItem(position)
        Glide.with(fragment)
            .load(record.packageInfo)
            .into(binding.icon)
        binding.title.text = record.label ?: record.packageName
        val operation = when (record.operation) {
            OP_QUERY -> fragment.getString(R.string.queried_at)
            OP_INSERT -> fragment.getString(R.string.inserted_at)
            OP_DELETE -> fragment.getString(R.string.deleted_at)
            else -> throw IllegalArgumentException()
        } + formatDateTime(record.timeMillis)
        binding.operation.text = if (record.intercepted.any { it })
            buildSpannedString { strikeThrough { append(operation) } } else operation
        val more = record.data.size - 1
        val hasMore = more > 0
        binding.text.text = record.data.first()
        binding.suffix.text = if (hasMore) fragment.getString(R.string.and_more, more) else null
        binding.root.setOnClickListener {
            val adapter = ArrayAdapter(
                context, R.layout.usagerecord_popup_item,
                record.data.zip(record.intercepted).map { (data, intercepted) ->
                    if (intercepted) buildSpannedString { strikeThrough { append(data) } } else data
                }
            )
            val listPopupWindow = ListPopupWindow(context)
            listPopupWindow.setAdapter(adapter)
            listPopupWindow.anchorView = binding.root
            listPopupWindow.setOnItemClickListener { _, _, position, _ ->
                val data = adapter.getItem(position).toString()
                clipboardManager.setPrimaryClip(ClipData.newPlainText(null, data))
                Snackbar.make(
                    fragment.requireView(), fragment.getString(R.string.copied, data),
                    Snackbar.LENGTH_SHORT
                ).show()
                listPopupWindow.dismiss()
            }
            listPopupWindow.show()
        }
    }
    private fun formatDateTime(timeMillis: Long): String {
        val flags = DateUtils.FORMAT_NO_NOON or DateUtils.FORMAT_NO_MIDNIGHT or
                DateUtils.FORMAT_ABBREV_ALL or DateUtils.FORMAT_SHOW_TIME
        return DateUtils.formatDateTime(context, timeMillis, flags)
    }
    class ViewHolder(val binding: UsagerecordItemBinding) : RecyclerView.ViewHolder(binding.root)
    companion object {
        private val CALLBACK = object : DiffUtil.ItemCallback<MediaProviderRecord>() {
            override fun areItemsTheSame(
                oldItem: MediaProviderRecord, newItem: MediaProviderRecord
            ): Boolean = oldItem.timeMillis == newItem.timeMillis
            override fun areContentsTheSame(
                oldItem: MediaProviderRecord, newItem: MediaProviderRecord
            ): Boolean = oldItem == newItem
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordFragment.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.usagerecord
import android.app.Application
import android.icu.text.DateFormat
import android.icu.util.TimeZone
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuInflater
import android.view.MenuItem
import android.view.View
import android.view.ViewGroup
import androidx.appcompat.widget.SearchView
import androidx.fragment.app.viewModels
import androidx.lifecycle.asLiveData
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.datepicker.CalendarConstraints
import com.google.android.material.datepicker.DateValidatorPointBackward
import com.google.android.material.datepicker.MaterialDatePicker
import me.gm.cleaner.plugin.IMediaChangeObserver
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.databinding.UsagerecordFragmentBinding
import me.gm.cleaner.plugin.ktx.addOnExitListener
import me.gm.cleaner.plugin.ktx.buildSpannableString
import me.gm.cleaner.plugin.ktx.fitsSystemWindowInsets
import me.gm.cleaner.plugin.ktx.overScrollIfContentScrollsPersistent
import me.gm.cleaner.plugin.ui.module.ModuleFragment
import me.gm.cleaner.plugin.widget.FixQueryChangeSearchView
import me.zhanghai.android.fastscroll.FastScrollerBuilder
import rikka.recyclerview.fixEdgeEffect
import java.lang.ref.WeakReference
import java.util.Date
import java.util.Locale
class UsageRecordFragment : ModuleFragment() {
    private val viewModel: UsageRecordViewModel by viewModels(
        factoryProducer = {
            UsageRecordViewModel.provideFactory(
                requireContext().applicationContext as Application,
                binderViewModel
            )
        }
    )
    private val mediaChangeObserver = object : IMediaChangeObserver.Stub() {
        override fun onChange() {
            viewModel.reload()
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setHasOptionsMenu(true)
    }
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        if (!binderViewModel.pingBinder()) {
            return super.onCreateView(inflater, container, savedInstanceState)
        }
        val binding = UsagerecordFragmentBinding.inflate(layoutInflater)
        val adapter = UsageRecordAdapter(this).apply {
            stateRestorationPolicy = RecyclerView.Adapter.StateRestorationPolicy.PREVENT_WHEN_EMPTY
        }
        val list = binding.list
        liftOnScrollTargetView = WeakReference(list)
        list.adapter = adapter
        list.layoutManager = GridLayoutManager(requireContext(), 1)
        list.setHasFixedSize(true)
        val fastScroller = FastScrollerBuilder(list)
            .useMd2Style()
            .build()
        list.fixEdgeEffect(false)
        list.overScrollIfContentScrollsPersistent()
        list.fitsSystemWindowInsets(fastScroller)
        viewModel.recordsFlow.asLiveData().observe(viewLifecycleOwner) { records ->
            when (records) {
                is UsageRecordState.Loading -> binding.progress.show()
                is UsageRecordState.Done -> adapter.submitList(records.list) {
                    binding.progress.hide()
                    supportActionBar?.subtitle = DateFormat.getInstanceForSkeleton(
                        DateFormat.YEAR_ABBR_MONTH_DAY, Locale.getDefault()
                    ).apply {
                        timeZone = TimeZone.getTimeZone("UTC")
                    }.format(Date(viewModel.calendar.timeInMillis))
                }
            }
        }
        binderViewModel.registerMediaChangeObserver(mediaChangeObserver)
        findNavController().addOnExitListener { _, _, _ ->
            binderViewModel.unregisterMediaChangeObserver(mediaChangeObserver)
            supportActionBar?.subtitle = null
        }
        return binding.root
    }
    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        super.onCreateOptionsMenu(menu, inflater)
        if (!binderViewModel.pingBinder()) {
            return
        }
        inflater.inflate(R.menu.usagerecord_toolbar, menu)
        val searchItem = menu.findItem(R.id.menu_search)
        if (viewModel.isSearching) {
            searchItem.expandActionView()
        }
        searchItem.setOnActionExpandListener(object : MenuItem.OnActionExpandListener {
            override fun onMenuItemActionExpand(item: MenuItem): Boolean {
                viewModel.isSearching = true
                viewModel.queryText = ""
                return true
            }
            override fun onMenuItemActionCollapse(item: MenuItem): Boolean {
                viewModel.isSearching = false
                return true
            }
        })
        val searchView = searchItem.actionView as FixQueryChangeSearchView
        searchView.setQuery(viewModel.queryText, false)
        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String): Boolean {
                viewModel.queryText = query
                return true
            }
            override fun onQueryTextChange(newText: String): Boolean {
                if (!searchView.shouldIgnoreQueryChange) {
                    viewModel.queryText = newText
                }
                return false
            }
        })
        menu.findItem(R.id.menu_hide_query).isChecked = RootPreferences.isHideQueryFlowable.value
        menu.findItem(R.id.menu_hide_insert).isChecked = RootPreferences.isHideInsertFlowable.value
        menu.findItem(R.id.menu_hide_delete).isChecked = RootPreferences.isHideDeleteFlowable.value
        arrayOf(menu.findItem(R.id.menu_header_hide)).forEach {
            it.title = requireContext().buildSpannableString(it.title!!)
        }
    }
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_pick_date -> {
                val calendarConstraints = CalendarConstraints.Builder()
                    .setValidator(DateValidatorPointBackward.now())
                    .build()
                val datePicker = MaterialDatePicker.Builder.datePicker()
                    .setCalendarConstraints(calendarConstraints)
                    .setSelection(viewModel.calendar.timeInMillis)
                    .build()
                datePicker.addOnPositiveButtonClickListener { selection ->
                    viewModel.selectedTime = selection
                }
                datePicker.show(childFragmentManager, null)
            }
            R.id.menu_hide_query -> {
                val isHideQuery = !item.isChecked
                item.isChecked = isHideQuery
                RootPreferences.isHideQueryFlowable.value = isHideQuery
            }
            R.id.menu_hide_insert -> {
                val isHideInsert = !item.isChecked
                item.isChecked = isHideInsert
                RootPreferences.isHideInsertFlowable.value = isHideInsert
            }
            R.id.menu_hide_delete -> {
                val isHideDelete = !item.isChecked
                item.isChecked = isHideDelete
                RootPreferences.isHideDeleteFlowable.value = isHideDelete
            }
            R.id.menu_clear -> {
                binderViewModel.clearAllTables()
                viewModel.reload()
            }
            else -> return super.onOptionsItemSelected(item)
        }
        return true
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/ui/module/usagerecord/UsageRecordViewModel.kt
================================================
```
package me.gm.cleaner.plugin.ui.module.usagerecord
import android.app.Application
import android.provider.MediaStore
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.dao.RootPreferences
import me.gm.cleaner.plugin.ktx.getValue
import me.gm.cleaner.plugin.ktx.setValue
import me.gm.cleaner.plugin.ui.module.BinderViewModel
import java.util.Calendar
class UsageRecordViewModel(
    application: Application,
    private val binderViewModel: BinderViewModel,
) : AndroidViewModel(application) {
    private val _isSearchingFlow: MutableStateFlow<Boolean> = MutableStateFlow(false)
    var isSearching: Boolean by _isSearchingFlow
    private val _queryTextFlow: MutableStateFlow<String> = MutableStateFlow("")
    var queryText: String by _queryTextFlow
    private val _selectedTimeFlow: MutableStateFlow<Long> =
        MutableStateFlow(System.currentTimeMillis())
    var selectedTime: Long by _selectedTimeFlow
    val calendar: Calendar = Calendar.getInstance()
    private val _recordsFlow = MutableStateFlow<UsageRecordState>(UsageRecordState.Loading)
    val recordsFlow =
        combine(_recordsFlow, _isSearchingFlow, _queryTextFlow) { source, isSearching, queryText ->
            when (source) {
                is UsageRecordState.Loading -> UsageRecordState.Loading
                is UsageRecordState.Done -> withContext(Dispatchers.Default) {
                    var sequence = source.list.asSequence()
                    if (isSearching) {
                        sequence = sequence.filter {
                            it.data.any { data -> data.contains(queryText, true) } ||
                                    it.label?.contains(queryText, true) == true ||
                                    it.packageName.contains(queryText, true)
                        }
                    }
                    UsageRecordState.Done(sequence.toList())
                }
            }
        }
    private fun calculateSelectedTime(timeMillis: Long): Pair<Long, Long> =
        with(calendar) {
            timeInMillis = timeMillis
            set(Calendar.HOUR_OF_DAY, 0)
            set(Calendar.MINUTE, 0)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
            val start = timeInMillis
            set(Calendar.HOUR_OF_DAY, 23)
            set(Calendar.MINUTE, 59)
            set(Calendar.SECOND, 59)
            set(Calendar.MILLISECOND, 999)
            val end = timeInMillis
            return start to end
        }
    private suspend inline fun queryRecord(
        start: Long, end: Long, operations: List<Int>
    ): List<MediaProviderRecord> = withContext(Dispatchers.IO) {
        val projection = operations.map { it.toString() }.toTypedArray()
        val selection = start.toString()
        val sortOrder = end.toString()
        getApplication<Application>().contentResolver.query(
            MediaStore.Images.Media.INTERNAL_CONTENT_URI,
            projection,
            selection,
            null,
            sortOrder
        )?.use { cursor ->
            return@withContext MediaProviderRecord.convert(cursor)
        }
        return@withContext emptyList()
    }
    private suspend fun load(
        start: Long, end: Long,
        isHideQuery: Boolean, isHideInsert: Boolean, isHideDelete: Boolean
    ): UsageRecordState {
        val packageManager = getApplication<Application>().packageManager
        val operations = mutableListOf<Int>()
        if (!isHideQuery) {
            operations += OP_QUERY
        }
        if (!isHideInsert) {
            operations += OP_INSERT
        }
        if (!isHideDelete) {
            operations += OP_DELETE
        }
        val records = mutableListOf<MediaProviderRecord>().also {
            it += queryRecord(start, end, operations)
        }.onEach {
            val pi = binderViewModel.getPackageInfo(it.packageName) ?: return@onEach
            it.packageInfo = pi
            it.label = packageManager.getApplicationLabel(pi.applicationInfo).toString()
        }.takeWhile {
            it.packageInfo != null
        }
        return UsageRecordState.Done(records)
    }
    private val isHideQueryFlow: StateFlow<Boolean> = RootPreferences.isHideQueryFlowable.asFlow()
    private val isHideInsertFlow: StateFlow<Boolean> = RootPreferences.isHideInsertFlowable.asFlow()
    private val isHideDeleteFlow: StateFlow<Boolean> = RootPreferences.isHideDeleteFlowable.asFlow()
    fun reload() {
        _recordsFlow.value = UsageRecordState.Loading
        viewModelScope.launch {
            val (start, end) = calculateSelectedTime(selectedTime)
            _recordsFlow.value = load(
                start, end,
                isHideQueryFlow.value,
                isHideInsertFlow.value,
                isHideDeleteFlow.value
            )
        }
    }
    init {
        viewModelScope.launch {
            combine(
                _selectedTimeFlow,
                isHideQueryFlow,
                isHideInsertFlow,
                isHideDeleteFlow,
            ) { selectedTime, isHideQuery, isHideInsert, isHideDelete ->
                _recordsFlow.value = UsageRecordState.Loading
                val (start, end) = calculateSelectedTime(selectedTime)
                load(start, end, isHideQuery, isHideInsert, isHideDelete)
            }.collect {
                _recordsFlow.value = it
            }
        }
    }
    companion object {
        fun provideFactory(
            application: Application, binderViewModel: BinderViewModel
        ): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            @Suppress("UNCHECKED_CAST")
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                return UsageRecordViewModel(application, binderViewModel) as T
            }
        }
    }
}
sealed class UsageRecordState {
    data object Loading : UsageRecordState()
    data class Done(val list: List<MediaProviderRecord>) : UsageRecordState()
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/Comparators.kt
================================================
```
package me.gm.cleaner.plugin.util
import java.text.Collator
private val collator: Collator by lazy { Collator.getInstance() }
private val naturalSorter: NaturalSorter by lazy { NaturalSorter() }
fun <T> collatorComparator(convert: (T) -> String): Comparator<T> {
    return Comparator { o1, o2 ->
        collator.compare(convert(o1), convert(o2))
    }
}
fun <T> fileNameComparator(convert: (T) -> String): Comparator<T> {
    return Comparator { o1, o2 ->
        naturalSorter.compare(convert(o1), convert(o2))
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/FlowableSharedPreferences.kt
================================================
```
package me.gm.cleaner.plugin.util
import android.content.SharedPreferences
import androidx.core.content.edit
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
class FlowableSharedPreferences<T>(
    private val preferences: SharedPreferences,
    private val key: String,
    private val defaultValue: T,
) {
    @Suppress("UNCHECKED_CAST")
    private fun load(): T = when (defaultValue) {
        is String -> preferences.getString(key, defaultValue) as T
        is Set<*> -> preferences.getStringSet(key, defaultValue as Set<String>) as T
        is Int -> preferences.getInt(key, defaultValue) as T
        is Long -> preferences.getLong(key, defaultValue) as T
        is Float -> preferences.getFloat(key, defaultValue) as T
        is Boolean -> preferences.getBoolean(key, defaultValue) as T
        else -> throw IllegalArgumentException("Unsupported type")
    }
    private val _preferenceFlow: MutableStateFlow<T> = MutableStateFlow(load())
    var value: T
        get() = _preferenceFlow.value
        set(value) {
            preferences.edit {
                when (value) {
                    is String -> putString(key, value as String)
                    is Set<*> -> putStringSet(key, value as Set<String>)
                    is Int -> putInt(key, value as Int)
                    is Long -> putLong(key, value as Long)
                    is Float -> putFloat(key, value as Float)
                    is Boolean -> putBoolean(key, value as Boolean)
                    else -> throw IllegalArgumentException("Unsupported type")
                }
            }
        }
    fun asFlow(): StateFlow<T> = _preferenceFlow
    private val listener = SharedPreferences.OnSharedPreferenceChangeListener { _, key ->
        if (key == this.key) {
            _preferenceFlow.value = load()
        }
    }
    init {
        preferences.registerOnSharedPreferenceChangeListener(listener)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/MediaStoreCompat.kt
================================================
```
package me.gm.cleaner.plugin.util
import android.app.RecoverableSecurityException
import android.content.IntentSender
import android.net.Uri
import android.os.Build
import android.provider.MediaStore
import androidx.annotation.RequiresApi
import androidx.fragment.app.Fragment
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
object MediaStoreCompat {
    suspend fun delete(fragment: Fragment, uri: Uri): Boolean = withContext(Dispatchers.IO) {
        try {
            fragment.requireContext().contentResolver.delete(uri, null, null)
            return@withContext true
        } catch (securityException: SecurityException) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                val recoverableSecurityException =
                    securityException as? RecoverableSecurityException
                        ?: throw securityException
                fragment.startIntentSenderForResult(
                    recoverableSecurityException.userAction.actionIntent.intentSender,
                    DELETE_PERMISSION_REQUEST, null, 0, 0, 0, null
                )
                return@withContext false
            } else {
                throw securityException
            }
        }
    }
    @RequiresApi(Build.VERSION_CODES.R)
    suspend fun delete(fragment: Fragment, uris: Collection<Uri>) {
        if (uris.isEmpty()) {
            return
        }
        return withContext(Dispatchers.IO) {
            val pendingIntent = MediaStore.createDeleteRequest(
                fragment.requireContext().contentResolver, uris
            )
            fragment.startIntentSenderForResult(
                pendingIntent.intentSender, DELETE_PERMISSION_REQUEST, null, 0, 0, 0, null
            )
        }
    }
    const val DELETE_PERMISSION_REQUEST = 0x1033
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/NaturalSorter.java
================================================
```
package me.gm.cleaner.plugin.util;
import java.math.BigInteger;
import java.text.Collator;
import java.util.Comparator;
public class NaturalSorter implements Comparator<String> {
    private static final Collator collator = Collator.getInstance();
    @Override
    public int compare(String o1, String o2) {
        int index1 = 0;
        int index2 = 0;
        while (true) {
            String data1 = nextSlice(o1, index1);
            String data2 = nextSlice(o2, index2);
            if (data1 == null && data2 == null) {
                return 0;
            }
            if (data1 == null) {
                return -1;
            }
            if (data2 == null) {
                return 1;
            }
            index1 += data1.length();
            index2 += data2.length();
            int result;
            if (isDigit(data1) && isDigit(data2)) {
                result = new BigInteger(data1).compareTo(new BigInteger(data2));
                if (result == 0) {
                    result = Integer.compare(data1.length(), data2.length());
                }
            } else {
                result = collator.compare(data1, data2);
            }
            if (result != 0) {
                return result;
            }
        }
    }
    private static boolean isDigit(String str) {
        char ch = str.charAt(0);
        return ch >= '0' && ch <= '9';
    }
    static String nextSlice(String str, int index) {
        int length = str.length();
        if (index == length) {
            return null;
        }
        char ch = str.charAt(index);
        if (ch == '.' || ch == ' ') {
            return str.substring(index, index + 1);
        } else if (ch >= '0' && ch <= '9') {
            return str.substring(index, nextNumberBound(str, index + 1));
        } else {
            return str.substring(index, nextOtherBound(str, index + 1));
        }
    }
    private static int nextNumberBound(String str, int index) {
        for (int length = str.length(); index < length; index++) {
            char ch = str.charAt(index);
            if (ch < '0' || ch > '9') {
                break;
            }
        }
        return index;
    }
    private static int nextOtherBound(String str, int index) {
        for (int length = str.length(); index < length; index++) {
            char ch = str.charAt(index);
            if (ch == '.' || ch == ' ' || (ch >= '0' && ch <= '9')) {
                break;
            }
        }
        return index;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/util/PermissionUtils.kt
================================================
```
package me.gm.cleaner.plugin.util
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.provider.Settings
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.annotation.CallSuper
import androidx.core.app.ActivityCompat
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.commitNow
import me.gm.cleaner.plugin.app.BaseFragment
object PermissionUtils {
    private const val TAG = "PermissionUtils"
    fun requestPermissions(
        fragmentManager: FragmentManager, requesterFragment: RequesterFragment
    ) {
        fragmentManager.commitNow {
            val existingFragment = fragmentManager.findFragmentByTag(TAG)
            if (existingFragment != null) {
                remove(existingFragment)
            }
            add(requesterFragment, TAG)
        }
        requesterFragment.dispatchRequestPermissions(requesterFragment.requiredPermissions)
    }
    fun startDetailsSettings(context: Context) {
        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
            data = Uri.fromParts("package", context.packageName, null)
        }
        context.startActivity(intent)
    }
}
abstract class RequesterFragment : BaseFragment() {
    open val requiredPermissions: Array<String> = emptyArray<String>()
    private lateinit var requestMultiplePermissions: ActivityResultLauncher<Array<String>>
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestMultiplePermissions =
            registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { result ->
                val granted = result.filterValues { it }.keys
                if (granted.isNotEmpty()) {
                    onRequestPermissionsSuccess(granted)
                }
                val denied = result.keys - granted
                if (denied.isNotEmpty()) {
                    val shouldShowRationale = denied.filter {
                        ActivityCompat.shouldShowRequestPermissionRationale(requireActivity(), it)
                    }.toSet()
                    onRequestPermissionsFailure(
                        shouldShowRationale, denied - shouldShowRationale
                    )
                }
            }
    }
    @CallSuper
    internal fun dispatchRequestPermissions(permissions: Array<String>) {
        val granted = permissions.filter {
            ActivityCompat.checkSelfPermission(requireContext(), it) ==
                    PackageManager.PERMISSION_GRANTED
        }.toSet()
        if (permissions.size > granted.size) {
            val denied = permissions.toSet() - granted
            val shouldShowRationale = denied.filter {
                ActivityCompat.shouldShowRequestPermissionRationale(requireActivity(), it)
            }.toSet()
            if (shouldShowRationale.isNotEmpty()) {
                onRequestPermissionsFailure(shouldShowRationale, emptySet())
            } else {
                onRequestPermissions(denied.toTypedArray())
            }
        }
    }
    protected fun onRequestPermissions(permissions: Array<String>) {
        requestMultiplePermissions.launch(permissions)
    }
    protected open fun onRequestPermissionsSuccess(permissions: Set<String>) {
    }
    protected open fun onRequestPermissionsFailure(
        shouldShowRationale: Set<String>, denied: Set<String>
    ) {
    }
    override fun onDestroyView() {
        super.onDestroyView()
        requestMultiplePermissions.unregister()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/BottomActionBar.java
================================================
```
package me.gm.cleaner.plugin.widget;
import static java.lang.Math.min;
import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.os.Build.VERSION;
import android.util.AttributeSet;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.view.SupportMenuInflater;
import androidx.appcompat.view.menu.MenuBuilder;
import androidx.appcompat.widget.TintTypedArray;
import androidx.core.content.ContextCompat;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import com.google.android.material.drawable.DrawableUtils;
import com.google.android.material.internal.ThemeEnforcement;
import com.google.android.material.internal.ViewUtils;
import com.google.android.material.internal.ViewUtils.RelativePadding;
import com.google.android.material.shape.MaterialShapeDrawable;
import com.google.android.material.shape.ShapeAppearanceModel;
import me.gm.cleaner.plugin.R;
@SuppressLint("RestrictedApi")
public class BottomActionBar extends FrameLayout {
    private MenuInflater menuInflater;
    private final MenuBuilder menu;
    @NonNull
    private final BottomActionBarMenuView menuView;
    public BottomActionBar(@NonNull Context context) {
        this(context, null);
    }
    public BottomActionBar(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, com.google.android.material.R.attr.bottomNavigationStyle);
    }
    public BottomActionBar(
            @NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, com.google.android.material.R.attr.bottomNavigationStyle);
    }
    public BottomActionBar(
            @NonNull Context context,
            @Nullable AttributeSet attrs,
            int defStyleAttr,
            int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        context = getContext();
        TintTypedArray attributes =
                ThemeEnforcement.obtainTintedStyledAttributes(
                        context, attrs, R.styleable.BottomActionBar, defStyleAttr, defStyleRes);
        this.menu = new MenuBuilder(context);
        this.menuView = createNavigationBarMenuView(context);
        this.menuView.initialize(menu);
        if (attributes.hasValue(R.styleable.BottomActionBar_menu)) {
            inflateMenu(attributes.getResourceId(R.styleable.BottomActionBar_menu, 0));
        }
        Drawable background = getBackground();
        ColorStateList backgroundColorStateList = DrawableUtils.getColorStateListOrNull(background);
        if (background == null || backgroundColorStateList != null) {
            ShapeAppearanceModel shapeAppearanceModel =
                    ShapeAppearanceModel.builder(context, attrs, defStyleAttr, defStyleRes).build();
            MaterialShapeDrawable materialShapeDrawable = new MaterialShapeDrawable(shapeAppearanceModel);
            if (backgroundColorStateList != null) {
                materialShapeDrawable.setFillColor(backgroundColorStateList);
            }
            materialShapeDrawable.initializeElevationOverlay(context);
            ViewCompat.setBackground(this, materialShapeDrawable);
        }
        if (shouldDrawCompatibilityTopDivider()) {
            addCompatibilityTopDivider(context);
        }
        attributes.recycle();
        addView(menuView);
        applyWindowInsets();
    }
    @NonNull
    protected BottomActionBarMenuView createNavigationBarMenuView(@NonNull Context context) {
        return new BottomActionBarMenuView(context);
    }
    public void inflateMenu(int resId) {
        if (menuInflater == null) {
            menuInflater = new SupportMenuInflater(getContext());
        }
        menuInflater.inflate(resId, menu);
        menuView.buildMenuView();
    }
    public void show() {
        setVisibility(View.VISIBLE);
    }
    public void hide() {
        setVisibility(View.GONE);
    }
    private void applyWindowInsets() {
        ViewUtils.doOnApplyWindowInsets(
                this,
                new ViewUtils.OnApplyWindowInsetsListener() {
                    @NonNull
                    @Override
                    public WindowInsetsCompat onApplyWindowInsets(
                            View view,
                            @NonNull WindowInsetsCompat insets,
                            @NonNull RelativePadding initialPadding) {
                        initialPadding.bottom += insets.getSystemWindowInsetBottom();
                        boolean isRtl = ViewCompat.getLayoutDirection(view) == ViewCompat.LAYOUT_DIRECTION_RTL;
                        int systemWindowInsetLeft = insets.getSystemWindowInsetLeft();
                        int systemWindowInsetRight = insets.getSystemWindowInsetRight();
                        initialPadding.start += isRtl ? systemWindowInsetRight : systemWindowInsetLeft;
                        initialPadding.end += isRtl ? systemWindowInsetLeft : systemWindowInsetRight;
                        initialPadding.applyToView(view);
                        return insets;
                    }
                });
    }
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int minHeightSpec = makeMinHeightSpec(heightMeasureSpec);
        super.onMeasure(widthMeasureSpec, minHeightSpec);
    }
    private int makeMinHeightSpec(int measureSpec) {
        int minHeight = getSuggestedMinimumHeight();
        if (MeasureSpec.getMode(measureSpec) != MeasureSpec.EXACTLY && minHeight > 0) {
            minHeight += getPaddingTop() + getPaddingBottom();
            return MeasureSpec.makeMeasureSpec(
                    min(MeasureSpec.getSize(measureSpec), minHeight), MeasureSpec.EXACTLY);
        }
        return measureSpec;
    }
    private boolean shouldDrawCompatibilityTopDivider() {
        return VERSION.SDK_INT < 21 && !(getBackground() instanceof MaterialShapeDrawable);
    }
    private void addCompatibilityTopDivider(@NonNull Context context) {
        View divider = new View(context);
        divider.setBackgroundColor(
                ContextCompat.getColor(
                        context,
                        com.google.android.material.R.color.design_bottom_navigation_shadow_color));
        LayoutParams dividerParams =
                new LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        getResources().getDimensionPixelSize(
                                com.google.android.material.
                                        R.dimen.design_bottom_navigation_shadow_height));
        divider.setLayoutParams(dividerParams);
        addView(divider);
    }
    public void setOnMenuItemClickListener(@Nullable MenuItem.OnMenuItemClickListener listener) {
        if (listener == null) {
            menu.setCallback(null);
        } else {
            menu.setCallback(new MenuBuilder.Callback() {
                @Override
                public boolean onMenuItemSelected(@NonNull MenuBuilder menu, @NonNull MenuItem item) {
                    return listener.onMenuItemClick(item);
                }
                @Override
                public void onMenuModeChange(@NonNull MenuBuilder menu) {
                }
            });
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/BottomActionBarMenuView.java
================================================
```
package me.gm.cleaner.plugin.widget;
import android.annotation.SuppressLint;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.LinearLayout;
import androidx.annotation.NonNull;
import androidx.appcompat.view.menu.MenuBuilder;
import androidx.appcompat.view.menu.MenuItemImpl;
import androidx.appcompat.view.menu.MenuView;
import androidx.appcompat.widget.TooltipCompat;
import androidx.core.view.ViewCompat;
import me.gm.cleaner.plugin.databinding.DesignBottomBarItemBinding;
@SuppressLint("RestrictedApi")
public class BottomActionBarMenuView extends LinearLayout implements MenuView {
    @NonNull
    private final OnClickListener onClickListener =
            new OnClickListener() {
                @Override
                public void onClick(View v) {
                    MenuItem item = (MenuItem) v.getTag();
                    menu.performItemAction(item, null, 0);
                }
            };
    private MenuBuilder menu;
    public BottomActionBarMenuView(@NonNull Context context) {
        super(context);
        setOrientation(LinearLayout.HORIZONTAL);
        ViewCompat.setImportantForAccessibility(this, ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    @Override
    public void initialize(MenuBuilder menu) {
        this.menu = menu;
    }
    @Override
    public int getWindowAnimations() {
        return 0;
    }
    private DesignBottomBarItemBinding getNewItem() {
        return DesignBottomBarItemBinding.inflate(LayoutInflater.from(getContext()), this, false);
    }
    public void buildMenuView() {
        removeAllViews();
        for (int i = 0; i < menu.size(); i++) {
            DesignBottomBarItemBinding itemBinding = getNewItem();
            MenuItemImpl item = (MenuItemImpl) menu.getItem(i);
            itemBinding.navigationBarItemIconView.setImageDrawable(item.getIcon());
            itemBinding.navigationBarItemSmallLabelView.setText(item.getTitle());
            View child = itemBinding.getRoot();
            child.setOnClickListener(onClickListener);
            child.setTag(item);
            TooltipCompat.setTooltipText(child, item.getTitle());
            addView(child);
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/DrawerHeader.kt
================================================
```
package me.gm.cleaner.plugin.widget
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.WindowInsets
import android.widget.LinearLayout
import androidx.annotation.AttrRes
import androidx.annotation.StyleRes
class DrawerHeader @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, @AttrRes defStyleAttr: Int = 0,
    @StyleRes defStyleRes: Int = 0
) : LinearLayout(context, attrs, defStyleAttr, defStyleRes) {
    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets {
        val localInsets = Rect()
        val result = computeSystemWindowInsets(insets, localInsets)
        val displayCutout = insets.displayCutout
        if (displayCutout != null) {
            localInsets.top = displayCutout.safeInsetTop
        }
        applyInsets(localInsets)
        return result
    }
    private fun applyInsets(insets: Rect) {
        setPaddingRelative(0, insets.top, 0, 0)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FitsHorizontalInsetsCoordinatorLayout.kt
================================================
```
package me.gm.cleaner.plugin.widget
import android.content.Context
import android.graphics.Rect
import android.util.AttributeSet
import android.view.WindowInsets
import androidx.annotation.AttrRes
import androidx.coordinatorlayout.widget.CoordinatorLayout
class FitsHorizontalInsetsCoordinatorLayout @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, @AttrRes defStyleAttr: Int = 0
) : CoordinatorLayout(context, attrs, defStyleAttr) {
    private val mPaddingLeft = paddingLeft
    private val mPaddingTop = paddingTop
    private val mPaddingRight = paddingRight
    private val mPaddingBottom = paddingBottom
    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets {
        val localInsets = Rect()
        val result = computeSystemWindowInsets(insets, localInsets)
        applyInsets(localInsets)
        return insets
    }
    private fun applyInsets(insets: Rect) {
        setPadding(
            mPaddingLeft + insets.left, mPaddingTop,
            mPaddingRight + insets.right, mPaddingBottom
        )
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FixLayoutSearchView.kt
================================================
```
package me.gm.cleaner.plugin.widget
import android.content.Context
import android.util.AttributeSet
import android.view.View
import androidx.annotation.AttrRes
import androidx.appcompat.R
import androidx.appcompat.widget.SearchView
import androidx.core.view.updateLayoutParams
import androidx.core.view.updatePaddingRelative
import me.gm.cleaner.plugin.ktx.dpToPx
import me.gm.cleaner.plugin.ktx.getDrawableByAttr
open class FixLayoutSearchView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null,
    @AttrRes defStyleAttr: Int = R.attr.searchViewStyle
) : SearchView(context, attrs, defStyleAttr) {
    init {
        maxWidth = Int.MAX_VALUE
        val searchEditFrame = findViewById<View>(R.id.search_edit_frame)
        searchEditFrame.updateLayoutParams<MarginLayoutParams> {
            leftMargin = 12
            rightMargin = 12
        }
        val searchSrcText = findViewById<View>(R.id.search_src_text)
        searchSrcText.setPaddingRelative(0, searchSrcText.top, 0, searchSrcText.paddingBottom)
        val searchCloseBtn = findViewById<View>(R.id.search_close_btn)
        val searchCloseBtnPaddingHorizontal = searchCloseBtn.context.dpToPx(12)
        searchCloseBtn.updatePaddingRelative(
            start = searchCloseBtnPaddingHorizontal, end = searchCloseBtnPaddingHorizontal
        )
        searchCloseBtn.background =
            searchCloseBtn.context.getDrawableByAttr(R.attr.actionBarItemBackground)
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/FixQueryChangeSearchView.kt
================================================
```
package me.gm.cleaner.plugin.widget
import android.content.Context
import android.util.AttributeSet
import androidx.annotation.AttrRes
class FixQueryChangeSearchView : FixLayoutSearchView {
    var shouldIgnoreQueryChange = false
        private set
    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)
    constructor(context: Context, attrs: AttributeSet?, @AttrRes defStyleAttr: Int) : super(
        context, attrs, defStyleAttr
    )
    override fun setIconified(iconify: Boolean) {
        shouldIgnoreQueryChange = true
        super.setIconified(iconify)
        shouldIgnoreQueryChange = false
    }
    override fun onActionViewCollapsed() {
        shouldIgnoreQueryChange = true
        super.onActionViewCollapsed()
        shouldIgnoreQueryChange = false
    }
    override fun onActionViewExpanded() {
        shouldIgnoreQueryChange = true
        super.onActionViewExpanded()
        shouldIgnoreQueryChange = false
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/widget/ThemedSwipeRefreshLayout.kt
================================================
```
package me.gm.cleaner.plugin.widget
import android.content.Context
import android.util.AttributeSet
import androidx.swiperefreshlayout.widget.ThemedSwipeRefreshLayout
import me.gm.cleaner.plugin.ktx.getDimenByAttr
class ThemedSwipeRefreshLayout(context: Context, attrs: AttributeSet?) :
    ThemedSwipeRefreshLayout(context, attrs) {
    private fun init() {
        val actionBarSizeAddTabHeight = context.getDimenByAttr(android.R.attr.actionBarSize).toInt()
        setProgressViewOffset(
            false, actionBarSizeAddTabHeight, progressViewEndOffset + actionBarSizeAddTabHeight
        )
    }
    init {
        init()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/JsonFileSpImpl.java
================================================
```
package me.gm.cleaner.plugin.xposed;
import android.text.TextUtils;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import de.robv.android.xposed.XposedBridge;
import me.gm.cleaner.plugin.dao.JsonSharedPreferencesImpl;
import me.gm.cleaner.plugin.dao.SharedPreferencesWrapper;
public class JsonFileSpImpl extends SharedPreferencesWrapper {
    public final File file;
    protected String contentCache;
    public JsonFileSpImpl(File src) {
        file = src;
        JSONObject json;
        try {
            var str = read();
            if (TextUtils.isEmpty(str)) {
                json = new JSONObject();
            } else {
                json = new JSONObject(str);
            }
        } catch (JSONException e) {
            json = new JSONObject();
        }
        delegate = new JsonSharedPreferencesImpl(json);
    }
    private void ensureFile() {
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                XposedBridge.log(e);
                throw new RuntimeException(e);
            }
        }
    }
    public String read() {
        if (contentCache == null) {
            ensureFile();
            try (var it = new FileInputStream(file)) {
                var bb = ByteBuffer.allocate(it.available());
                it.getChannel().read(bb);
                contentCache = new String(bb.array());
            } catch (IOException e) {
                XposedBridge.log(e);
            }
        }
        return contentCache;
    }
    public void write(String what) {
        contentCache = what;
        try {
            delegate = new JsonSharedPreferencesImpl(new JSONObject(what));
        } catch (JSONException ignored) {
        }
        ensureFile();
        var bb = ByteBuffer.wrap(what.getBytes());
        try (var it = new FileOutputStream(file)) {
            it.getChannel().write(bb);
        } catch (IOException e) {
            XposedBridge.log(e);
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/ManagerService.kt
================================================
```
package me.gm.cleaner.plugin.xposed
import android.content.Context
import android.content.pm.PackageInfo
import android.content.res.Resources
import android.os.*
import androidx.room.Room
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.IManagerService
import me.gm.cleaner.plugin.IMediaChangeObserver
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MIGRATION_1_2
import me.gm.cleaner.plugin.dao.MediaProviderRecordDao
import me.gm.cleaner.plugin.dao.MediaProviderRecordDatabase
import me.gm.cleaner.plugin.model.ParceledListSlice
import java.io.File
abstract class ManagerService : IManagerService.Stub() {
    lateinit var classLoader: ClassLoader
        protected set
    lateinit var resources: Resources
        protected set
    lateinit var context: Context
        private set
    private lateinit var database: MediaProviderRecordDatabase
    lateinit var dao: MediaProviderRecordDao
        private set
    private val observers = RemoteCallbackList<IMediaChangeObserver>()
    val rootSp by lazy { JsonFileSpImpl(File(context.filesDir, "root")) }
    val ruleSp by lazy { TemplatesJsonFileSpImpl(File(context.filesDir, "rule")) }
    protected fun onCreate(context: Context) {
        this.context = context
        database = Room
            .databaseBuilder(
                context,
                MediaProviderRecordDatabase::class.java,
                MEDIA_PROVIDER_USAGE_RECORD_DATABASE_NAME
            )
            .addMigrations(MIGRATION_1_2)
            .build()
        dao = database.mediaProviderRecordDao()
    }
    private val packageManagerService: IInterface by lazy {
        val binder = XposedHelpers.callStaticMethod(
            XposedHelpers.findClass("android.os.ServiceManager", classLoader),
            "getService", "package"
        ) as IBinder
        XposedHelpers.callStaticMethod(
            XposedHelpers.findClass(
                "android.content.pm.IPackageManager\$Stub", classLoader
            ), "asInterface", binder
        ) as IInterface
    }
    override fun getModuleVersion() = BuildConfig.VERSION_CODE
    override fun getInstalledPackages(userId: Int, flags: Int): ParceledListSlice<PackageInfo> {
        val parceledListSlice = XposedHelpers.callMethod(
            packageManagerService,
            "getInstalledPackages",
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) flags.toLong() else flags,
            userId
        )
        val list = XposedHelpers.callMethod(parceledListSlice, "getList") as List<PackageInfo>
        return ParceledListSlice(list)
    }
    override fun getPackageInfo(packageName: String, flags: Int, userId: Int) =
        XposedHelpers.callMethod(
            packageManagerService,
            "getPackageInfo",
            packageName,
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) flags.toLong() else flags,
            userId
        ) as? PackageInfo
    override fun readSp(who: Int): String? = when (who) {
        R.xml.root_preferences -> rootSp.read()
        R.xml.template_preferences -> ruleSp.read()
        else -> throw IllegalArgumentException()
    }
    override fun writeSp(who: Int, what: String) {
        when (who) {
            R.xml.root_preferences -> rootSp.write(what)
            R.xml.template_preferences -> ruleSp.write(what)
        }
    }
    override fun clearAllTables() {
        database.clearAllTables()
    }
    override fun packageUsageTimes(operation: Int, packageNames: List<String>) =
        dao.packageUsageTimes(operation, *packageNames.toTypedArray())
    override fun registerMediaChangeObserver(observer: IMediaChangeObserver) {
        observers.register(observer)
    }
    override fun unregisterMediaChangeObserver(observer: IMediaChangeObserver) {
        observers.unregister(observer)
    }
    @Synchronized
    fun dispatchMediaChange() {
        var i = observers.beginBroadcast()
        while (i > 0) {
            i--
            val observer = observers.getBroadcastItem(i)
            if (observer != null) {
                try {
                    observer.onChange()
                } catch (ignored: RemoteException) {
                }
            }
        }
        observers.finishBroadcast()
    }
    companion object {
        const val MEDIA_PROVIDER_USAGE_RECORD_DATABASE_NAME = "media_provider.db"
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/TemplatesJsonFileSpImpl.java
================================================
```
package me.gm.cleaner.plugin.xposed;
import java.io.File;
import me.gm.cleaner.plugin.model.Templates;
public final class TemplatesJsonFileSpImpl extends JsonFileSpImpl {
    private volatile Templates templatesCache;
    public TemplatesJsonFileSpImpl(File src) {
        super(src);
        templatesCache = new Templates(read());
    }
    @Override
    public void write(String what) {
        super.write(what);
        templatesCache = new Templates(what);
    }
    public Templates getTemplates() {
        return templatesCache;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/XposedInit.kt
================================================
```
package me.gm.cleaner.plugin.xposed
import android.content.ContentProvider
import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.ProviderInfo
import android.content.res.AssetManager
import android.content.res.Resources
import android.provider.MediaStore
import de.robv.android.xposed.*
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam
import me.gm.cleaner.plugin.xposed.hooker.DeleteHooker
import me.gm.cleaner.plugin.xposed.hooker.FileHooker
import me.gm.cleaner.plugin.xposed.hooker.InsertHooker
import me.gm.cleaner.plugin.xposed.hooker.QueryHooker
import java.io.File
class XposedInit : ManagerService(), IXposedHookLoadPackage, IXposedHookZygoteInit {
    @Throws(Throwable::class)
    private fun onMediaProviderLoaded(lpparam: LoadPackageParam, context: Context) {
        val mediaProvider = try {
            XposedHelpers.findClass(
                "com.android.providers.media.MediaProvider", lpparam.classLoader
            )
        } catch (e: XposedHelpers.ClassNotFoundError) {
            return
        }
        classLoader = lpparam.classLoader
        onCreate(context)
        XposedBridge.hookAllMethods(
            mediaProvider, "queryInternal", QueryHooker(this@XposedInit)
        )
        XposedBridge.hookAllMethods(
            mediaProvider, "insertFile", InsertHooker(this@XposedInit)
        )
        XposedBridge.hookAllMethods(
            mediaProvider, "deleteInternal", DeleteHooker(this@XposedInit)
        )
    }
    @Throws(Throwable::class)
    private fun onDownloadManagerLoaded(lpparam: LoadPackageParam, context: Context) {
        XposedHelpers.findAndHookMethod(File::class.java, "mkdir", FileHooker(this@XposedInit))
        XposedHelpers.findAndHookMethod(File::class.java, "mkdirs", FileHooker(this@XposedInit))
    }
    @Throws(Throwable::class)
    override fun handleLoadPackage(lpparam: LoadPackageParam) {
        if (lpparam.appInfo.flags and ApplicationInfo.FLAG_SYSTEM == 0) {
            return
        }
        XposedHelpers.findAndHookMethod(
            ContentProvider::class.java, "attachInfo",
            Context::class.java, ProviderInfo::class.java, Boolean::class.java,
            object : XC_MethodHook() {
                @Throws(Throwable::class)
                override fun beforeHookedMethod(param: MethodHookParam) {
                    val context = param.args[0] as Context
                    val providerInfo = param.args[1] as ProviderInfo
                    when (providerInfo.authority) {
                        MediaStore.AUTHORITY -> onMediaProviderLoaded(lpparam, context)
                        Downloads_Impl_AUTHORITY -> onDownloadManagerLoaded(lpparam, context)
                    }
                }
            }
        )
    }
    @Throws(Throwable::class)
    override fun initZygote(startupParam: IXposedHookZygoteInit.StartupParam) {
        val assetManager = AssetManager::class.java.newInstance()
        XposedHelpers.callMethod(assetManager, "addAssetPath", startupParam.modulePath)
        resources = Resources(assetManager, null, null)
    }
    companion object {
        const val Downloads_Impl_AUTHORITY = "downloads"
    }
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/DeleteHooker.kt
================================================
```
package me.gm.cleaner.plugin.xposed.hooker
import android.app.RecoverableSecurityException
import android.content.ContentResolver.QUERY_ARG_SQL_SELECTION
import android.content.ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS
import android.database.Cursor
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore.Files.FileColumns
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_DELETE
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import java.io.File
class DeleteHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        val uri = param.args[0] as Uri
        val extras = param.args[1] as? Bundle ?: Bundle.EMPTY
        val userWhere: String? = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> extras?.getString(
                QUERY_ARG_SQL_SELECTION
            )
            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> param.args[1] as? String
            else -> throw UnsupportedOperationException()
        }
        val userWhereArgs: Array<String>? = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> extras?.getStringArray(
                QUERY_ARG_SQL_SELECTION_ARGS
            )
            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> param.args[2] as? Array<String>
            else -> throw UnsupportedOperationException()
        }
        val match = param.matchUri(uri, param.isCallingPackageAllowedHidden)
        val data = mutableListOf<String>()
        val mimeType = mutableListOf<String>()
        when (match) {
            AUDIO_MEDIA_ID, VIDEO_MEDIA_ID, IMAGES_MEDIA_ID -> {
                try {
                    when {
                        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                            param.thisObject, "enforceCallingPermission", uri, extras, true
                        )
                        Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                            param.thisObject, "enforceCallingPermission", uri, true
                        )
                    }
                } catch (e: XposedHelpers.InvocationTargetError) {
                    if (e.cause is RecoverableSecurityException) {
                        return
                    }
                }
                val qb = when {
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_DELETE, match, uri,
                        extras, null
                    )
                    Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_DELETE, uri, match, null
                    )
                    else -> throw UnsupportedOperationException()
                }
                val helper = XposedHelpers.callMethod(param.thisObject, "getDatabaseForUri", uri)
                val projection = arrayOf(
                    FileColumns.MEDIA_TYPE,
                    FileColumns.DATA,
                    FileColumns._ID,
                    FileColumns.IS_DOWNLOAD,
                    FileColumns.MIME_TYPE,
                )
                val c = when {
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                        qb, "query", helper, projection, userWhere, userWhereArgs,
                        null, null, null, null, null
                    )
                    Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                        qb, "query", XposedHelpers.callMethod(helper, "getWritableDatabase"),
                        projection, userWhere, userWhereArgs, null, null, null, null, null
                    )
                    else -> throw UnsupportedOperationException()
                } as Cursor
                if (c.count == 0) {
                    c.close()
                    return
                }
                while (c.moveToNext()) {
                    data += c.getString(1)
                    mimeType += c.getString(4)
                }
                c.close()
            }
            FILES -> if (userWhereArgs != null) {
                data += userWhereArgs
                data.mapTo(mimeType) { MimeUtils.resolveMimeType(File(it)) }
            }
            else -> return 
        }
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    param.callingPackage,
                    match,
                    OP_DELETE,
                    data,
                    mimeType,
                    MutableList(data.size) { false }
                )
            )
            service.dispatchMediaChange()
        }
    }
    private val TYPE_DELETE: Int = when {
        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> 3
        Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> 2
        else -> throw UnsupportedOperationException()
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/FileHooker.kt
================================================
```
package me.gm.cleaner.plugin.xposed.hooker
import android.os.Binder
import android.os.Process
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.FileUtils
import java.io.File
class FileHooker(private val service: ManagerService) : XC_MethodHook() {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        val file = param.thisObject as File
        val path = file.absolutePath
        val uid = Binder.getCallingUid()
        val myUid = Process.myUid()
        val callingPackage = if (uid != myUid) {
            val packages = service.context.packageManager.getPackagesForUid(uid)
            packages?.firstOrNull() ?: "uid:$uid"
        } else {
            "com.android.providers.media"
        }
        val templates = service.ruleSp.templates.values.filter { it.redirectPath != null }
        for (template in templates) {
            if (!template.applyToApp.isNullOrEmpty() && 
                !template.applyToApp.contains(callingPackage) && 
                uid != myUid 
            ) {
                continue
            }
            for (filter in template.filterPath ?: emptyList()) {
                if (FileUtils.contains(filter, path)) {
                    val redirectedPath = path.replaceFirst(filter, template.redirectPath!!)
                    XposedBridge.log("MPM_FileGuard: Blocked mkdir at origin by [$callingPackage], moved to $redirectedPath")
                    val redirectedFile = File(redirectedPath)
                    if (!redirectedFile.exists()) {
                        redirectedFile.mkdirs()
                    }
                    param.result = true 
                    return
                }
            }
        }
    }
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/InsertHooker.kt
================================================
```
package me.gm.cleaner.plugin.xposed.hooker
import android.content.ClipDescription
import android.content.ContentValues
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.text.TextUtils
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedBridge
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_INSERT
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.FileUtils
import me.gm.cleaner.plugin.xposed.util.MimeUtils
import java.io.File
class InsertHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        val match = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[2] else param.args[1]
                ) as Int
        val uri = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[3] else param.args[2]
                ) as Uri
        val values = (
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) param.args[5] else param.args[3]
                ) as ContentValues
        var mimeType = values.getAsString(MediaStore.MediaColumns.MIME_TYPE)
        val wasPathEmpty = wasPathEmpty(values)
        if (wasPathEmpty) {
            ensureUniqueFileColumns(param.thisObject, match, uri, values, mimeType)
        }
        val data = values.getAsString(MediaStore.MediaColumns.DATA) ?: ""
        val callingPackage = param.callingPackage
        val templates = service.ruleSp.templates.filterTemplate(javaClass, callingPackage)
        val matchingTemplatePair = templates.values
            .filter { it.redirectPath != null }
            .flatMap { t -> t.filterPath?.map { p -> t to p } ?: emptyList() }
            .filter { (_, filterPath) -> 
                data.startsWith(filterPath) 
            }
            .maxByOrNull { it.second.length }
        var finalData = data
        var shouldIntercept = false
        if (matchingTemplatePair != null) {
            val (template, filterPath) = matchingTemplatePair
            val targetRoot = template.redirectPath!!
            finalData = data.replaceFirst(filterPath, targetRoot)
            values.put(MediaStore.MediaColumns.DATA, finalData)
            val externalPath = Environment.getExternalStorageDirectory().path
            if (finalData.startsWith(externalPath)) {
                val newFile = File(finalData)
                val relative = newFile.parentFile?.absolutePath
                    ?.substringAfter(externalPath)
                    ?.removePrefix("/")
                    ?.let { if (it.isEmpty()) it else "$it/" } ?: ""
                values.put(MediaStore.MediaColumns.RELATIVE_PATH, relative)
            }
            XposedBridge.log("MPM_Redirect: [$callingPackage] $data -> $finalData")
        } else {
            shouldIntercept = templates.applyTemplates(listOf(data), listOf(mimeType)).first()
            if (shouldIntercept) {
                param.result = null
            }
        }
        if (mimeType.isNullOrEmpty()) {
            mimeType = values.getAsString(MediaStore.MediaColumns.MIME_TYPE)
            values.remove(MediaStore.MediaColumns.MIME_TYPE)
        }
        if (wasPathEmpty) {
            values.remove(MediaStore.MediaColumns.DATA)
        }
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    callingPackage,
                    match,
                    OP_INSERT,
                    listOf(finalData),
                    listOf(mimeType ?: ""),
                    listOf(shouldIntercept)
                )
            )
            service.dispatchMediaChange()
        }
    }
    private fun wasPathEmpty(values: ContentValues) =
        !values.containsKey(MediaStore.MediaColumns.DATA)
                || values.getAsString(MediaStore.MediaColumns.DATA).isNullOrEmpty()
    private fun ensureUniqueFileColumns(
        thisObject: Any, match: Int, uri: Uri, values: ContentValues, mimeType: String?
    ) {
        var defaultMimeType = ClipDescription.MIMETYPE_UNKNOWN
        var defaultPrimary = Environment.DIRECTORY_DOWNLOADS
        var defaultSecondary: String? = null
        when (match) {
            AUDIO_MEDIA, AUDIO_MEDIA_ID -> {
                defaultMimeType = "audio/mpeg"
                defaultPrimary = Environment.DIRECTORY_MUSIC
            }
            VIDEO_MEDIA, VIDEO_MEDIA_ID -> {
                defaultMimeType = "video/mp4"
                defaultPrimary = Environment.DIRECTORY_MOVIES
            }
            IMAGES_MEDIA, IMAGES_MEDIA_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_PICTURES
            }
            AUDIO_ALBUMART, AUDIO_ALBUMART_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_MUSIC
                defaultSecondary = DIRECTORY_THUMBNAILS
            }
            VIDEO_THUMBNAILS, VIDEO_THUMBNAILS_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_MOVIES
                defaultSecondary = DIRECTORY_THUMBNAILS
            }
            IMAGES_THUMBNAILS, IMAGES_THUMBNAILS_ID -> {
                defaultMimeType = "image/jpeg"
                defaultPrimary = Environment.DIRECTORY_PICTURES
                defaultSecondary = DIRECTORY_THUMBNAILS
            }
            AUDIO_PLAYLISTS, AUDIO_PLAYLISTS_ID -> {
                defaultMimeType = "audio/mpegurl"
                defaultPrimary = Environment.DIRECTORY_MUSIC
            }
            DOWNLOADS, DOWNLOADS_ID -> {
                defaultPrimary = Environment.DIRECTORY_DOWNLOADS
            }
        }
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME))) {
            values.put(MediaStore.MediaColumns.DISPLAY_NAME, System.currentTimeMillis().toString())
        }
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.RELATIVE_PATH))) {
            val path = if (defaultSecondary != null) "$defaultPrimary/$defaultSecondary/" else "$defaultPrimary/"
            values.put(MediaStore.MediaColumns.RELATIVE_PATH, path)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val resolvedVolumeName = XposedHelpers.callMethod(thisObject, "resolveVolumeName", uri) as String
            val volumePath = XposedHelpers.callMethod(thisObject, "getVolumePath", resolvedVolumeName) as File
            val fileUtilsClass = XposedHelpers.findClass("com.android.providers.media.util.FileUtils", service.classLoader)
            val isFuseThread = XposedHelpers.callMethod(thisObject, "isFuseThread") as Boolean
            XposedHelpers.callStaticMethod(fileUtilsClass, "sanitizeValues", values, !isFuseThread)
            XposedHelpers.callStaticMethod(fileUtilsClass, "computeDataFromValues", values, volumePath, isFuseThread)
            var res = File(values.getAsString(MediaStore.MediaColumns.DATA))
            res = XposedHelpers.callStaticMethod(fileUtilsClass, "buildUniqueFile", res.parentFile, mimeType, res.name) as File
            values.put(MediaStore.MediaColumns.DATA, res.absolutePath)
        } else {
            val resolvedVolumeName = XposedHelpers.callMethod(thisObject, "resolveVolumeName", uri) as String
            val relativePath = XposedHelpers.callMethod(thisObject, "sanitizePath", values.getAsString(MediaStore.MediaColumns.RELATIVE_PATH))
            val displayName = XposedHelpers.callMethod(thisObject, "sanitizeDisplayName", values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME))
            var res = XposedHelpers.callMethod(thisObject, "getVolumePath", resolvedVolumeName) as File
            res = XposedHelpers.callStaticMethod(Environment::class.java, "buildPath", res, relativePath) as File
            res = XposedHelpers.callStaticMethod(FileUtils::class.java, "buildUniqueFile", res, mimeType, displayName) as File
            values.put(MediaStore.MediaColumns.DATA, res.absolutePath)
        }
        val displayName = values.getAsString(MediaStore.MediaColumns.DISPLAY_NAME)
        val mimeTypeFromExt = if (TextUtils.isEmpty(displayName)) null else MimeUtils.resolveMimeType(File(displayName))
        if (TextUtils.isEmpty(values.getAsString(MediaStore.MediaColumns.MIME_TYPE))) {
            values.put(MediaStore.MediaColumns.MIME_TYPE, mimeTypeFromExt ?: defaultMimeType)
        }
    }
    companion object {
        private const val DIRECTORY_THUMBNAILS = ".thumbnails"
    }
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/MediaProviderHooker.kt
================================================
```
package me.gm.cleaner.plugin.xposed.hooker
import android.net.Uri
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
interface MediaProviderHooker {
    fun XC_MethodHook.MethodHookParam.ensureMediaProvider() {
        require(method.declaringClass.name == "com.android.providers.media.MediaProvider")
    }
    val XC_MethodHook.MethodHookParam.isFuseThread: Boolean
        get() = try {
            val fuseDaemonCls = XposedHelpers.findClass(
                "com.android.providers.media.fuse.FuseDaemon", thisObject.javaClass.classLoader
            )
            XposedHelpers.callStaticMethod(fuseDaemonCls, "native_is_fuse_thread") as Boolean
        } catch (e: XposedHelpers.ClassNotFoundError) {
            false
        }
    val XC_MethodHook.MethodHookParam.callingPackage: String
        get() {
            ensureMediaProvider()
            try {
                val pkg = XposedHelpers.callMethod(thisObject, "getCallingPackage") as? String
                if (pkg != null) return pkg
            } catch (ignored: Throwable) {}
            try {
                val threadLocal = XposedHelpers.getObjectField(thisObject, "mCallingIdentity") as? ThreadLocal<*>
                val identity = threadLocal?.get()
                if (identity != null) {
                    val pkg = XposedHelpers.callMethod(identity, "getPackageName") as? String
                    if (pkg != null) return pkg
                }
            } catch (ignored: Throwable) {}
            return "com.android.providers.media"
        }
    val XC_MethodHook.MethodHookParam.isCallingPackageAllowedHidden: Boolean
        get() {
            ensureMediaProvider()
            return XposedHelpers.callMethod(thisObject, "isCallingPackageAllowedHidden") as Boolean
        }
    fun XC_MethodHook.MethodHookParam.matchUri(uri: Uri, allowHidden: Boolean): Int {
        ensureMediaProvider()
        return XposedHelpers.callMethod(thisObject, "matchUri", uri, allowHidden) as Int
    }
    val IMAGES_MEDIA: Int
        get() = 1
    val IMAGES_MEDIA_ID: Int
        get() = 2
    val IMAGES_MEDIA_ID_THUMBNAIL: Int
        get() = 3
    val IMAGES_THUMBNAILS: Int
        get() = 4
    val IMAGES_THUMBNAILS_ID: Int
        get() = 5
    val AUDIO_MEDIA: Int
        get() = 100
    val AUDIO_MEDIA_ID: Int
        get() = 101
    val AUDIO_MEDIA_ID_GENRES: Int
        get() = 102
    val AUDIO_MEDIA_ID_GENRES_ID: Int
        get() = 103
    val AUDIO_GENRES: Int
        get() = 106
    val AUDIO_GENRES_ID: Int
        get() = 107
    val AUDIO_GENRES_ID_MEMBERS: Int
        get() = 108
    val AUDIO_GENRES_ALL_MEMBERS: Int
        get() = 109
    val AUDIO_PLAYLISTS: Int
        get() = 110
    val AUDIO_PLAYLISTS_ID: Int
        get() = 111
    val AUDIO_PLAYLISTS_ID_MEMBERS: Int
        get() = 112
    val AUDIO_PLAYLISTS_ID_MEMBERS_ID: Int
        get() = 113
    val AUDIO_ARTISTS: Int
        get() = 114
    val AUDIO_ARTISTS_ID: Int
        get() = 115
    val AUDIO_ALBUMS: Int
        get() = 116
    val AUDIO_ALBUMS_ID: Int
        get() = 117
    val AUDIO_ARTISTS_ID_ALBUMS: Int
        get() = 118
    val AUDIO_ALBUMART: Int
        get() = 119
    val AUDIO_ALBUMART_ID: Int
        get() = 120
    val AUDIO_ALBUMART_FILE_ID: Int
        get() = 121
    val VIDEO_MEDIA: Int
        get() = 200
    val VIDEO_MEDIA_ID: Int
        get() = 201
    val VIDEO_MEDIA_ID_THUMBNAIL: Int
        get() = 202
    val VIDEO_THUMBNAILS: Int
        get() = 203
    val VIDEO_THUMBNAILS_ID: Int
        get() = 204
    val VOLUMES: Int
        get() = 300
    val VOLUMES_ID: Int
        get() = 301
    val MEDIA_SCANNER: Int
        get() = 500
    val FS_ID: Int
        get() = 600
    val VERSION: Int
        get() = 601
    val FILES: Int
        get() = 700
    val FILES_ID: Int
        get() = 701
    val DOWNLOADS: Int
        get() = 800
    val DOWNLOADS_ID: Int
        get() = 801
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/hooker/QueryHooker.kt
================================================
```
package me.gm.cleaner.plugin.xposed.hooker
import android.content.ContentResolver
import android.database.Cursor
import android.database.CursorWrapper
import android.database.MatrixCursor
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.CancellationSignal
import android.provider.MediaStore
import android.provider.MediaStore.Files.FileColumns
import android.util.ArraySet
import androidx.core.os.bundleOf
import de.robv.android.xposed.XC_MethodHook
import de.robv.android.xposed.XposedHelpers
import me.gm.cleaner.plugin.BuildConfig
import me.gm.cleaner.plugin.R
import me.gm.cleaner.plugin.dao.MediaProviderOperation.Companion.OP_QUERY
import me.gm.cleaner.plugin.dao.MediaProviderRecord
import me.gm.cleaner.plugin.xposed.ManagerService
import me.gm.cleaner.plugin.xposed.util.FilteredCursor
import java.util.Optional
import java.util.function.Consumer
import java.util.function.Function
class QueryHooker(private val service: ManagerService) : XC_MethodHook(), MediaProviderHooker {
    @Throws(Throwable::class)
    override fun beforeHookedMethod(param: MethodHookParam) {
        if (param.isFuseThread) {
            return
        }
        val uri = param.args[0] as Uri
        val projection = param.args[1] as? Array<String>?
        val queryArgs = param.args[2] as? Bundle ?: Bundle.EMPTY
        val signal = param.args[3] as? CancellationSignal
        if (param.callingPackage in
            setOf("com.android.providers.media", "com.android.providers.media.module")
        ) {
            return
        }
        val query = Bundle(queryArgs)
        query.remove(INCLUDED_DEFAULT_DIRECTORIES)
        val honoredArgs = ArraySet<String>()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val databaseUtilsClass = XposedHelpers.findClass(
                "com.android.providers.media.util.DatabaseUtils", service.classLoader
            )
            XposedHelpers.callStaticMethod(
                databaseUtilsClass, "resolveQueryArgs", query, object : Consumer<String> {
                    override fun accept(t: String) {
                        honoredArgs.add(t)
                    }
                }, object : Function<String, String> {
                    override fun apply(t: String) = XposedHelpers.callMethod(
                        param.thisObject, "ensureCustomCollator", t
                    ) as String
                }
            )
        }
        if (isClientQuery(param.callingPackage, uri)) {
            param.result = handleClientQuery(projection, query)
            return
        }
        val table = param.matchUri(uri, param.isCallingPackageAllowedHidden)
        val dataProjection = when {
            projection == null -> null
            table in setOf(IMAGES_THUMBNAILS, VIDEO_THUMBNAILS) -> projection + FileColumns.DATA
            else -> projection + arrayOf(FileColumns.DATA, FileColumns.MIME_TYPE)
        }
        val helper = XposedHelpers.callMethod(param.thisObject, "getDatabaseForUri", uri)
        val qb = when {
            Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> {
                val honoredArgsConsumer = object : Consumer<String> {
                    override fun accept(t: String) {
                        honoredArgs.add(t)
                    }
                }
                try {
                    XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_QUERY, table, uri, query,
                        honoredArgsConsumer, Optional.empty<Any>()
                    )
                } catch (e: NoSuchMethodError) {
                    XposedHelpers.callMethod(
                        param.thisObject, "getQueryBuilder", TYPE_QUERY, table, uri, query,
                        honoredArgsConsumer
                    )
                }
            }
            Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> XposedHelpers.callMethod(
                param.thisObject, "getQueryBuilder", TYPE_QUERY, uri, table, query
            )
            else -> throw UnsupportedOperationException()
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            val targetSdkVersion = XposedHelpers.callMethod(
                param.thisObject, "getCallingPackageTargetSdkVersion"
            ) as Int
            val databaseUtilsClass = XposedHelpers.findClass(
                "com.android.providers.media.util.DatabaseUtils", service.classLoader
            )
            if (targetSdkVersion < Build.VERSION_CODES.R) {
                XposedHelpers.callStaticMethod(databaseUtilsClass, "recoverAbusiveSortOrder", query)
                XposedHelpers.callStaticMethod(
                    databaseUtilsClass, "recoverAbusiveLimit", uri, query
                )
            }
            if (targetSdkVersion < Build.VERSION_CODES.Q) {
                XposedHelpers.callStaticMethod(databaseUtilsClass, "recoverAbusiveSelection", query)
            }
        }
        val c = try {
            when {
                Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> XposedHelpers.callMethod(
                    qb, "query", helper, dataProjection, query, signal
                )
                Build.VERSION.SDK_INT == Build.VERSION_CODES.Q -> {
                    val selection = query.getString(ContentResolver.QUERY_ARG_SQL_SELECTION)
                    val selectionArgs =
                        query.getStringArray(ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS)
                    val sortOrder =
                        query.getString(ContentResolver.QUERY_ARG_SQL_SORT_ORDER) ?: let {
                            if (query.containsKey(ContentResolver.QUERY_ARG_SORT_COLUMNS)) {
                                XposedHelpers.callStaticMethod(
                                    ContentResolver::class.java, "createSqlSortClause", query
                                ) as String?
                            } else {
                                null
                            }
                        }
                    val groupBy = if (table == AUDIO_ARTISTS_ID_ALBUMS) "audio.album_id"
                    else null
                    val having = null
                    val limit = uri.getQueryParameter("limit")
                    XposedHelpers.callMethod(
                        qb, "query", XposedHelpers.callMethod(helper, "getWritableDatabase"),
                        dataProjection, selection, selectionArgs, groupBy, having, sortOrder, limit,
                        signal
                    )
                }
                else -> throw UnsupportedOperationException()
            } as Cursor
        } catch (e: XposedHelpers.InvocationTargetError) {
            return
        }
        if (c.count == 0) {
            c.close()
            return
        }
        val callingPackage = param.callingPackage
        val templates = service.ruleSp.templates.filterTemplate(javaClass, callingPackage)
        val dataColumn = c.getColumnIndexOrThrow(FileColumns.DATA)
        val mimeTypeColumn = c.getColumnIndex(FileColumns.MIME_TYPE)
        val dataList = mutableListOf<String>()
        val mimeTypeList = mutableListOf<String>()
        while (c.moveToNext()) {
            dataList += c.getString(dataColumn) ?: ""
            mimeTypeList += if (mimeTypeColumn != -1) c.getString(mimeTypeColumn) ?: "" else ""
        }
        val redirectionMap = mutableMapOf<String, String>()
        templates.values.forEach { template ->
            val redirectPath = template.redirectPath
            if (!redirectPath.isNullOrEmpty()) {
                template.filterPath?.forEach { originalPath ->
                    redirectionMap[redirectPath] = originalPath
                }
            }
        }
        var wrappedCursor: Cursor = c
        if (redirectionMap.isNotEmpty()) {
            wrappedCursor = RedirectedCursor(c, redirectionMap)
        }
        val shouldIntercept = templates.applyTemplates(dataList, mimeTypeList)
        if (shouldIntercept.any { it }) {
            wrappedCursor.moveToFirst()
            val filter = shouldIntercept
                .mapIndexedNotNull { index, b -> if (!b) index else null }
                .toIntArray()
            param.result = FilteredCursor.createUsingFilter(wrappedCursor, filter)
        } else {
            param.result = wrappedCursor
        }
        if (service.rootSp.getBoolean(
                service.resources.getString(R.string.usage_record_key), true
            )
        ) {
            service.dao.insert(
                MediaProviderRecord(
                    0,
                    System.currentTimeMillis(),
                    callingPackage,
                    table,
                    OP_QUERY,
                    if (dataList.size < MAX_SIZE) dataList else dataList.subList(0, MAX_SIZE),
                    mimeTypeList,
                    shouldIntercept
                )
            )
            service.dispatchMediaChange()
        }
    }
    private class RedirectedCursor(cursor: Cursor, private val redirectMap: Map<String, String>) : CursorWrapper(cursor) {
        private val dataColumnIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA)
        override fun getString(columnIndex: Int): String? {
            val value = super.getString(columnIndex)
            if (columnIndex == dataColumnIndex && value != null) {
                for ((realPath, originalPath) in redirectMap) {
                    if (value.startsWith(realPath)) {
                        return value.replaceFirst(realPath, originalPath)
                    }
                }
            }
            return value
        }
    }
    private fun isClientQuery(callingPackage: String, uri: Uri) =
        callingPackage == BuildConfig.APPLICATION_ID && uri == MediaStore.Images.Media.INTERNAL_CONTENT_URI
    private fun handleClientQuery(table: Array<String>?, queryArgs: Bundle): Cursor {
        if (table == null || queryArgs.isEmpty) {
            return MatrixCursor(arrayOf("binder")).apply {
                extras = bundleOf("me.gm.cleaner.plugin.cursor.extra.BINDER" to service)
            }
        }
        val start = queryArgs.getString(ContentResolver.QUERY_ARG_SQL_SELECTION)!!.toLong()
        val end = queryArgs.getString(ContentResolver.QUERY_ARG_SQL_SORT_ORDER)!!.toLong()
        return service.dao.loadForTimeMillis(start, end, *table.map { it.toInt() }.toIntArray())
    }
    companion object {
        private const val INCLUDED_DEFAULT_DIRECTORIES = "android:included-default-directories"
        private const val TYPE_QUERY = 0
        private const val MAX_SIZE = 1000
    }
}
```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FileCreationObserver.java
================================================
```
package me.gm.cleaner.plugin.xposed.util;
import android.os.FileObserver;
import androidx.annotation.Nullable;
import java.io.File;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import java.util.function.Supplier;
public class FileCreationObserver extends FileObserver {
    private final File mTarget;
    private final Supplier<ScheduledExecutorService> mScheduler;
    private Predicate<Integer> mOnMaybeFileCreatedListener;
    private final AtomicInteger mQueueSize = new AtomicInteger();
    public FileCreationObserver(File file, Supplier<ScheduledExecutorService> scheduler) {
        super(file.getParentFile(), FileObserver.MODIFY | FileObserver.CREATE);
        mTarget = file;
        mScheduler = scheduler;
    }
    @Override
    public void onEvent(int event, @Nullable String path) {
        if (path == null) {
            return;
        }
        if (mTarget.getName().equals(path)) {
            mQueueSize.incrementAndGet();
            mScheduler.get().schedule(() -> {
                var queueSize = mQueueSize.decrementAndGet();
                var testTimes = 1 - queueSize;
                if (queueSize <= 0 && mOnMaybeFileCreatedListener.test(testTimes)) {
                    stopWatching();
                }
            }, 5, TimeUnit.SECONDS);
        }
    }
    public FileCreationObserver setOnMaybeFileCreatedListener(Predicate<Integer> l) {
        mOnMaybeFileCreatedListener = l;
        return this;
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FileUtils.kt
================================================
```
package me.gm.cleaner.plugin.xposed.util
import android.annotation.SuppressLint
import android.os.Environment
import java.io.File
object FileUtils {
    fun contains(parent: File, child: File): Boolean = contains(parent.path, child.path)
    fun contains(parent: String, child: File): Boolean = contains(parent, child.path)
    fun contains(parent: File, child: String): Boolean = contains(parent.path, child)
    fun contains(parent: String, child: String): Boolean =
        child.equals(parent, true) || parent.equals(File.separator, true) ||
                child.startsWith(parent + File.separator, true)
    val externalStorageDirPath: String = Environment.getExternalStorageDirectory().path
    val androidDir: File = File(externalStorageDirPath, "Android")
    val standardDirs: Array<String>
        @Suppress("UNCHECKED_CAST")
        @SuppressLint("SoonBlockedPrivateApi")
        get() = Environment::class.java
            .getDeclaredField("STANDARD_DIRECTORIES")
            .apply { isAccessible = true }[null] as Array<String>
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FilteredCursor.java
================================================
```
package me.gm.cleaner.plugin.xposed.util;
import android.database.CharArrayBuffer;
import android.database.Cursor;
import android.database.CursorWrapper;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
public class FilteredCursor extends CursorWrapper {
  private static final Map<Cursor, Set<FilteredCursor>> sMasterCursorMap =
          Collections.synchronizedMap(new WeakHashMap<Cursor, Set<FilteredCursor>>());
  private int[] mFilterMap;
  private int mPos = -1;
  private final Cursor mCursor;
  private boolean mClosed;
  public static FilteredCursor createUsingIdentityFilter(Cursor cursor) {
    if (cursor == null) {
      return null;
    }
    return new FilteredCursor(cursor);
  }
  public static FilteredCursor createUsingFilter(Cursor cursor, int[] filter) {
    if (cursor == null) {
      return null;
    }
    if (filter == null) {
      throw new NullPointerException();
    }
    return new FilteredCursor(cursor, filter);
  }
  private FilteredCursor(Cursor cursor) {
    this(cursor, null);
    resetToIdentityFilter();
  }
  private FilteredCursor(Cursor cursor, int[] filterMap) {
    super(cursor);
    mCursor = cursor;
    mFilterMap = filterMap;
    attachToMasterCursor();
  }
  public int[] getFilterMap() {
    return mFilterMap;
  }
  public FilteredCursor resetToIdentityFilter() {
    int count = mCursor.getCount();
    int[] filterMap = new int[count];
    for (int i = 0; i < count; i++) {
      filterMap[i] = i;
    }
    mFilterMap = filterMap;
    mPos = -1;
    return this;
  }
  public boolean isIdentityFilter() {
    int count = mCursor.getCount();
    if (mFilterMap.length != count) {
      return false;
    }
    for (int i = 0; i < count; i++) {
      if (mFilterMap[i] != i) {
        return false;
      }
    }
    return true;
  }
  public FilteredCursor refilter(int[] newArrangement) {
    final int newMapSize = newArrangement.length;
    int[] newMap = new int[newMapSize];
    for (int i = 0; i < newMapSize; i++) {
      newMap[i] = mFilterMap[newArrangement[i]];
    }
    mFilterMap = newMap;
    mPos = -1;
    return this;
  }
  public boolean isPositionEmpty() {
    return mFilterMap[mPos] == -1;
  }
  private void throwIfEmptyRow() {
    if (isPositionEmpty()) {
      throw new UnsupportedOperationException("Cannot access data in an empty row");
    }
  }
  public void swapItems(int itemOne, int itemTwo) {
    int temp = mFilterMap[itemOne];
    mFilterMap[itemOne] = mFilterMap[itemTwo];
    mFilterMap[itemTwo] = temp;
  }
  @Override
  public int getCount() {
    return mFilterMap.length;
  }
  @Override
  public int getPosition() {
    return mPos;
  }
  @Override
  public boolean moveToPosition(int position) {
    final int count = getCount();
    if (position >= count) {
      mPos = count;
      return false;
    }
    if (position < 0) {
      mPos = -1;
      return false;
    }
    final int realPosition = mFilterMap[position];
    boolean moved = realPosition == -1 || super.moveToPosition(realPosition);
    if (moved) {
      mPos = position;
    } else {
      mPos = -1;
    }
    return moved;
  }
  @Override
  public final boolean move(int offset) {
    return moveToPosition(mPos + offset);
  }
  @Override
  public final boolean moveToFirst() {
    return moveToPosition(0);
  }
  @Override
  public final boolean moveToLast() {
    return moveToPosition(getCount() - 1);
  }
  @Override
  public final boolean moveToNext() {
    return moveToPosition(mPos + 1);
  }
  @Override
  public final boolean moveToPrevious() {
    return moveToPosition(mPos - 1);
  }
  @Override
  public final boolean isFirst() {
    return mPos == 0 && getCount() != 0;
  }
  @Override
  public final boolean isLast() {
    int count = getCount();
    return mPos == (count - 1) && count != 0;
  }
  @Override
  public final boolean isBeforeFirst() {
    if (getCount() == 0) {
      return true;
    }
    return mPos == -1;
  }
  @Override
  public final boolean isAfterLast() {
    if (getCount() == 0) {
      return true;
    }
    return mPos == getCount();
  }
  @Override
  public boolean isNull(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.isNull(columnIndex);
  }
  @Override
  public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
    throwIfEmptyRow();
    mCursor.copyStringToBuffer(columnIndex, buffer);
  }
  @Override
  public byte[] getBlob(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getBlob(columnIndex);
  }
  @Override
  public double getDouble(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getDouble(columnIndex);
  }
  @Override
  public float getFloat(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getFloat(columnIndex);
  }
  @Override
  public int getInt(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getInt(columnIndex);
  }
  @Override
  public long getLong(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getLong(columnIndex);
  }
  @Override
  public short getShort(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getShort(columnIndex);
  }
  @Override
  public String getString(int columnIndex) {
    throwIfEmptyRow();
    return mCursor.getString(columnIndex);
  }
  @Override
  public boolean isClosed() {
    return mClosed || getMasterCursor().isClosed();
  }
  @Override
  public void close() {
    mClosed = true;
    Cursor masterCursor = getMasterCursor();
    Set<FilteredCursor> linkedFilteredCursorSet = sMasterCursorMap.get(masterCursor);
    if (linkedFilteredCursorSet == null) {
      super.close(); 
    } else {
      linkedFilteredCursorSet.remove(this);
      if (linkedFilteredCursorSet.isEmpty()) {
        super.close();
      }
    }
    if (masterCursor.isClosed()) {
      sMasterCursorMap.remove(masterCursor);
    }
  }
  @Override
  @Deprecated
  public boolean requery() {
    throw new UnsupportedOperationException();
  }
  private void attachToMasterCursor() {
    Cursor masterCursor = getMasterCursor();
    Set<FilteredCursor> filteredCursorSet = sMasterCursorMap.get(masterCursor);
    if (filteredCursorSet == null) {
      filteredCursorSet = Collections.synchronizedSet(new HashSet<FilteredCursor>());
      sMasterCursorMap.put(masterCursor, filteredCursorSet);
    }
    filteredCursorSet.add(this);
  }
  public Cursor getMasterCursor() {
    Cursor cursor = mCursor;
    while (cursor instanceof CursorWrapper) {
      cursor = ((CursorWrapper) cursor).getWrappedCursor();
    }
    return cursor;
  }
  public static FilteredCursor unwrapFilteredCursor(Cursor cursor) {
    while (cursor instanceof CursorWrapper) {
      if (cursor instanceof FilteredCursor) {
        return (FilteredCursor) cursor;
      } else {
        cursor = ((CursorWrapper) cursor).getWrappedCursor();
      }
    }
    return null;
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/FilteredCursorFactory.java
================================================
```
package me.gm.cleaner.plugin.xposed.util;
import android.database.Cursor;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class FilteredCursorFactory {
  private FilteredCursorFactory() {
  }
  public interface Selector {
    boolean select(Cursor cursor);
  }
  public static FilteredCursor createUsingSelector(Cursor cursor, Selector selector) {
    if (cursor == null) {
      return null;
    }
    ArrayList<Integer> filterList = new ArrayList<Integer>();
    if (cursor.moveToFirst()) {
      do {
        if (selector.select(cursor)) {
          filterList.add(cursor.getPosition());
        }
      } while (cursor.moveToNext());
    }
    return FilteredCursor.createUsingFilter(cursor, toIntArray(filterList));
  }
  public static Map<String, FilteredCursor> createGroups(Cursor cursor, String columnName) {
    if (cursor == null) {
      return null;
    }
    final int columnIndex = cursor.getColumnIndexOrThrow(columnName);
    return createGroups(cursor, columnIndex);
  }
  public static Map<String, FilteredCursor> createGroups(Cursor cursor, int columnIndex) {
    if (cursor == null) {
      return null;
    }
    Map<String, List<Integer>> filters = new HashMap<String, List<Integer>>();
    if (cursor.moveToFirst()) {
      do {
        String key = cursor.getString(columnIndex);
        List<Integer> filterList = filters.get(key);
        if (filterList == null) {
          filterList = new ArrayList<Integer>();
          filters.put(key, filterList);
        }
        filterList.add(cursor.getPosition());
      } while (cursor.moveToNext());
    }
    Map<String, FilteredCursor> groups = new HashMap<String, FilteredCursor>();
    for (Map.Entry<String, List<Integer>> entry : filters.entrySet()) {
      groups.put(entry.getKey(), FilteredCursor.createUsingFilter(cursor, toIntArray(entry.getValue())));
    }
    return groups;
  }
  public enum JoinType {
    LEFT_OUTER_JOIN,
    STRICT_LEFT_OUTER_JOIN,
    INNER_JOIN,
  }
  public static FilteredCursor createUsingJoinList(Cursor cursor, String columnName, List<String> joinList) {
    return createUsingJoinList(cursor, columnName, joinList, JoinType.STRICT_LEFT_OUTER_JOIN);
  }
  public static FilteredCursor createUsingJoinList(Cursor cursor, int columnIndex, List<String> joinList) {
    return createUsingJoinList(cursor, columnIndex, joinList, JoinType.STRICT_LEFT_OUTER_JOIN);
  }
  public static FilteredCursor createUsingJoinList(Cursor cursor, String columnName, List<String> joinList, JoinType joinType) {
    if (cursor == null) {
      return null;
    }
    final int columnIndex = cursor.getColumnIndexOrThrow(columnName);
    return createUsingJoinList(cursor, columnIndex, joinList, joinType);
  }
  public static FilteredCursor createUsingJoinList(Cursor cursor, int columnIndex, List<String> joinList, JoinType joinType) {
    if (cursor == null) {
      return null;
    }
    if (joinList == null || joinList.size() == 0) {
      return FilteredCursor.createUsingFilter(cursor, new int[0]);
    }
    int[] filterMap;
    final int filterListSize = joinList.size();
    filterMap = new int[filterListSize];
    Arrays.fill(filterMap, -1);
    Map<String, Deque<Integer>> filterValueMap = new HashMap<String, Deque<Integer>>(filterListSize);
    for (int i = 0; i < filterListSize; i++) {
      String value = joinList.get(i);
      Deque<Integer> filterIndexList = filterValueMap.get(value);
      if (filterIndexList == null) {
        filterIndexList = new ArrayDeque<Integer>();
        filterValueMap.put(value, filterIndexList);
      }
      filterIndexList.add(i);
    }
    if (cursor.moveToFirst()) {
      do {
        String value = cursor.getString(columnIndex);
        Deque<Integer> filterIndexList = filterValueMap.get(value);
        if (filterIndexList != null) {
          int cursorPosition = cursor.getPosition();
          for (Integer filterIndex : filterIndexList) {
            filterMap[filterIndex] = cursorPosition;
          }
          if (filterIndexList.size() > 1) {
            filterIndexList.removeFirst();
          } else {
            filterValueMap.remove(value);
          }
        }
      } while (cursor.moveToNext());
    }
    switch (joinType) {
      case STRICT_LEFT_OUTER_JOIN: {
        failOnEmptyPositions(cursor, filterMap, columnIndex, filterValueMap);
        break;
      }
      case INNER_JOIN: {
        filterMap = cullEmptyPositions(filterMap);
        break;
      }
      case LEFT_OUTER_JOIN: {
        break;
      }
    }
    return FilteredCursor.createUsingFilter(cursor, filterMap);
  }
  private static void failOnEmptyPositions(Cursor cursor, int[] filterMap, int columnIndex, Map<String, Deque<Integer>> filterValueMap) {
    for (Map.Entry<String, Deque<Integer>> filterMapEntry : filterValueMap.entrySet()) {
      int filterIndex = filterMapEntry.getValue().getFirst();
      if (filterMap[filterIndex] == -1) {
        throw new IllegalArgumentException("Source cursor is missing entries for the column \""
                + cursor.getColumnName(columnIndex) + "\" with values " + filterMapEntry.getKey());
      }
    }
  }
  private static int[] cullEmptyPositions(int[] filterMap) {
    int culledSize = 0;
    for (int value : filterMap) {
      if (value != -1) {
        culledSize++;
      }
    }
    int[] culledFilterMap = new int[culledSize];
    int pos = 0;
    for (int value : filterMap) {
      if (value != -1) {
        culledFilterMap[pos++] = value;
      }
    }
    return culledFilterMap;
  }
  private static int[] toIntArray(List<Integer> list) {
    int[] ret = new int[list.size()];
    int i = 0;
    for (Integer e : list)
      ret[i++] = e;
    return ret;
  }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/MimeUtils.java
================================================
```
package me.gm.cleaner.plugin.xposed.util;
import android.content.ClipDescription;
import android.mtp.MtpConstants;
import android.provider.MediaStore.Files.FileColumns;
import android.webkit.MimeTypeMap;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.File;
import java.util.Locale;
import java.util.Objects;
public class MimeUtils {
    public static boolean equalIgnoreCase(@Nullable String a, @Nullable String b) {
        return (a != null) && a.equalsIgnoreCase(b);
    }
    public static boolean startsWithIgnoreCase(@Nullable String target, @Nullable String other) {
        if (target == null || other == null) return false;
        if (other.length() > target.length()) return false;
        return target.regionMatches(true, 0, other, 0, other.length());
    }
    public static @NonNull String resolveMimeType(@NonNull File file) {
        final String extension = extractFileExtension(file.getPath());
        if (extension == null) return ClipDescription.MIMETYPE_UNKNOWN;
        final String mimeType = MimeTypeMap.getSingleton()
                .getMimeTypeFromExtension(extension.toLowerCase(Locale.ROOT));
        if (mimeType == null) return ClipDescription.MIMETYPE_UNKNOWN;
        return mimeType;
    }
    public static @Nullable String extractFileExtension(@Nullable String data) {
        if (data == null) return null;
        final int lastDot = data.lastIndexOf('.');
        if (lastDot == -1) {
            return null;
        } else {
            return data.substring(lastDot + 1);
        }
    }
    public static int resolveMediaType(@NonNull String mimeType) {
        if (isPlaylistMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_PLAYLIST;
        } else if (isSubtitleMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_SUBTITLE;
        } else if (isAudioMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_AUDIO;
        } else if (isVideoMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_VIDEO;
        } else if (isImageMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_IMAGE;
        } else if (isDocumentMimeType(mimeType)) {
            return FileColumns.MEDIA_TYPE_DOCUMENT;
        } else {
            return FileColumns.MEDIA_TYPE_NONE;
        }
    }
    public static int resolveFormatCode(@Nullable String mimeType) {
        final int mediaType = resolveMediaType(mimeType);
        switch (mediaType) {
            case FileColumns.MEDIA_TYPE_AUDIO:
                return MtpConstants.FORMAT_UNDEFINED_AUDIO;
            case FileColumns.MEDIA_TYPE_VIDEO:
                return MtpConstants.FORMAT_UNDEFINED_VIDEO;
            case FileColumns.MEDIA_TYPE_IMAGE:
                return MtpConstants.FORMAT_DEFINED;
            default:
                return MtpConstants.FORMAT_UNDEFINED;
        }
    }
    public static @NonNull String extractPrimaryType(@NonNull String mimeType) {
        final int slash = mimeType.indexOf('/');
        if (slash == -1) {
            throw new IllegalArgumentException();
        }
        return mimeType.substring(0, slash);
    }
    public static boolean isAudioMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "audio/");
    }
    public static boolean isVideoMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "video/");
    }
    public static boolean isImageMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        return startsWithIgnoreCase(mimeType, "image/");
    }
    public static boolean isPlaylistMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/vnd.apple.mpegurl":
            case "application/vnd.ms-wpl":
            case "application/x-extension-smpl":
            case "application/x-mpegurl":
            case "application/xspf+xml":
            case "audio/mpegurl":
            case "audio/x-mpegurl":
            case "audio/x-scpls":
                return true;
            default:
                return false;
        }
    }
    public static boolean isSubtitleMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/lrc":
            case "application/smil+xml":
            case "application/ttml+xml":
            case "application/x-extension-cap":
            case "application/x-extension-srt":
            case "application/x-extension-sub":
            case "application/x-extension-vtt":
            case "application/x-subrip":
            case "text/vtt":
                return true;
            default:
                return false;
        }
    }
    public static boolean isDocumentMimeType(@Nullable String mimeType) {
        if (mimeType == null) return false;
        if (startsWithIgnoreCase(mimeType, "text/")) return true;
        switch (mimeType.toLowerCase(Locale.ROOT)) {
            case "application/epub+zip":
            case "application/msword":
            case "application/pdf":
            case "application/rtf":
            case "application/vnd.ms-excel":
            case "application/vnd.ms-excel.addin.macroenabled.12":
            case "application/vnd.ms-excel.sheet.binary.macroenabled.12":
            case "application/vnd.ms-excel.sheet.macroenabled.12":
            case "application/vnd.ms-excel.template.macroenabled.12":
            case "application/vnd.ms-powerpoint":
            case "application/vnd.ms-powerpoint.addin.macroenabled.12":
            case "application/vnd.ms-powerpoint.presentation.macroenabled.12":
            case "application/vnd.ms-powerpoint.slideshow.macroenabled.12":
            case "application/vnd.ms-powerpoint.template.macroenabled.12":
            case "application/vnd.ms-word.document.macroenabled.12":
            case "application/vnd.ms-word.template.macroenabled.12":
            case "application/vnd.oasis.opendocument.chart":
            case "application/vnd.oasis.opendocument.database":
            case "application/vnd.oasis.opendocument.formula":
            case "application/vnd.oasis.opendocument.graphics":
            case "application/vnd.oasis.opendocument.graphics-template":
            case "application/vnd.oasis.opendocument.presentation":
            case "application/vnd.oasis.opendocument.presentation-template":
            case "application/vnd.oasis.opendocument.spreadsheet":
            case "application/vnd.oasis.opendocument.spreadsheet-template":
            case "application/vnd.oasis.opendocument.text":
            case "application/vnd.oasis.opendocument.text-master":
            case "application/vnd.oasis.opendocument.text-template":
            case "application/vnd.oasis.opendocument.text-web":
            case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            case "application/vnd.openxmlformats-officedocument.presentationml.template":
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            case "application/vnd.stardivision.calc":
            case "application/vnd.stardivision.chart":
            case "application/vnd.stardivision.draw":
            case "application/vnd.stardivision.impress":
            case "application/vnd.stardivision.impress-packed":
            case "application/vnd.stardivision.mail":
            case "application/vnd.stardivision.math":
            case "application/vnd.stardivision.writer":
            case "application/vnd.stardivision.writer-global":
            case "application/vnd.sun.xml.calc":
            case "application/vnd.sun.xml.calc.template":
            case "application/vnd.sun.xml.draw":
            case "application/vnd.sun.xml.draw.template":
            case "application/vnd.sun.xml.impress":
            case "application/vnd.sun.xml.impress.template":
            case "application/vnd.sun.xml.math":
            case "application/vnd.sun.xml.writer":
            case "application/vnd.sun.xml.writer.global":
            case "application/vnd.sun.xml.writer.template":
            case "application/x-mspublisher":
                return true;
            default:
                return false;
        }
    }
}

```

================================================
FILE: ./app/src/main/java/me/gm/cleaner/plugin/xposed/util/RedirectedCursor.java
================================================
```
package me.gm.cleaner.plugin.xposed.util;
import android.database.Cursor;
import android.database.CursorWrapper;
import android.provider.MediaStore;
import java.util.Map;
public class RedirectedCursor extends CursorWrapper {
    private final Map<String, String> mRedirectMap; 
    private final int mDataColumnIndex;
    public RedirectedCursor(Cursor cursor, Map<String, String> redirectMap) {
        super(cursor);
        mRedirectMap = redirectMap;
        mDataColumnIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);
    }
    @Override
    public String getString(int columnIndex) {
        String value = super.getString(columnIndex);
        if (columnIndex == mDataColumnIndex && value != null) {
            for (Map.Entry<String, String> entry : mRedirectMap.entrySet()) {
                String realPathPrefix = entry.getKey();
                if (value.startsWith(realPathPrefix)) {
                    return value.replaceFirst(realPathPrefix, entry.getValue());
                }
            }
        }
        return value;
    }
}
```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/ItemsHeightsObserver.kt
================================================
```
package me.zhanghai.android.fastscroll
import android.graphics.Canvas
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import me.gm.cleaner.plugin.ktx.getObjectField
open class ItemsHeightsObserver(list: RecyclerView, measureAllItemsOnStart: Boolean = true) :
    RecyclerView.AdapterDataObserver() {
    val itemsHeights: PrefixSumArrayList = PrefixSumArrayList()
    private val heightUndeterminedPositions: MutableList<Int> = mutableListOf()
    protected val adapter: RecyclerView.Adapter<RecyclerView.ViewHolder> = list.adapter!!
    protected val layoutManager: RecyclerView.LayoutManager = list.layoutManager!!
    open val visibleItemPositions: Iterable<Int>
        get() {
            val layoutManager = layoutManager as LinearLayoutManager
            return layoutManager.findFirstVisibleItemPosition()..
                    layoutManager.findLastVisibleItemPosition()
        }
    private val recycler: RecyclerView.Recycler
            by lazy { list.getObjectField<RecyclerView.Recycler>() }
    private fun enforceItemOffset(position: Int): Int {
        var itemView = layoutManager.findViewByPosition(position)
        var newHolderCreated = false
        if (itemView == null) {
            itemView = recycler.getViewForPosition(position)
            newHolderCreated = true
            layoutManager.measureChildWithMargins(itemView, 0, 0)
        }
        try {
            return itemView.measuredHeight
        } finally {
            if (newHolderCreated) {
                recycler.recycleView(itemView)
            }
        }
    }
    open fun getOneItemOffset(): Int = itemsHeights.firstOrNull { it > 0 }
        ?: getVisibleItemOffset((layoutManager as LinearLayoutManager).findFirstVisibleItemPosition())
    open fun guessItemOffsetAt(position: Int): Int? = null
    protected fun getVisibleItemOffset(position: Int): Int {
        val itemView = layoutManager.findViewByPosition(position) ?: return -1
        return itemView.measuredHeight
    }
    private fun enforceAllItemsOffset(measureAllItems: Boolean) {
        val oneItemOffset = if (measureAllItems) {
            0
        } else {
            getOneItemOffset()
        }
        itemsHeights.clear()
        heightUndeterminedPositions.clear()
        val visibleItemPositions = visibleItemPositions
        for (i in 0 until adapter.itemCount) {
            itemsHeights += if (measureAllItems) {
                enforceItemOffset(i)
            } else {
                if (i in visibleItemPositions) {
                    getVisibleItemOffset(i)
                } else {
                    heightUndeterminedPositions += i
                    guessItemOffsetAt(i) ?: oneItemOffset
                }
            }
        }
    }
    override fun onChanged() {
        enforceAllItemsOffset(false)
    }
    override fun onItemRangeChanged(positionStart: Int, itemCount: Int) {
        for (i in positionStart until positionStart + itemCount) {
            heightUndeterminedPositions += i
        }
    }
    override fun onItemRangeInserted(positionStart: Int, itemCount: Int) {
        for (i in 0 until heightUndeterminedPositions.size) {
            if (heightUndeterminedPositions[i] >= positionStart) {
                heightUndeterminedPositions[i] += itemCount
            }
        }
        val oneItemOffset = itemsHeights.firstOrNull { it > 0 } ?: 0
        for (i in positionStart until positionStart + itemCount) {
            val guessItemOffset = guessItemOffsetAt(i) ?: oneItemOffset
            itemsHeights.add(i, guessItemOffset)
            heightUndeterminedPositions += i
        }
    }
    override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {
        repeat(itemCount) {
            itemsHeights.removeAt(positionStart)
        }
        for (i in positionStart until positionStart + itemCount) {
            heightUndeterminedPositions -= i
        }
        for (i in 0 until heightUndeterminedPositions.size) {
            if (heightUndeterminedPositions[i] > positionStart) {
                heightUndeterminedPositions[i] -= itemCount
            }
        }
    }
    override fun onItemRangeMoved(fromPosition: Int, toPosition: Int, itemCount: Int) {
        itemsHeights.add(toPosition, itemsHeights.removeAt(fromPosition))
        if (fromPosition > toPosition) {
            for (i in 0 until heightUndeterminedPositions.size) {
                when (heightUndeterminedPositions[i]) {
                    fromPosition -> heightUndeterminedPositions[i] = toPosition
                    in toPosition until fromPosition -> heightUndeterminedPositions[i]++
                }
            }
        } else if (fromPosition < toPosition) {
            for (i in 0 until heightUndeterminedPositions.size) {
                when (heightUndeterminedPositions[i]) {
                    fromPosition -> heightUndeterminedPositions[i] = toPosition
                    in fromPosition..toPosition -> heightUndeterminedPositions[i]--
                }
            }
        }
    }
    private fun updateAllVisibleItemsOffset() {
        if (heightUndeterminedPositions.isEmpty()) {
            return
        }
        for (position in visibleItemPositions) {
            if (heightUndeterminedPositions.remove(position)) {
                val offset = getVisibleItemOffset(position)
                itemsHeights[position] = offset
            }
        }
    }
    private fun itemHeightsInitialized(): Boolean = itemsHeights.any { it > 0 }
    init {
        list.addItemDecoration(object : RecyclerView.ItemDecoration() {
            override fun onDraw(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
                if (!itemHeightsInitialized()) {
                    enforceAllItemsOffset(measureAllItemsOnStart)
                } else {
                    updateAllVisibleItemsOffset()
                }
            }
        })
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/Md3PopupBackground.java
================================================
```
package me.zhanghai.android.fastscroll;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.Matrix;
import android.graphics.Outline;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.view.View;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.graphics.drawable.DrawableCompat;
class Md3PopupBackground extends Drawable {
    @NonNull
    private final Paint mPaint;
    private final int mPaddingStart;
    private final int mPaddingEnd;
    @NonNull
    private final Path mPath = new Path();
    @NonNull
    private final Matrix mTempMatrix = new Matrix();
    public Md3PopupBackground(@NonNull Context context) {
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setColor(Utils.getColorFromAttrRes(R.attr.colorPrimary, context));
        mPaint.setStyle(Paint.Style.FILL);
        Resources resources = context.getResources();
        mPaddingStart = resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_padding_start);
        mPaddingEnd = resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_padding_end);
    }
    @Override
    public void draw(@NonNull Canvas canvas) {
        canvas.drawPath(mPath, mPaint);
    }
    @Override
    public boolean onLayoutDirectionChanged(int layoutDirection) {
        updatePath();
        return true;
    }
    @Override
    public void setAlpha(int alpha) {
    }
    @Override
    public void setColorFilter(@Nullable ColorFilter colorFilter) {
    }
    @Override
    public boolean isAutoMirrored() {
        return true;
    }
    private boolean needMirroring() {
        return DrawableCompat.getLayoutDirection(this) == View.LAYOUT_DIRECTION_RTL;
    }
    @Override
    public int getOpacity() {
        return PixelFormat.TRANSLUCENT;
    }
    @Override
    protected void onBoundsChange(@NonNull Rect bounds) {
        updatePath();
    }
    private void updatePath() {
        mPath.reset();
        Rect bounds = getBounds();
        float width = bounds.width();
        float height = bounds.height();
        float r = height / 2;
        float sqrt2 = (float) Math.sqrt(2);
        width = Math.max(r + sqrt2 * r, width);
        pathArcTo(mPath, r, r, r, 90, 180);
        float o1X = width - sqrt2 * r;
        pathArcTo(mPath, o1X, r, r, -90, 45f);
        float r2 = r / 5;
        float o2X = width - sqrt2 * r2;
        pathArcTo(mPath, o2X, r, r2, -45, 90);
        pathArcTo(mPath, o1X, r, r, 45f, 45f);
        mPath.close();
        if (needMirroring()) {
            mTempMatrix.setScale(-1, 1, width / 2, 0);
        } else {
            mTempMatrix.reset();
        }
        mTempMatrix.postTranslate(bounds.left, bounds.top);
        mPath.transform(mTempMatrix);
    }
    private static void pathArcTo(@NonNull Path path, float centerX, float centerY, float radius,
                                  float startAngle, float sweepAngle) {
        path.arcTo(centerX - radius, centerY - radius, centerX + radius, centerY + radius,
                startAngle, sweepAngle, false);
    }
    @Override
    public boolean getPadding(@NonNull Rect padding) {
        if (needMirroring()) {
            padding.set(mPaddingEnd, 0, mPaddingStart, 0);
        } else {
            padding.set(mPaddingStart, 0, mPaddingEnd, 0);
        }
        return true;
    }
    @Override
    public void getOutline(@NonNull Outline outline) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q && !mPath.isConvex()) {
            super.getOutline(outline);
            return;
        }
        outline.setConvexPath(mPath);
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/NoInterceptionRecyclerViewHelper.java
================================================
```
package me.zhanghai.android.fastscroll;
import android.view.MotionEvent;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.recyclerview.widget.RecyclerView;
public class NoInterceptionRecyclerViewHelper extends RecyclerViewHelper {
    @NonNull
    private final RecyclerView mView;
    private boolean mDragging;
    public NoInterceptionRecyclerViewHelper(@NonNull RecyclerView view,
                                            @Nullable PopupTextProvider popupTextProvider) {
        super(view, popupTextProvider);
        mView = view;
    }
    @Override
    public void addOnTouchEventListener(@NonNull Predicate<MotionEvent> onTouchEvent) {
        mView.addOnItemTouchListener(new RecyclerView.SimpleOnItemTouchListener() {
            @Override
            public boolean onInterceptTouchEvent(@NonNull RecyclerView recyclerView,
                                                 @NonNull MotionEvent event) {
                var action = event.getAction();
                var shouldInterceptTouchEvent = (action == MotionEvent.ACTION_UP ||
                        action == MotionEvent.ACTION_CANCEL) && mDragging;
                mDragging = onTouchEvent.test(event);
                return shouldInterceptTouchEvent;
            }
            @Override
            public void onTouchEvent(@NonNull RecyclerView recyclerView,
                                     @NonNull MotionEvent event) {
                onTouchEvent.test(event);
            }
        });
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PopupStyle.java
================================================
```
package me.zhanghai.android.fastscroll;
import android.content.Context;
import android.content.res.Resources;
import android.text.TextUtils;
import android.util.TypedValue;
import android.view.Gravity;
import android.widget.FrameLayout;
import android.widget.TextView;
import androidx.core.util.Consumer;
public class PopupStyle {
    private PopupStyle() {
    }
    public static Consumer<TextView> MD3 = popupView -> {
        Resources resources = popupView.getResources();
        popupView.setMinimumWidth(resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_min_width));
        popupView.setMinimumHeight(resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_min_height));
        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)
                popupView.getLayoutParams();
        layoutParams.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP;
        layoutParams.setMarginEnd(resources.getDimensionPixelOffset(
                R.dimen.afs_md2_popup_margin_end));
        popupView.setLayoutParams(layoutParams);
        Context context = popupView.getContext();
        popupView.setBackground(new Md3PopupBackground(context));
        popupView.setElevation(resources.getDimensionPixelOffset(R.dimen.afs_md2_popup_elevation));
        popupView.setEllipsize(TextUtils.TruncateAt.MIDDLE);
        popupView.setGravity(Gravity.CENTER);
        popupView.setIncludeFontPadding(false);
        popupView.setSingleLine(true);
        popupView.setTextColor(Utils.getColorFromAttrRes(android.R.attr.textColorPrimaryInverse,
                context));
        popupView.setTextSize(TypedValue.COMPLEX_UNIT_PX, resources.getDimensionPixelSize(
                R.dimen.afs_md2_popup_text_size));
    };
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PreciseRecyclerViewHelper.kt
================================================
```
package me.zhanghai.android.fastscroll
import android.graphics.Rect
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
open class PreciseRecyclerViewHelper(
    private val list: RecyclerView,
    popupTextProvider: PopupTextProvider? = null,
    measureAllItemsOnStart: Boolean = true,
    val observer: ItemsHeightsObserver = ItemsHeightsObserver(list, measureAllItemsOnStart)
) : NoInterceptionRecyclerViewHelper(list, popupTextProvider) {
    private val layoutManager: LinearLayoutManager = list.layoutManager as LinearLayoutManager
    private val mTempRect: Rect = Rect()
    private val isGridLayoutManager: Boolean =
        layoutManager is GridLayoutManager && layoutManager.spanCount > 1
    init {
        list.adapter!!.registerAdapterDataObserver(observer)
    }
    private fun calcPrefixSumForGridLayoutManager(
        requestSize: Int, prefixSum: MutableList<Int> = mutableListOf()
    ): MutableList<Int> {
        val spanSizeLookup = (layoutManager as GridLayoutManager).spanSizeLookup
        val spanCount = layoutManager.spanCount
        val chunkHeights = mutableListOf<Int>()
        while (prefixSum.size < requestSize) {
            chunkHeights.clear()
            var remainingSpan = spanCount
            while (true) {
                val position = prefixSum.size + chunkHeights.size
                if (position >= observer.itemsHeights.size) {
                    break
                }
                val spanSize = spanSizeLookup.getSpanSize(position)
                remainingSpan -= spanSize
                if (remainingSpan < 0) {
                    break 
                }
                val itemHeight = observer.itemsHeights[position]
                chunkHeights.add(itemHeight)
            }
            val newSum = (prefixSum.lastOrNull() ?: 0) + chunkHeights.max()
            repeat(chunkHeights.size) { 
                prefixSum.add(newSum)
            }
        }
        return prefixSum
    }
    override fun getScrollRange(): Int = list.paddingTop + list.paddingBottom +
            if (!isGridLayoutManager) {
                observer.itemsHeights.sum()
            } else {
                calcPrefixSumForGridLayoutManager(observer.itemsHeights.size).lastOrNull() ?: 0
            }
    override fun getScrollOffset(): Int {
        val firstItemPosition = layoutManager.getPosition(list.getChildAt(0))
        if (firstItemPosition == RecyclerView.NO_POSITION ||
            firstItemPosition >= observer.itemsHeights.size
        ) {
            return 0
        }
        val itemsHeightsSum = if (!isGridLayoutManager) {
            observer.itemsHeights.query(0, firstItemPosition)
        } else {
            calcPrefixSumForGridLayoutManager(firstItemPosition).lastOrNull() ?: 0
        }
        return list.paddingTop - getFirstItemOffset() + itemsHeightsSum
    }
    private fun getFirstItemOffset(): Int {
        if (list.childCount == 0) {
            return 0
        }
        val itemView = list.getChildAt(0)
        list.getDecoratedBoundsWithMargins(itemView, mTempRect)
        return mTempRect.top
    }
    override fun scrollTo(offset: Int) {
        list.stopScroll()
        val offset = offset - list.paddingTop
        var sum = 0
        var firstItemPosition = 0
        if (!isGridLayoutManager) {
            for (i in 0 until observer.itemsHeights.size) {
                val next = sum + observer.itemsHeights[i]
                if (next > offset) break
                sum = next
                firstItemPosition++
            }
        } else {
            val prefixSum = mutableListOf<Int>()
            for (i in 0 until observer.itemsHeights.size) {
                val next = calcPrefixSumForGridLayoutManager(firstItemPosition + 1, prefixSum)
                    .lastOrNull() ?: 0
                if (next > offset) break
                sum = next
                firstItemPosition++
            }
        }
        val firstItemTop = sum - offset
        scrollToPositionWithOffset(firstItemPosition, firstItemTop)
    }
    private fun scrollToPositionWithOffset(position: Int, offset: Int) {
        val offset = offset - list.paddingTop
        layoutManager.scrollToPositionWithOffset(position, offset)
    }
}

```

================================================
FILE: ./app/src/main/java/me/zhanghai/android/fastscroll/PrefixSumArrayList.java
================================================
```
package me.zhanghai.android.fastscroll;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
public class PrefixSumArrayList extends ArrayList<Integer> {
    private final ArrayList<Integer> prefixSum = new ArrayList<>();
    private Integer getPrefixSumBefore(final int index) {
        if (index == 0) {
            return 0;
        }
        return prefixSum.get(index - 1);
    }
    private void ensurePrefixSum(final int left, final int right) {
        if (getPrefixSumBefore(left) == null) {
            ensurePrefixSum(0, left);
        }
        if (getPrefixSumBefore(right) == null) {
            for (int i = left; i < right; i++) {
                prefixSum.set(i, getPrefixSumBefore(i) + super.get(i));
            }
        }
    }
    public int query(final int left, final int right) {
        ensurePrefixSum(left, right);
        return getPrefixSumBefore(right) - getPrefixSumBefore(left);
    }
    public int sum() {
        return query(0, super.size());
    }
    private void invalidatePrefixSum(final int index) {
        final int newSize = super.size();
        final Integer[] elementData = new Integer[newSize];
        Arrays.fill(elementData, null);
        for (int i = 0; i < index; i++) {
            if (i >= prefixSum.size()) {
                break;
            }
            final Integer val = prefixSum.get(i);
            if (val == null) {
                break;
            }
            elementData[i] = val;
        }
        prefixSum.clear();
        Collections.addAll(prefixSum, elementData);
    }
    @Override
    public void trimToSize() {
        super.trimToSize();
        prefixSum.trimToSize();
    }
    @Override
    public void ensureCapacity(final int minCapacity) {
        super.ensureCapacity(minCapacity);
        prefixSum.ensureCapacity(minCapacity);
    }
    @Override
    public Integer set(final int index, final Integer element) {
        try {
            return super.set(index, element);
        } finally {
            invalidatePrefixSum(index);
        }
    }
    @Override
    public boolean add(final Integer integer) {
        final int index = super.size();
        try {
            return super.add(integer);
        } finally {
            invalidatePrefixSum(index);
        }
    }
    @Override
    public void add(final int index, final Integer element) {
        super.add(index, element);
        invalidatePrefixSum(index);
    }
    @Override
    public Integer remove(final int index) {
        try {
            return super.remove(index);
        } finally {
            invalidatePrefixSum(index);
        }
    }
    @Override
    public boolean remove(@Nullable final Object o) {
        final int index = super.indexOf(o);
        try {
            return index != -1;
        } finally {
            remove(index);
        }
    }
    @Override
    public void clear() {
        super.clear();
        prefixSum.clear();
    }
    @Override
    public boolean addAll(@NonNull final Collection<? extends Integer> c) {
        final int index = super.size();
        try {
            return super.addAll(c);
        } finally {
            invalidatePrefixSum(index);
        }
    }
    @Override
    public boolean addAll(final int index, @NonNull final Collection<? extends Integer> c) {
        try {
            return super.addAll(index, c);
        } finally {
            invalidatePrefixSum(index);
        }
    }
    @Override
    protected void removeRange(final int fromIndex, final int toIndex) {
        super.removeRange(fromIndex, toIndex);
        invalidatePrefixSum(fromIndex);
    }
    @Override
    public boolean removeAll(@NonNull final Collection<?> c) {
        try {
            return super.removeAll(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }
    @Override
    public boolean retainAll(@NonNull final Collection<?> c) {
        try {
            return super.retainAll(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }
    @Override
    public boolean removeIf(@NonNull final Predicate<? super Integer> filter) {
        try {
            return super.removeIf(filter);
        } finally {
            invalidatePrefixSum(0);
        }
    }
    @Override
    public void replaceAll(@NonNull final UnaryOperator<Integer> operator) {
        try {
            super.replaceAll(operator);
        } finally {
            invalidatePrefixSum(0);
        }
    }
    @Override
    public void sort(@Nullable final Comparator<? super Integer> c) {
        try {
            super.sort(c);
        } finally {
            invalidatePrefixSum(0);
        }
    }
}

```

================================================
FILE: ./build.gradle
================================================
```
buildscript {
    ext {
        hiltVersion = '2.51'
        kotlinVersion = '1.9.23'
        navigationVersion = '2.7.7'
    }
    repositories {
        google()
        mavenCentral()
        jcenter()
    }
    dependencies {
        classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$navigationVersion"
        classpath 'com.android.tools.build:gradle:8.4.0'
        classpath "com.google.dagger:hilt-android-gradle-plugin:$hiltVersion"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
    }
}
plugins {
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}
allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url 'https://api.xposed.info/' }
        maven { url 'https://jitpack.io' }
        jcenter() 
    }
}
task clean(type: Delete) {
    delete rootProject.layout.buildDirectory
}
```

================================================
FILE: ./settings.gradle
================================================
```
include ':app'
rootProject.name = "Media Provider Manager"
include ':photoview'
project(':photoview').projectDir = new File('PhotoView/photoview')

```

